
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AuthUser
 * 
 */
export type AuthUser = $Result.DefaultSelection<Prisma.$AuthUserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Identity
 * 
 */
export type Identity = $Result.DefaultSelection<Prisma.$IdentityPayload>
/**
 * Model Curriculum
 * 
 */
export type Curriculum = $Result.DefaultSelection<Prisma.$CurriculumPayload>
/**
 * Model AcademicYear
 * 
 */
export type AcademicYear = $Result.DefaultSelection<Prisma.$AcademicYearPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model UserAcademicYearMapping
 * 
 */
export type UserAcademicYearMapping = $Result.DefaultSelection<Prisma.$UserAcademicYearMappingPayload>
/**
 * Model UserCurriculumMapping
 * 
 */
export type UserCurriculumMapping = $Result.DefaultSelection<Prisma.$UserCurriculumMappingPayload>
/**
 * Model UserGradeMapping
 * 
 */
export type UserGradeMapping = $Result.DefaultSelection<Prisma.$UserGradeMappingPayload>
/**
 * Model UserSubjectMapping
 * 
 */
export type UserSubjectMapping = $Result.DefaultSelection<Prisma.$UserSubjectMappingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthProvider: {
  email: 'email',
  google: 'google',
  github: 'github'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]

}

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AuthUsers
 * const authUsers = await prisma.authUser.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AuthUsers
   * const authUsers = await prisma.authUser.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/orm/prisma-client/queries/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.authUser`: Exposes CRUD operations for the **AuthUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthUsers
    * const authUsers = await prisma.authUser.findMany()
    * ```
    */
  get authUser(): Prisma.AuthUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.identity`: Exposes CRUD operations for the **Identity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Identities
    * const identities = await prisma.identity.findMany()
    * ```
    */
  get identity(): Prisma.IdentityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.curriculum`: Exposes CRUD operations for the **Curriculum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Curricula
    * const curricula = await prisma.curriculum.findMany()
    * ```
    */
  get curriculum(): Prisma.CurriculumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicYear`: Exposes CRUD operations for the **AcademicYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicYears
    * const academicYears = await prisma.academicYear.findMany()
    * ```
    */
  get academicYear(): Prisma.AcademicYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAcademicYearMapping`: Exposes CRUD operations for the **UserAcademicYearMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAcademicYearMappings
    * const userAcademicYearMappings = await prisma.userAcademicYearMapping.findMany()
    * ```
    */
  get userAcademicYearMapping(): Prisma.UserAcademicYearMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCurriculumMapping`: Exposes CRUD operations for the **UserCurriculumMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCurriculumMappings
    * const userCurriculumMappings = await prisma.userCurriculumMapping.findMany()
    * ```
    */
  get userCurriculumMapping(): Prisma.UserCurriculumMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userGradeMapping`: Exposes CRUD operations for the **UserGradeMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserGradeMappings
    * const userGradeMappings = await prisma.userGradeMapping.findMany()
    * ```
    */
  get userGradeMapping(): Prisma.UserGradeMappingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSubjectMapping`: Exposes CRUD operations for the **UserSubjectMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubjectMappings
    * const userSubjectMappings = await prisma.userSubjectMapping.findMany()
    * ```
    */
  get userSubjectMapping(): Prisma.UserSubjectMappingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.4.1
   * Query Engine version: 55ae170b1ced7fc6ed07a15f110549408c501bb3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AuthUser: 'AuthUser',
    Session: 'Session',
    Identity: 'Identity',
    Curriculum: 'Curriculum',
    AcademicYear: 'AcademicYear',
    Location: 'Location',
    Profile: 'Profile',
    Grade: 'Grade',
    Subject: 'Subject',
    Chapter: 'Chapter',
    School: 'School',
    UserAcademicYearMapping: 'UserAcademicYearMapping',
    UserCurriculumMapping: 'UserCurriculumMapping',
    UserGradeMapping: 'UserGradeMapping',
    UserSubjectMapping: 'UserSubjectMapping'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "authUser" | "session" | "identity" | "curriculum" | "academicYear" | "location" | "profile" | "grade" | "subject" | "chapter" | "school" | "userAcademicYearMapping" | "userCurriculumMapping" | "userGradeMapping" | "userSubjectMapping"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      AuthUser: {
        payload: Prisma.$AuthUserPayload<ExtArgs>
        fields: Prisma.AuthUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          findFirst: {
            args: Prisma.AuthUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          findMany: {
            args: Prisma.AuthUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
          }
          create: {
            args: Prisma.AuthUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          createMany: {
            args: Prisma.AuthUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
          }
          delete: {
            args: Prisma.AuthUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          update: {
            args: Prisma.AuthUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          deleteMany: {
            args: Prisma.AuthUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>[]
          }
          upsert: {
            args: Prisma.AuthUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthUserPayload>
          }
          aggregate: {
            args: Prisma.AuthUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthUser>
          }
          groupBy: {
            args: Prisma.AuthUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthUserCountArgs<ExtArgs>
            result: $Utils.Optional<AuthUserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Identity: {
        payload: Prisma.$IdentityPayload<ExtArgs>
        fields: Prisma.IdentityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdentityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdentityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          findFirst: {
            args: Prisma.IdentityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdentityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          findMany: {
            args: Prisma.IdentityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>[]
          }
          create: {
            args: Prisma.IdentityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          createMany: {
            args: Prisma.IdentityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdentityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>[]
          }
          delete: {
            args: Prisma.IdentityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          update: {
            args: Prisma.IdentityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          deleteMany: {
            args: Prisma.IdentityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdentityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdentityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>[]
          }
          upsert: {
            args: Prisma.IdentityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdentityPayload>
          }
          aggregate: {
            args: Prisma.IdentityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdentity>
          }
          groupBy: {
            args: Prisma.IdentityGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdentityGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdentityCountArgs<ExtArgs>
            result: $Utils.Optional<IdentityCountAggregateOutputType> | number
          }
        }
      }
      Curriculum: {
        payload: Prisma.$CurriculumPayload<ExtArgs>
        fields: Prisma.CurriculumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurriculumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurriculumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>
          }
          findFirst: {
            args: Prisma.CurriculumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurriculumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>
          }
          findMany: {
            args: Prisma.CurriculumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>[]
          }
          create: {
            args: Prisma.CurriculumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>
          }
          createMany: {
            args: Prisma.CurriculumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurriculumCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>[]
          }
          delete: {
            args: Prisma.CurriculumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>
          }
          update: {
            args: Prisma.CurriculumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>
          }
          deleteMany: {
            args: Prisma.CurriculumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurriculumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurriculumUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>[]
          }
          upsert: {
            args: Prisma.CurriculumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurriculumPayload>
          }
          aggregate: {
            args: Prisma.CurriculumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurriculum>
          }
          groupBy: {
            args: Prisma.CurriculumGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurriculumGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurriculumCountArgs<ExtArgs>
            result: $Utils.Optional<CurriculumCountAggregateOutputType> | number
          }
        }
      }
      AcademicYear: {
        payload: Prisma.$AcademicYearPayload<ExtArgs>
        fields: Prisma.AcademicYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findFirst: {
            args: Prisma.AcademicYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findMany: {
            args: Prisma.AcademicYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          create: {
            args: Prisma.AcademicYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          createMany: {
            args: Prisma.AcademicYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          delete: {
            args: Prisma.AcademicYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          update: {
            args: Prisma.AcademicYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          deleteMany: {
            args: Prisma.AcademicYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          upsert: {
            args: Prisma.AcademicYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          aggregate: {
            args: Prisma.AcademicYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicYear>
          }
          groupBy: {
            args: Prisma.AcademicYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicYearCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      UserAcademicYearMapping: {
        payload: Prisma.$UserAcademicYearMappingPayload<ExtArgs>
        fields: Prisma.UserAcademicYearMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAcademicYearMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAcademicYearMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>
          }
          findFirst: {
            args: Prisma.UserAcademicYearMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAcademicYearMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>
          }
          findMany: {
            args: Prisma.UserAcademicYearMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>[]
          }
          create: {
            args: Prisma.UserAcademicYearMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>
          }
          createMany: {
            args: Prisma.UserAcademicYearMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAcademicYearMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>[]
          }
          delete: {
            args: Prisma.UserAcademicYearMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>
          }
          update: {
            args: Prisma.UserAcademicYearMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>
          }
          deleteMany: {
            args: Prisma.UserAcademicYearMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAcademicYearMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAcademicYearMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>[]
          }
          upsert: {
            args: Prisma.UserAcademicYearMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademicYearMappingPayload>
          }
          aggregate: {
            args: Prisma.UserAcademicYearMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAcademicYearMapping>
          }
          groupBy: {
            args: Prisma.UserAcademicYearMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAcademicYearMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAcademicYearMappingCountArgs<ExtArgs>
            result: $Utils.Optional<UserAcademicYearMappingCountAggregateOutputType> | number
          }
        }
      }
      UserCurriculumMapping: {
        payload: Prisma.$UserCurriculumMappingPayload<ExtArgs>
        fields: Prisma.UserCurriculumMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCurriculumMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCurriculumMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>
          }
          findFirst: {
            args: Prisma.UserCurriculumMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCurriculumMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>
          }
          findMany: {
            args: Prisma.UserCurriculumMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>[]
          }
          create: {
            args: Prisma.UserCurriculumMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>
          }
          createMany: {
            args: Prisma.UserCurriculumMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCurriculumMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>[]
          }
          delete: {
            args: Prisma.UserCurriculumMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>
          }
          update: {
            args: Prisma.UserCurriculumMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>
          }
          deleteMany: {
            args: Prisma.UserCurriculumMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCurriculumMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCurriculumMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>[]
          }
          upsert: {
            args: Prisma.UserCurriculumMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCurriculumMappingPayload>
          }
          aggregate: {
            args: Prisma.UserCurriculumMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCurriculumMapping>
          }
          groupBy: {
            args: Prisma.UserCurriculumMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCurriculumMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCurriculumMappingCountArgs<ExtArgs>
            result: $Utils.Optional<UserCurriculumMappingCountAggregateOutputType> | number
          }
        }
      }
      UserGradeMapping: {
        payload: Prisma.$UserGradeMappingPayload<ExtArgs>
        fields: Prisma.UserGradeMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserGradeMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserGradeMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>
          }
          findFirst: {
            args: Prisma.UserGradeMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserGradeMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>
          }
          findMany: {
            args: Prisma.UserGradeMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>[]
          }
          create: {
            args: Prisma.UserGradeMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>
          }
          createMany: {
            args: Prisma.UserGradeMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserGradeMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>[]
          }
          delete: {
            args: Prisma.UserGradeMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>
          }
          update: {
            args: Prisma.UserGradeMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>
          }
          deleteMany: {
            args: Prisma.UserGradeMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserGradeMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserGradeMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>[]
          }
          upsert: {
            args: Prisma.UserGradeMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserGradeMappingPayload>
          }
          aggregate: {
            args: Prisma.UserGradeMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserGradeMapping>
          }
          groupBy: {
            args: Prisma.UserGradeMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGradeMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserGradeMappingCountArgs<ExtArgs>
            result: $Utils.Optional<UserGradeMappingCountAggregateOutputType> | number
          }
        }
      }
      UserSubjectMapping: {
        payload: Prisma.$UserSubjectMappingPayload<ExtArgs>
        fields: Prisma.UserSubjectMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubjectMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubjectMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>
          }
          findFirst: {
            args: Prisma.UserSubjectMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubjectMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>
          }
          findMany: {
            args: Prisma.UserSubjectMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>[]
          }
          create: {
            args: Prisma.UserSubjectMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>
          }
          createMany: {
            args: Prisma.UserSubjectMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubjectMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>[]
          }
          delete: {
            args: Prisma.UserSubjectMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>
          }
          update: {
            args: Prisma.UserSubjectMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>
          }
          deleteMany: {
            args: Prisma.UserSubjectMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubjectMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSubjectMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>[]
          }
          upsert: {
            args: Prisma.UserSubjectMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubjectMappingPayload>
          }
          aggregate: {
            args: Prisma.UserSubjectMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubjectMapping>
          }
          groupBy: {
            args: Prisma.UserSubjectMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubjectMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubjectMappingCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubjectMappingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    authUser?: AuthUserOmit
    session?: SessionOmit
    identity?: IdentityOmit
    curriculum?: CurriculumOmit
    academicYear?: AcademicYearOmit
    location?: LocationOmit
    profile?: ProfileOmit
    grade?: GradeOmit
    subject?: SubjectOmit
    chapter?: ChapterOmit
    school?: SchoolOmit
    userAcademicYearMapping?: UserAcademicYearMappingOmit
    userCurriculumMapping?: UserCurriculumMappingOmit
    userGradeMapping?: UserGradeMappingOmit
    userSubjectMapping?: UserSubjectMappingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AuthUserCountOutputType
   */

  export type AuthUserCountOutputType = {
    sessions: number
    identities: number
  }

  export type AuthUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AuthUserCountOutputTypeCountSessionsArgs
    identities?: boolean | AuthUserCountOutputTypeCountIdentitiesArgs
  }

  // Custom InputTypes
  /**
   * AuthUserCountOutputType without action
   */
  export type AuthUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUserCountOutputType
     */
    select?: AuthUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthUserCountOutputType without action
   */
  export type AuthUserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * AuthUserCountOutputType without action
   */
  export type AuthUserCountOutputTypeCountIdentitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityWhereInput
  }


  /**
   * Count Type CurriculumCountOutputType
   */

  export type CurriculumCountOutputType = {
    academicYears: number
    grades: number
    users: number
  }

  export type CurriculumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYears?: boolean | CurriculumCountOutputTypeCountAcademicYearsArgs
    grades?: boolean | CurriculumCountOutputTypeCountGradesArgs
    users?: boolean | CurriculumCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CurriculumCountOutputType without action
   */
  export type CurriculumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurriculumCountOutputType
     */
    select?: CurriculumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurriculumCountOutputType without action
   */
  export type CurriculumCountOutputTypeCountAcademicYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
  }

  /**
   * CurriculumCountOutputType without action
   */
  export type CurriculumCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * CurriculumCountOutputType without action
   */
  export type CurriculumCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCurriculumMappingWhereInput
  }


  /**
   * Count Type AcademicYearCountOutputType
   */

  export type AcademicYearCountOutputType = {
    users: number
  }

  export type AcademicYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AcademicYearCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYearCountOutputType
     */
    select?: AcademicYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAcademicYearMappingWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    profiles: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | LocationCountOutputTypeCountProfilesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    schools: number
    userCurriculums: number
    userGrades: number
    userSubjects: number
    academicYears: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schools?: boolean | ProfileCountOutputTypeCountSchoolsArgs
    userCurriculums?: boolean | ProfileCountOutputTypeCountUserCurriculumsArgs
    userGrades?: boolean | ProfileCountOutputTypeCountUserGradesArgs
    userSubjects?: boolean | ProfileCountOutputTypeCountUserSubjectsArgs
    academicYears?: boolean | ProfileCountOutputTypeCountAcademicYearsArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountSchoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountUserCurriculumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCurriculumMappingWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountUserGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGradeMappingWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountUserSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubjectMappingWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountAcademicYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAcademicYearMappingWhereInput
  }


  /**
   * Count Type GradeCountOutputType
   */

  export type GradeCountOutputType = {
    subjects: number
    academicYearMappings: number
    userGradeMappings: number
  }

  export type GradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | GradeCountOutputTypeCountSubjectsArgs
    academicYearMappings?: boolean | GradeCountOutputTypeCountAcademicYearMappingsArgs
    userGradeMappings?: boolean | GradeCountOutputTypeCountUserGradeMappingsArgs
  }

  // Custom InputTypes
  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeCountOutputType
     */
    select?: GradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountAcademicYearMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAcademicYearMappingWhereInput
  }

  /**
   * GradeCountOutputType without action
   */
  export type GradeCountOutputTypeCountUserGradeMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGradeMappingWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    chapters: number
    users: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | SubjectCountOutputTypeCountChaptersArgs
    users?: boolean | SubjectCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubjectMappingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model AuthUser
   */

  export type AggregateAuthUser = {
    _count: AuthUserCountAggregateOutputType | null
    _min: AuthUserMinAggregateOutputType | null
    _max: AuthUserMaxAggregateOutputType | null
  }

  export type AuthUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    emailVerifiedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type AuthUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    emailVerifiedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type AuthUserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    emailVerifiedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    profileId: number
    _all: number
  }


  export type AuthUserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    emailVerifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type AuthUserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    emailVerifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type AuthUserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    emailVerifiedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    _all?: true
  }

  export type AuthUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthUser to aggregate.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthUsers
    **/
    _count?: true | AuthUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthUserMaxAggregateInputType
  }

  export type GetAuthUserAggregateType<T extends AuthUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthUser[P]>
      : GetScalarType<T[P], AggregateAuthUser[P]>
  }




  export type AuthUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthUserWhereInput
    orderBy?: AuthUserOrderByWithAggregationInput | AuthUserOrderByWithAggregationInput[]
    by: AuthUserScalarFieldEnum[] | AuthUserScalarFieldEnum
    having?: AuthUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthUserCountAggregateInputType | true
    _min?: AuthUserMinAggregateInputType
    _max?: AuthUserMaxAggregateInputType
  }

  export type AuthUserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    emailVerifiedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    profileId: string | null
    _count: AuthUserCountAggregateOutputType | null
    _min: AuthUserMinAggregateOutputType | null
    _max: AuthUserMaxAggregateOutputType | null
  }

  type GetAuthUserGroupByPayload<T extends AuthUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthUserGroupByOutputType[P]>
            : GetScalarType<T[P], AuthUserGroupByOutputType[P]>
        }
      >
    >


  export type AuthUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    emailVerifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    sessions?: boolean | AuthUser$sessionsArgs<ExtArgs>
    identities?: boolean | AuthUser$identitiesArgs<ExtArgs>
    profile?: boolean | AuthUser$profileArgs<ExtArgs>
    _count?: boolean | AuthUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authUser"]>

  export type AuthUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    emailVerifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | AuthUser$profileArgs<ExtArgs>
  }, ExtArgs["result"]["authUser"]>

  export type AuthUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    emailVerifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | AuthUser$profileArgs<ExtArgs>
  }, ExtArgs["result"]["authUser"]>

  export type AuthUserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    emailVerifiedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
  }

  export type AuthUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "emailVerifiedAt" | "isActive" | "createdAt" | "updatedAt" | "profileId", ExtArgs["result"]["authUser"]>
  export type AuthUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AuthUser$sessionsArgs<ExtArgs>
    identities?: boolean | AuthUser$identitiesArgs<ExtArgs>
    profile?: boolean | AuthUser$profileArgs<ExtArgs>
    _count?: boolean | AuthUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | AuthUser$profileArgs<ExtArgs>
  }
  export type AuthUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | AuthUser$profileArgs<ExtArgs>
  }

  export type $AuthUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthUser"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      identities: Prisma.$IdentityPayload<ExtArgs>[]
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      emailVerifiedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      profileId: string | null
    }, ExtArgs["result"]["authUser"]>
    composites: {}
  }

  type AuthUserGetPayload<S extends boolean | null | undefined | AuthUserDefaultArgs> = $Result.GetResult<Prisma.$AuthUserPayload, S>

  type AuthUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthUserCountAggregateInputType | true
    }

  export interface AuthUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthUser'], meta: { name: 'AuthUser' } }
    /**
     * Find zero or one AuthUser that matches the filter.
     * @param {AuthUserFindUniqueArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthUserFindUniqueArgs>(args: SelectSubset<T, AuthUserFindUniqueArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthUserFindUniqueOrThrowArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserFindFirstArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthUserFindFirstArgs>(args?: SelectSubset<T, AuthUserFindFirstArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserFindFirstOrThrowArgs} args - Arguments to find a AuthUser
     * @example
     * // Get one AuthUser
     * const authUser = await prisma.authUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthUsers
     * const authUsers = await prisma.authUser.findMany()
     * 
     * // Get first 10 AuthUsers
     * const authUsers = await prisma.authUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authUserWithIdOnly = await prisma.authUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthUserFindManyArgs>(args?: SelectSubset<T, AuthUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthUser.
     * @param {AuthUserCreateArgs} args - Arguments to create a AuthUser.
     * @example
     * // Create one AuthUser
     * const AuthUser = await prisma.authUser.create({
     *   data: {
     *     // ... data to create a AuthUser
     *   }
     * })
     * 
     */
    create<T extends AuthUserCreateArgs>(args: SelectSubset<T, AuthUserCreateArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthUsers.
     * @param {AuthUserCreateManyArgs} args - Arguments to create many AuthUsers.
     * @example
     * // Create many AuthUsers
     * const authUser = await prisma.authUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthUserCreateManyArgs>(args?: SelectSubset<T, AuthUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthUsers and returns the data saved in the database.
     * @param {AuthUserCreateManyAndReturnArgs} args - Arguments to create many AuthUsers.
     * @example
     * // Create many AuthUsers
     * const authUser = await prisma.authUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthUsers and only return the `id`
     * const authUserWithIdOnly = await prisma.authUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthUser.
     * @param {AuthUserDeleteArgs} args - Arguments to delete one AuthUser.
     * @example
     * // Delete one AuthUser
     * const AuthUser = await prisma.authUser.delete({
     *   where: {
     *     // ... filter to delete one AuthUser
     *   }
     * })
     * 
     */
    delete<T extends AuthUserDeleteArgs>(args: SelectSubset<T, AuthUserDeleteArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthUser.
     * @param {AuthUserUpdateArgs} args - Arguments to update one AuthUser.
     * @example
     * // Update one AuthUser
     * const authUser = await prisma.authUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthUserUpdateArgs>(args: SelectSubset<T, AuthUserUpdateArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthUsers.
     * @param {AuthUserDeleteManyArgs} args - Arguments to filter AuthUsers to delete.
     * @example
     * // Delete a few AuthUsers
     * const { count } = await prisma.authUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthUserDeleteManyArgs>(args?: SelectSubset<T, AuthUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthUsers
     * const authUser = await prisma.authUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthUserUpdateManyArgs>(args: SelectSubset<T, AuthUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthUsers and returns the data updated in the database.
     * @param {AuthUserUpdateManyAndReturnArgs} args - Arguments to update many AuthUsers.
     * @example
     * // Update many AuthUsers
     * const authUser = await prisma.authUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthUsers and only return the `id`
     * const authUserWithIdOnly = await prisma.authUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthUserUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthUser.
     * @param {AuthUserUpsertArgs} args - Arguments to update or create a AuthUser.
     * @example
     * // Update or create a AuthUser
     * const authUser = await prisma.authUser.upsert({
     *   create: {
     *     // ... data to create a AuthUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthUser we want to update
     *   }
     * })
     */
    upsert<T extends AuthUserUpsertArgs>(args: SelectSubset<T, AuthUserUpsertArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserCountArgs} args - Arguments to filter AuthUsers to count.
     * @example
     * // Count the number of AuthUsers
     * const count = await prisma.authUser.count({
     *   where: {
     *     // ... the filter for the AuthUsers we want to count
     *   }
     * })
    **/
    count<T extends AuthUserCountArgs>(
      args?: Subset<T, AuthUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthUserAggregateArgs>(args: Subset<T, AuthUserAggregateArgs>): Prisma.PrismaPromise<GetAuthUserAggregateType<T>>

    /**
     * Group by AuthUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthUserGroupByArgs['orderBy'] }
        : { orderBy?: AuthUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthUser model
   */
  readonly fields: AuthUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends AuthUser$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, AuthUser$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    identities<T extends AuthUser$identitiesArgs<ExtArgs> = {}>(args?: Subset<T, AuthUser$identitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profile<T extends AuthUser$profileArgs<ExtArgs> = {}>(args?: Subset<T, AuthUser$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthUser model
   */
  interface AuthUserFieldRefs {
    readonly id: FieldRef<"AuthUser", 'String'>
    readonly email: FieldRef<"AuthUser", 'String'>
    readonly passwordHash: FieldRef<"AuthUser", 'String'>
    readonly emailVerifiedAt: FieldRef<"AuthUser", 'DateTime'>
    readonly isActive: FieldRef<"AuthUser", 'Boolean'>
    readonly createdAt: FieldRef<"AuthUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthUser", 'DateTime'>
    readonly profileId: FieldRef<"AuthUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuthUser findUnique
   */
  export type AuthUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser findUniqueOrThrow
   */
  export type AuthUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser findFirst
   */
  export type AuthUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthUsers.
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthUsers.
     */
    distinct?: AuthUserScalarFieldEnum | AuthUserScalarFieldEnum[]
  }

  /**
   * AuthUser findFirstOrThrow
   */
  export type AuthUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUser to fetch.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthUsers.
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthUsers.
     */
    distinct?: AuthUserScalarFieldEnum | AuthUserScalarFieldEnum[]
  }

  /**
   * AuthUser findMany
   */
  export type AuthUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter, which AuthUsers to fetch.
     */
    where?: AuthUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthUsers to fetch.
     */
    orderBy?: AuthUserOrderByWithRelationInput | AuthUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthUsers.
     */
    cursor?: AuthUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthUsers.
     */
    skip?: number
    distinct?: AuthUserScalarFieldEnum | AuthUserScalarFieldEnum[]
  }

  /**
   * AuthUser create
   */
  export type AuthUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthUser.
     */
    data: XOR<AuthUserCreateInput, AuthUserUncheckedCreateInput>
  }

  /**
   * AuthUser createMany
   */
  export type AuthUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthUsers.
     */
    data: AuthUserCreateManyInput | AuthUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthUser createManyAndReturn
   */
  export type AuthUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * The data used to create many AuthUsers.
     */
    data: AuthUserCreateManyInput | AuthUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthUser update
   */
  export type AuthUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthUser.
     */
    data: XOR<AuthUserUpdateInput, AuthUserUncheckedUpdateInput>
    /**
     * Choose, which AuthUser to update.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser updateMany
   */
  export type AuthUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthUsers.
     */
    data: XOR<AuthUserUpdateManyMutationInput, AuthUserUncheckedUpdateManyInput>
    /**
     * Filter which AuthUsers to update
     */
    where?: AuthUserWhereInput
    /**
     * Limit how many AuthUsers to update.
     */
    limit?: number
  }

  /**
   * AuthUser updateManyAndReturn
   */
  export type AuthUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * The data used to update AuthUsers.
     */
    data: XOR<AuthUserUpdateManyMutationInput, AuthUserUncheckedUpdateManyInput>
    /**
     * Filter which AuthUsers to update
     */
    where?: AuthUserWhereInput
    /**
     * Limit how many AuthUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthUser upsert
   */
  export type AuthUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthUser to update in case it exists.
     */
    where: AuthUserWhereUniqueInput
    /**
     * In case the AuthUser found by the `where` argument doesn't exist, create a new AuthUser with this data.
     */
    create: XOR<AuthUserCreateInput, AuthUserUncheckedCreateInput>
    /**
     * In case the AuthUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthUserUpdateInput, AuthUserUncheckedUpdateInput>
  }

  /**
   * AuthUser delete
   */
  export type AuthUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    /**
     * Filter which AuthUser to delete.
     */
    where: AuthUserWhereUniqueInput
  }

  /**
   * AuthUser deleteMany
   */
  export type AuthUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthUsers to delete
     */
    where?: AuthUserWhereInput
    /**
     * Limit how many AuthUsers to delete.
     */
    limit?: number
  }

  /**
   * AuthUser.sessions
   */
  export type AuthUser$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * AuthUser.identities
   */
  export type AuthUser$identitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    where?: IdentityWhereInput
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    cursor?: IdentityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * AuthUser.profile
   */
  export type AuthUser$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * AuthUser without action
   */
  export type AuthUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    authId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    authId: string | null
    refreshToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    authId: number
    refreshToken: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    authId?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    authId?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    authId?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    authId: string
    refreshToken: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    authId?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authId" | "refreshToken" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      auth: Prisma.$AuthUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authId: string
      refreshToken: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth<T extends AuthUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthUserDefaultArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly authId: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Identity
   */

  export type AggregateIdentity = {
    _count: IdentityCountAggregateOutputType | null
    _min: IdentityMinAggregateOutputType | null
    _max: IdentityMaxAggregateOutputType | null
  }

  export type IdentityMinAggregateOutputType = {
    id: string | null
    provider: $Enums.AuthProvider | null
    providerId: string | null
    authId: string | null
    createdAt: Date | null
  }

  export type IdentityMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.AuthProvider | null
    providerId: string | null
    authId: string | null
    createdAt: Date | null
  }

  export type IdentityCountAggregateOutputType = {
    id: number
    provider: number
    providerId: number
    authId: number
    createdAt: number
    _all: number
  }


  export type IdentityMinAggregateInputType = {
    id?: true
    provider?: true
    providerId?: true
    authId?: true
    createdAt?: true
  }

  export type IdentityMaxAggregateInputType = {
    id?: true
    provider?: true
    providerId?: true
    authId?: true
    createdAt?: true
  }

  export type IdentityCountAggregateInputType = {
    id?: true
    provider?: true
    providerId?: true
    authId?: true
    createdAt?: true
    _all?: true
  }

  export type IdentityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identity to aggregate.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Identities
    **/
    _count?: true | IdentityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdentityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdentityMaxAggregateInputType
  }

  export type GetIdentityAggregateType<T extends IdentityAggregateArgs> = {
        [P in keyof T & keyof AggregateIdentity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdentity[P]>
      : GetScalarType<T[P], AggregateIdentity[P]>
  }




  export type IdentityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdentityWhereInput
    orderBy?: IdentityOrderByWithAggregationInput | IdentityOrderByWithAggregationInput[]
    by: IdentityScalarFieldEnum[] | IdentityScalarFieldEnum
    having?: IdentityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdentityCountAggregateInputType | true
    _min?: IdentityMinAggregateInputType
    _max?: IdentityMaxAggregateInputType
  }

  export type IdentityGroupByOutputType = {
    id: string
    provider: $Enums.AuthProvider
    providerId: string
    authId: string
    createdAt: Date
    _count: IdentityCountAggregateOutputType | null
    _min: IdentityMinAggregateOutputType | null
    _max: IdentityMaxAggregateOutputType | null
  }

  type GetIdentityGroupByPayload<T extends IdentityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdentityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdentityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdentityGroupByOutputType[P]>
            : GetScalarType<T[P], IdentityGroupByOutputType[P]>
        }
      >
    >


  export type IdentitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerId?: boolean
    authId?: boolean
    createdAt?: boolean
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identity"]>

  export type IdentitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerId?: boolean
    authId?: boolean
    createdAt?: boolean
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identity"]>

  export type IdentitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    providerId?: boolean
    authId?: boolean
    createdAt?: boolean
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["identity"]>

  export type IdentitySelectScalar = {
    id?: boolean
    provider?: boolean
    providerId?: boolean
    authId?: boolean
    createdAt?: boolean
  }

  export type IdentityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "providerId" | "authId" | "createdAt", ExtArgs["result"]["identity"]>
  export type IdentityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }
  export type IdentityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }
  export type IdentityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | AuthUserDefaultArgs<ExtArgs>
  }

  export type $IdentityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Identity"
    objects: {
      auth: Prisma.$AuthUserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.AuthProvider
      providerId: string
      authId: string
      createdAt: Date
    }, ExtArgs["result"]["identity"]>
    composites: {}
  }

  type IdentityGetPayload<S extends boolean | null | undefined | IdentityDefaultArgs> = $Result.GetResult<Prisma.$IdentityPayload, S>

  type IdentityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdentityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdentityCountAggregateInputType | true
    }

  export interface IdentityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Identity'], meta: { name: 'Identity' } }
    /**
     * Find zero or one Identity that matches the filter.
     * @param {IdentityFindUniqueArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdentityFindUniqueArgs>(args: SelectSubset<T, IdentityFindUniqueArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Identity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdentityFindUniqueOrThrowArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdentityFindUniqueOrThrowArgs>(args: SelectSubset<T, IdentityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindFirstArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdentityFindFirstArgs>(args?: SelectSubset<T, IdentityFindFirstArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Identity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindFirstOrThrowArgs} args - Arguments to find a Identity
     * @example
     * // Get one Identity
     * const identity = await prisma.identity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdentityFindFirstOrThrowArgs>(args?: SelectSubset<T, IdentityFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Identities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Identities
     * const identities = await prisma.identity.findMany()
     * 
     * // Get first 10 Identities
     * const identities = await prisma.identity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const identityWithIdOnly = await prisma.identity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdentityFindManyArgs>(args?: SelectSubset<T, IdentityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Identity.
     * @param {IdentityCreateArgs} args - Arguments to create a Identity.
     * @example
     * // Create one Identity
     * const Identity = await prisma.identity.create({
     *   data: {
     *     // ... data to create a Identity
     *   }
     * })
     * 
     */
    create<T extends IdentityCreateArgs>(args: SelectSubset<T, IdentityCreateArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Identities.
     * @param {IdentityCreateManyArgs} args - Arguments to create many Identities.
     * @example
     * // Create many Identities
     * const identity = await prisma.identity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdentityCreateManyArgs>(args?: SelectSubset<T, IdentityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Identities and returns the data saved in the database.
     * @param {IdentityCreateManyAndReturnArgs} args - Arguments to create many Identities.
     * @example
     * // Create many Identities
     * const identity = await prisma.identity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Identities and only return the `id`
     * const identityWithIdOnly = await prisma.identity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdentityCreateManyAndReturnArgs>(args?: SelectSubset<T, IdentityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Identity.
     * @param {IdentityDeleteArgs} args - Arguments to delete one Identity.
     * @example
     * // Delete one Identity
     * const Identity = await prisma.identity.delete({
     *   where: {
     *     // ... filter to delete one Identity
     *   }
     * })
     * 
     */
    delete<T extends IdentityDeleteArgs>(args: SelectSubset<T, IdentityDeleteArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Identity.
     * @param {IdentityUpdateArgs} args - Arguments to update one Identity.
     * @example
     * // Update one Identity
     * const identity = await prisma.identity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdentityUpdateArgs>(args: SelectSubset<T, IdentityUpdateArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Identities.
     * @param {IdentityDeleteManyArgs} args - Arguments to filter Identities to delete.
     * @example
     * // Delete a few Identities
     * const { count } = await prisma.identity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdentityDeleteManyArgs>(args?: SelectSubset<T, IdentityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Identities
     * const identity = await prisma.identity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdentityUpdateManyArgs>(args: SelectSubset<T, IdentityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Identities and returns the data updated in the database.
     * @param {IdentityUpdateManyAndReturnArgs} args - Arguments to update many Identities.
     * @example
     * // Update many Identities
     * const identity = await prisma.identity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Identities and only return the `id`
     * const identityWithIdOnly = await prisma.identity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdentityUpdateManyAndReturnArgs>(args: SelectSubset<T, IdentityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Identity.
     * @param {IdentityUpsertArgs} args - Arguments to update or create a Identity.
     * @example
     * // Update or create a Identity
     * const identity = await prisma.identity.upsert({
     *   create: {
     *     // ... data to create a Identity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Identity we want to update
     *   }
     * })
     */
    upsert<T extends IdentityUpsertArgs>(args: SelectSubset<T, IdentityUpsertArgs<ExtArgs>>): Prisma__IdentityClient<$Result.GetResult<Prisma.$IdentityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Identities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityCountArgs} args - Arguments to filter Identities to count.
     * @example
     * // Count the number of Identities
     * const count = await prisma.identity.count({
     *   where: {
     *     // ... the filter for the Identities we want to count
     *   }
     * })
    **/
    count<T extends IdentityCountArgs>(
      args?: Subset<T, IdentityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdentityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Identity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdentityAggregateArgs>(args: Subset<T, IdentityAggregateArgs>): Prisma.PrismaPromise<GetIdentityAggregateType<T>>

    /**
     * Group by Identity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdentityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdentityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdentityGroupByArgs['orderBy'] }
        : { orderBy?: IdentityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdentityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdentityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Identity model
   */
  readonly fields: IdentityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Identity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdentityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth<T extends AuthUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthUserDefaultArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Identity model
   */
  interface IdentityFieldRefs {
    readonly id: FieldRef<"Identity", 'String'>
    readonly provider: FieldRef<"Identity", 'AuthProvider'>
    readonly providerId: FieldRef<"Identity", 'String'>
    readonly authId: FieldRef<"Identity", 'String'>
    readonly createdAt: FieldRef<"Identity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Identity findUnique
   */
  export type IdentityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity findUniqueOrThrow
   */
  export type IdentityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity findFirst
   */
  export type IdentityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identities.
     */
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * Identity findFirstOrThrow
   */
  export type IdentityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identity to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Identities.
     */
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * Identity findMany
   */
  export type IdentityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter, which Identities to fetch.
     */
    where?: IdentityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Identities to fetch.
     */
    orderBy?: IdentityOrderByWithRelationInput | IdentityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Identities.
     */
    cursor?: IdentityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Identities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Identities.
     */
    skip?: number
    distinct?: IdentityScalarFieldEnum | IdentityScalarFieldEnum[]
  }

  /**
   * Identity create
   */
  export type IdentityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * The data needed to create a Identity.
     */
    data: XOR<IdentityCreateInput, IdentityUncheckedCreateInput>
  }

  /**
   * Identity createMany
   */
  export type IdentityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Identities.
     */
    data: IdentityCreateManyInput | IdentityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Identity createManyAndReturn
   */
  export type IdentityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * The data used to create many Identities.
     */
    data: IdentityCreateManyInput | IdentityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Identity update
   */
  export type IdentityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * The data needed to update a Identity.
     */
    data: XOR<IdentityUpdateInput, IdentityUncheckedUpdateInput>
    /**
     * Choose, which Identity to update.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity updateMany
   */
  export type IdentityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Identities.
     */
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyInput>
    /**
     * Filter which Identities to update
     */
    where?: IdentityWhereInput
    /**
     * Limit how many Identities to update.
     */
    limit?: number
  }

  /**
   * Identity updateManyAndReturn
   */
  export type IdentityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * The data used to update Identities.
     */
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyInput>
    /**
     * Filter which Identities to update
     */
    where?: IdentityWhereInput
    /**
     * Limit how many Identities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Identity upsert
   */
  export type IdentityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * The filter to search for the Identity to update in case it exists.
     */
    where: IdentityWhereUniqueInput
    /**
     * In case the Identity found by the `where` argument doesn't exist, create a new Identity with this data.
     */
    create: XOR<IdentityCreateInput, IdentityUncheckedCreateInput>
    /**
     * In case the Identity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdentityUpdateInput, IdentityUncheckedUpdateInput>
  }

  /**
   * Identity delete
   */
  export type IdentityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
    /**
     * Filter which Identity to delete.
     */
    where: IdentityWhereUniqueInput
  }

  /**
   * Identity deleteMany
   */
  export type IdentityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Identities to delete
     */
    where?: IdentityWhereInput
    /**
     * Limit how many Identities to delete.
     */
    limit?: number
  }

  /**
   * Identity without action
   */
  export type IdentityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Identity
     */
    select?: IdentitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Identity
     */
    omit?: IdentityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdentityInclude<ExtArgs> | null
  }


  /**
   * Model Curriculum
   */

  export type AggregateCurriculum = {
    _count: CurriculumCountAggregateOutputType | null
    _avg: CurriculumAvgAggregateOutputType | null
    _sum: CurriculumSumAggregateOutputType | null
    _min: CurriculumMinAggregateOutputType | null
    _max: CurriculumMaxAggregateOutputType | null
  }

  export type CurriculumAvgAggregateOutputType = {
    id: number | null
  }

  export type CurriculumSumAggregateOutputType = {
    id: bigint | null
  }

  export type CurriculumMinAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    image: string | null
    name: string | null
    description: string | null
    isDeleted: boolean | null
  }

  export type CurriculumMaxAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    image: string | null
    name: string | null
    description: string | null
    isDeleted: boolean | null
  }

  export type CurriculumCountAggregateOutputType = {
    id: number
    createdAt: number
    image: number
    name: number
    description: number
    isDeleted: number
    _all: number
  }


  export type CurriculumAvgAggregateInputType = {
    id?: true
  }

  export type CurriculumSumAggregateInputType = {
    id?: true
  }

  export type CurriculumMinAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    name?: true
    description?: true
    isDeleted?: true
  }

  export type CurriculumMaxAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    name?: true
    description?: true
    isDeleted?: true
  }

  export type CurriculumCountAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    name?: true
    description?: true
    isDeleted?: true
    _all?: true
  }

  export type CurriculumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Curriculum to aggregate.
     */
    where?: CurriculumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Curricula to fetch.
     */
    orderBy?: CurriculumOrderByWithRelationInput | CurriculumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurriculumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Curricula from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Curricula.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Curricula
    **/
    _count?: true | CurriculumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurriculumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurriculumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurriculumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurriculumMaxAggregateInputType
  }

  export type GetCurriculumAggregateType<T extends CurriculumAggregateArgs> = {
        [P in keyof T & keyof AggregateCurriculum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurriculum[P]>
      : GetScalarType<T[P], AggregateCurriculum[P]>
  }




  export type CurriculumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurriculumWhereInput
    orderBy?: CurriculumOrderByWithAggregationInput | CurriculumOrderByWithAggregationInput[]
    by: CurriculumScalarFieldEnum[] | CurriculumScalarFieldEnum
    having?: CurriculumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurriculumCountAggregateInputType | true
    _avg?: CurriculumAvgAggregateInputType
    _sum?: CurriculumSumAggregateInputType
    _min?: CurriculumMinAggregateInputType
    _max?: CurriculumMaxAggregateInputType
  }

  export type CurriculumGroupByOutputType = {
    id: bigint
    createdAt: Date
    image: string
    name: string | null
    description: string | null
    isDeleted: boolean
    _count: CurriculumCountAggregateOutputType | null
    _avg: CurriculumAvgAggregateOutputType | null
    _sum: CurriculumSumAggregateOutputType | null
    _min: CurriculumMinAggregateOutputType | null
    _max: CurriculumMaxAggregateOutputType | null
  }

  type GetCurriculumGroupByPayload<T extends CurriculumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurriculumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurriculumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurriculumGroupByOutputType[P]>
            : GetScalarType<T[P], CurriculumGroupByOutputType[P]>
        }
      >
    >


  export type CurriculumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
    academicYears?: boolean | Curriculum$academicYearsArgs<ExtArgs>
    grades?: boolean | Curriculum$gradesArgs<ExtArgs>
    users?: boolean | Curriculum$usersArgs<ExtArgs>
    _count?: boolean | CurriculumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curriculum"]>

  export type CurriculumSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["curriculum"]>

  export type CurriculumSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["curriculum"]>

  export type CurriculumSelectScalar = {
    id?: boolean
    createdAt?: boolean
    image?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
  }

  export type CurriculumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "image" | "name" | "description" | "isDeleted", ExtArgs["result"]["curriculum"]>
  export type CurriculumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academicYears?: boolean | Curriculum$academicYearsArgs<ExtArgs>
    grades?: boolean | Curriculum$gradesArgs<ExtArgs>
    users?: boolean | Curriculum$usersArgs<ExtArgs>
    _count?: boolean | CurriculumCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurriculumIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurriculumIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurriculumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Curriculum"
    objects: {
      academicYears: Prisma.$AcademicYearPayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
      users: Prisma.$UserCurriculumMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      createdAt: Date
      image: string
      name: string | null
      description: string | null
      isDeleted: boolean
    }, ExtArgs["result"]["curriculum"]>
    composites: {}
  }

  type CurriculumGetPayload<S extends boolean | null | undefined | CurriculumDefaultArgs> = $Result.GetResult<Prisma.$CurriculumPayload, S>

  type CurriculumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurriculumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurriculumCountAggregateInputType | true
    }

  export interface CurriculumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Curriculum'], meta: { name: 'Curriculum' } }
    /**
     * Find zero or one Curriculum that matches the filter.
     * @param {CurriculumFindUniqueArgs} args - Arguments to find a Curriculum
     * @example
     * // Get one Curriculum
     * const curriculum = await prisma.curriculum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurriculumFindUniqueArgs>(args: SelectSubset<T, CurriculumFindUniqueArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Curriculum that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurriculumFindUniqueOrThrowArgs} args - Arguments to find a Curriculum
     * @example
     * // Get one Curriculum
     * const curriculum = await prisma.curriculum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurriculumFindUniqueOrThrowArgs>(args: SelectSubset<T, CurriculumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Curriculum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumFindFirstArgs} args - Arguments to find a Curriculum
     * @example
     * // Get one Curriculum
     * const curriculum = await prisma.curriculum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurriculumFindFirstArgs>(args?: SelectSubset<T, CurriculumFindFirstArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Curriculum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumFindFirstOrThrowArgs} args - Arguments to find a Curriculum
     * @example
     * // Get one Curriculum
     * const curriculum = await prisma.curriculum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurriculumFindFirstOrThrowArgs>(args?: SelectSubset<T, CurriculumFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Curricula that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Curricula
     * const curricula = await prisma.curriculum.findMany()
     * 
     * // Get first 10 Curricula
     * const curricula = await prisma.curriculum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const curriculumWithIdOnly = await prisma.curriculum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurriculumFindManyArgs>(args?: SelectSubset<T, CurriculumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Curriculum.
     * @param {CurriculumCreateArgs} args - Arguments to create a Curriculum.
     * @example
     * // Create one Curriculum
     * const Curriculum = await prisma.curriculum.create({
     *   data: {
     *     // ... data to create a Curriculum
     *   }
     * })
     * 
     */
    create<T extends CurriculumCreateArgs>(args: SelectSubset<T, CurriculumCreateArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Curricula.
     * @param {CurriculumCreateManyArgs} args - Arguments to create many Curricula.
     * @example
     * // Create many Curricula
     * const curriculum = await prisma.curriculum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurriculumCreateManyArgs>(args?: SelectSubset<T, CurriculumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Curricula and returns the data saved in the database.
     * @param {CurriculumCreateManyAndReturnArgs} args - Arguments to create many Curricula.
     * @example
     * // Create many Curricula
     * const curriculum = await prisma.curriculum.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Curricula and only return the `id`
     * const curriculumWithIdOnly = await prisma.curriculum.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurriculumCreateManyAndReturnArgs>(args?: SelectSubset<T, CurriculumCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Curriculum.
     * @param {CurriculumDeleteArgs} args - Arguments to delete one Curriculum.
     * @example
     * // Delete one Curriculum
     * const Curriculum = await prisma.curriculum.delete({
     *   where: {
     *     // ... filter to delete one Curriculum
     *   }
     * })
     * 
     */
    delete<T extends CurriculumDeleteArgs>(args: SelectSubset<T, CurriculumDeleteArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Curriculum.
     * @param {CurriculumUpdateArgs} args - Arguments to update one Curriculum.
     * @example
     * // Update one Curriculum
     * const curriculum = await prisma.curriculum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurriculumUpdateArgs>(args: SelectSubset<T, CurriculumUpdateArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Curricula.
     * @param {CurriculumDeleteManyArgs} args - Arguments to filter Curricula to delete.
     * @example
     * // Delete a few Curricula
     * const { count } = await prisma.curriculum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurriculumDeleteManyArgs>(args?: SelectSubset<T, CurriculumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Curricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Curricula
     * const curriculum = await prisma.curriculum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurriculumUpdateManyArgs>(args: SelectSubset<T, CurriculumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Curricula and returns the data updated in the database.
     * @param {CurriculumUpdateManyAndReturnArgs} args - Arguments to update many Curricula.
     * @example
     * // Update many Curricula
     * const curriculum = await prisma.curriculum.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Curricula and only return the `id`
     * const curriculumWithIdOnly = await prisma.curriculum.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurriculumUpdateManyAndReturnArgs>(args: SelectSubset<T, CurriculumUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Curriculum.
     * @param {CurriculumUpsertArgs} args - Arguments to update or create a Curriculum.
     * @example
     * // Update or create a Curriculum
     * const curriculum = await prisma.curriculum.upsert({
     *   create: {
     *     // ... data to create a Curriculum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curriculum we want to update
     *   }
     * })
     */
    upsert<T extends CurriculumUpsertArgs>(args: SelectSubset<T, CurriculumUpsertArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Curricula.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumCountArgs} args - Arguments to filter Curricula to count.
     * @example
     * // Count the number of Curricula
     * const count = await prisma.curriculum.count({
     *   where: {
     *     // ... the filter for the Curricula we want to count
     *   }
     * })
    **/
    count<T extends CurriculumCountArgs>(
      args?: Subset<T, CurriculumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurriculumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Curriculum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurriculumAggregateArgs>(args: Subset<T, CurriculumAggregateArgs>): Prisma.PrismaPromise<GetCurriculumAggregateType<T>>

    /**
     * Group by Curriculum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurriculumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurriculumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurriculumGroupByArgs['orderBy'] }
        : { orderBy?: CurriculumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurriculumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurriculumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Curriculum model
   */
  readonly fields: CurriculumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curriculum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurriculumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academicYears<T extends Curriculum$academicYearsArgs<ExtArgs> = {}>(args?: Subset<T, Curriculum$academicYearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grades<T extends Curriculum$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Curriculum$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Curriculum$usersArgs<ExtArgs> = {}>(args?: Subset<T, Curriculum$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Curriculum model
   */
  interface CurriculumFieldRefs {
    readonly id: FieldRef<"Curriculum", 'BigInt'>
    readonly createdAt: FieldRef<"Curriculum", 'DateTime'>
    readonly image: FieldRef<"Curriculum", 'String'>
    readonly name: FieldRef<"Curriculum", 'String'>
    readonly description: FieldRef<"Curriculum", 'String'>
    readonly isDeleted: FieldRef<"Curriculum", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Curriculum findUnique
   */
  export type CurriculumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * Filter, which Curriculum to fetch.
     */
    where: CurriculumWhereUniqueInput
  }

  /**
   * Curriculum findUniqueOrThrow
   */
  export type CurriculumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * Filter, which Curriculum to fetch.
     */
    where: CurriculumWhereUniqueInput
  }

  /**
   * Curriculum findFirst
   */
  export type CurriculumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * Filter, which Curriculum to fetch.
     */
    where?: CurriculumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Curricula to fetch.
     */
    orderBy?: CurriculumOrderByWithRelationInput | CurriculumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Curricula.
     */
    cursor?: CurriculumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Curricula from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Curricula.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Curricula.
     */
    distinct?: CurriculumScalarFieldEnum | CurriculumScalarFieldEnum[]
  }

  /**
   * Curriculum findFirstOrThrow
   */
  export type CurriculumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * Filter, which Curriculum to fetch.
     */
    where?: CurriculumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Curricula to fetch.
     */
    orderBy?: CurriculumOrderByWithRelationInput | CurriculumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Curricula.
     */
    cursor?: CurriculumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Curricula from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Curricula.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Curricula.
     */
    distinct?: CurriculumScalarFieldEnum | CurriculumScalarFieldEnum[]
  }

  /**
   * Curriculum findMany
   */
  export type CurriculumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * Filter, which Curricula to fetch.
     */
    where?: CurriculumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Curricula to fetch.
     */
    orderBy?: CurriculumOrderByWithRelationInput | CurriculumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Curricula.
     */
    cursor?: CurriculumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Curricula from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Curricula.
     */
    skip?: number
    distinct?: CurriculumScalarFieldEnum | CurriculumScalarFieldEnum[]
  }

  /**
   * Curriculum create
   */
  export type CurriculumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * The data needed to create a Curriculum.
     */
    data?: XOR<CurriculumCreateInput, CurriculumUncheckedCreateInput>
  }

  /**
   * Curriculum createMany
   */
  export type CurriculumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Curricula.
     */
    data: CurriculumCreateManyInput | CurriculumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Curriculum createManyAndReturn
   */
  export type CurriculumCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * The data used to create many Curricula.
     */
    data: CurriculumCreateManyInput | CurriculumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Curriculum update
   */
  export type CurriculumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * The data needed to update a Curriculum.
     */
    data: XOR<CurriculumUpdateInput, CurriculumUncheckedUpdateInput>
    /**
     * Choose, which Curriculum to update.
     */
    where: CurriculumWhereUniqueInput
  }

  /**
   * Curriculum updateMany
   */
  export type CurriculumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Curricula.
     */
    data: XOR<CurriculumUpdateManyMutationInput, CurriculumUncheckedUpdateManyInput>
    /**
     * Filter which Curricula to update
     */
    where?: CurriculumWhereInput
    /**
     * Limit how many Curricula to update.
     */
    limit?: number
  }

  /**
   * Curriculum updateManyAndReturn
   */
  export type CurriculumUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * The data used to update Curricula.
     */
    data: XOR<CurriculumUpdateManyMutationInput, CurriculumUncheckedUpdateManyInput>
    /**
     * Filter which Curricula to update
     */
    where?: CurriculumWhereInput
    /**
     * Limit how many Curricula to update.
     */
    limit?: number
  }

  /**
   * Curriculum upsert
   */
  export type CurriculumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * The filter to search for the Curriculum to update in case it exists.
     */
    where: CurriculumWhereUniqueInput
    /**
     * In case the Curriculum found by the `where` argument doesn't exist, create a new Curriculum with this data.
     */
    create: XOR<CurriculumCreateInput, CurriculumUncheckedCreateInput>
    /**
     * In case the Curriculum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurriculumUpdateInput, CurriculumUncheckedUpdateInput>
  }

  /**
   * Curriculum delete
   */
  export type CurriculumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    /**
     * Filter which Curriculum to delete.
     */
    where: CurriculumWhereUniqueInput
  }

  /**
   * Curriculum deleteMany
   */
  export type CurriculumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Curricula to delete
     */
    where?: CurriculumWhereInput
    /**
     * Limit how many Curricula to delete.
     */
    limit?: number
  }

  /**
   * Curriculum.academicYears
   */
  export type Curriculum$academicYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    cursor?: AcademicYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * Curriculum.grades
   */
  export type Curriculum$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Curriculum.users
   */
  export type Curriculum$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    where?: UserCurriculumMappingWhereInput
    orderBy?: UserCurriculumMappingOrderByWithRelationInput | UserCurriculumMappingOrderByWithRelationInput[]
    cursor?: UserCurriculumMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCurriculumMappingScalarFieldEnum | UserCurriculumMappingScalarFieldEnum[]
  }

  /**
   * Curriculum without action
   */
  export type CurriculumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
  }


  /**
   * Model AcademicYear
   */

  export type AggregateAcademicYear = {
    _count: AcademicYearCountAggregateOutputType | null
    _avg: AcademicYearAvgAggregateOutputType | null
    _sum: AcademicYearSumAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  export type AcademicYearAvgAggregateOutputType = {
    id: number | null
    curriculumId: number | null
  }

  export type AcademicYearSumAggregateOutputType = {
    id: bigint | null
    curriculumId: bigint | null
  }

  export type AcademicYearMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isActiveSession: boolean | null
    isDeleted: boolean | null
    curriculumId: bigint | null
  }

  export type AcademicYearMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isActiveSession: boolean | null
    isDeleted: boolean | null
    curriculumId: bigint | null
  }

  export type AcademicYearCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    isActiveSession: number
    isDeleted: number
    curriculumId: number
    _all: number
  }


  export type AcademicYearAvgAggregateInputType = {
    id?: true
    curriculumId?: true
  }

  export type AcademicYearSumAggregateInputType = {
    id?: true
    curriculumId?: true
  }

  export type AcademicYearMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    isActiveSession?: true
    isDeleted?: true
    curriculumId?: true
  }

  export type AcademicYearMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    isActiveSession?: true
    isDeleted?: true
    curriculumId?: true
  }

  export type AcademicYearCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    isActiveSession?: true
    isDeleted?: true
    curriculumId?: true
    _all?: true
  }

  export type AcademicYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYear to aggregate.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicYears
    **/
    _count?: true | AcademicYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicYearMaxAggregateInputType
  }

  export type GetAcademicYearAggregateType<T extends AcademicYearAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYear[P]>
      : GetScalarType<T[P], AggregateAcademicYear[P]>
  }




  export type AcademicYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithAggregationInput | AcademicYearOrderByWithAggregationInput[]
    by: AcademicYearScalarFieldEnum[] | AcademicYearScalarFieldEnum
    having?: AcademicYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicYearCountAggregateInputType | true
    _avg?: AcademicYearAvgAggregateInputType
    _sum?: AcademicYearSumAggregateInputType
    _min?: AcademicYearMinAggregateInputType
    _max?: AcademicYearMaxAggregateInputType
  }

  export type AcademicYearGroupByOutputType = {
    id: bigint
    name: string | null
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date | null
    isActiveSession: boolean | null
    isDeleted: boolean | null
    curriculumId: bigint | null
    _count: AcademicYearCountAggregateOutputType | null
    _avg: AcademicYearAvgAggregateOutputType | null
    _sum: AcademicYearSumAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  type GetAcademicYearGroupByPayload<T extends AcademicYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
        }
      >
    >


  export type AcademicYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActiveSession?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
    curriculum?: boolean | AcademicYear$curriculumArgs<ExtArgs>
    users?: boolean | AcademicYear$usersArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActiveSession?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
    curriculum?: boolean | AcademicYear$curriculumArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActiveSession?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
    curriculum?: boolean | AcademicYear$curriculumArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActiveSession?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
  }

  export type AcademicYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "isActiveSession" | "isDeleted" | "curriculumId", ExtArgs["result"]["academicYear"]>
  export type AcademicYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculum?: boolean | AcademicYear$curriculumArgs<ExtArgs>
    users?: boolean | AcademicYear$usersArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculum?: boolean | AcademicYear$curriculumArgs<ExtArgs>
  }
  export type AcademicYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculum?: boolean | AcademicYear$curriculumArgs<ExtArgs>
  }

  export type $AcademicYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicYear"
    objects: {
      curriculum: Prisma.$CurriculumPayload<ExtArgs> | null
      users: Prisma.$UserAcademicYearMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string | null
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date | null
      isActiveSession: boolean | null
      isDeleted: boolean | null
      curriculumId: bigint | null
    }, ExtArgs["result"]["academicYear"]>
    composites: {}
  }

  type AcademicYearGetPayload<S extends boolean | null | undefined | AcademicYearDefaultArgs> = $Result.GetResult<Prisma.$AcademicYearPayload, S>

  type AcademicYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicYearCountAggregateInputType | true
    }

  export interface AcademicYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicYear'], meta: { name: 'AcademicYear' } }
    /**
     * Find zero or one AcademicYear that matches the filter.
     * @param {AcademicYearFindUniqueArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearFindUniqueArgs>(args: SelectSubset<T, AcademicYearFindUniqueArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearFindUniqueOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearFindFirstArgs>(args?: SelectSubset<T, AcademicYearFindFirstArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYears
     * const academicYears = await prisma.academicYear.findMany()
     * 
     * // Get first 10 AcademicYears
     * const academicYears = await prisma.academicYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicYearFindManyArgs>(args?: SelectSubset<T, AcademicYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicYear.
     * @param {AcademicYearCreateArgs} args - Arguments to create a AcademicYear.
     * @example
     * // Create one AcademicYear
     * const AcademicYear = await prisma.academicYear.create({
     *   data: {
     *     // ... data to create a AcademicYear
     *   }
     * })
     * 
     */
    create<T extends AcademicYearCreateArgs>(args: SelectSubset<T, AcademicYearCreateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicYears.
     * @param {AcademicYearCreateManyArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicYearCreateManyArgs>(args?: SelectSubset<T, AcademicYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicYears and returns the data saved in the database.
     * @param {AcademicYearCreateManyAndReturnArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicYearCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicYear.
     * @param {AcademicYearDeleteArgs} args - Arguments to delete one AcademicYear.
     * @example
     * // Delete one AcademicYear
     * const AcademicYear = await prisma.academicYear.delete({
     *   where: {
     *     // ... filter to delete one AcademicYear
     *   }
     * })
     * 
     */
    delete<T extends AcademicYearDeleteArgs>(args: SelectSubset<T, AcademicYearDeleteArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicYear.
     * @param {AcademicYearUpdateArgs} args - Arguments to update one AcademicYear.
     * @example
     * // Update one AcademicYear
     * const academicYear = await prisma.academicYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicYearUpdateArgs>(args: SelectSubset<T, AcademicYearUpdateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicYears.
     * @param {AcademicYearDeleteManyArgs} args - Arguments to filter AcademicYears to delete.
     * @example
     * // Delete a few AcademicYears
     * const { count } = await prisma.academicYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicYearDeleteManyArgs>(args?: SelectSubset<T, AcademicYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicYearUpdateManyArgs>(args: SelectSubset<T, AcademicYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears and returns the data updated in the database.
     * @param {AcademicYearUpdateManyAndReturnArgs} args - Arguments to update many AcademicYears.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicYearUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicYear.
     * @param {AcademicYearUpsertArgs} args - Arguments to update or create a AcademicYear.
     * @example
     * // Update or create a AcademicYear
     * const academicYear = await prisma.academicYear.upsert({
     *   create: {
     *     // ... data to create a AcademicYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYear we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearUpsertArgs>(args: SelectSubset<T, AcademicYearUpsertArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearCountArgs} args - Arguments to filter AcademicYears to count.
     * @example
     * // Count the number of AcademicYears
     * const count = await prisma.academicYear.count({
     *   where: {
     *     // ... the filter for the AcademicYears we want to count
     *   }
     * })
    **/
    count<T extends AcademicYearCountArgs>(
      args?: Subset<T, AcademicYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicYearAggregateArgs>(args: Subset<T, AcademicYearAggregateArgs>): Prisma.PrismaPromise<GetAcademicYearAggregateType<T>>

    /**
     * Group by AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearGroupByArgs['orderBy'] }
        : { orderBy?: AcademicYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicYear model
   */
  readonly fields: AcademicYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curriculum<T extends AcademicYear$curriculumArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$curriculumArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends AcademicYear$usersArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicYear model
   */
  interface AcademicYearFieldRefs {
    readonly id: FieldRef<"AcademicYear", 'BigInt'>
    readonly name: FieldRef<"AcademicYear", 'String'>
    readonly startDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly endDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly createdAt: FieldRef<"AcademicYear", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicYear", 'DateTime'>
    readonly isActiveSession: FieldRef<"AcademicYear", 'Boolean'>
    readonly isDeleted: FieldRef<"AcademicYear", 'Boolean'>
    readonly curriculumId: FieldRef<"AcademicYear", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * AcademicYear findUnique
   */
  export type AcademicYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findUniqueOrThrow
   */
  export type AcademicYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findFirst
   */
  export type AcademicYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findFirstOrThrow
   */
  export type AcademicYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findMany
   */
  export type AcademicYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYears to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear create
   */
  export type AcademicYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicYear.
     */
    data: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
  }

  /**
   * AcademicYear createMany
   */
  export type AcademicYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear createManyAndReturn
   */
  export type AcademicYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicYear update
   */
  export type AcademicYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicYear.
     */
    data: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
    /**
     * Choose, which AcademicYear to update.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear updateMany
   */
  export type AcademicYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear updateManyAndReturn
   */
  export type AcademicYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicYear upsert
   */
  export type AcademicYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicYear to update in case it exists.
     */
    where: AcademicYearWhereUniqueInput
    /**
     * In case the AcademicYear found by the `where` argument doesn't exist, create a new AcademicYear with this data.
     */
    create: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
    /**
     * In case the AcademicYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
  }

  /**
   * AcademicYear delete
   */
  export type AcademicYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter which AcademicYear to delete.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear deleteMany
   */
  export type AcademicYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYears to delete
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to delete.
     */
    limit?: number
  }

  /**
   * AcademicYear.curriculum
   */
  export type AcademicYear$curriculumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    where?: CurriculumWhereInput
  }

  /**
   * AcademicYear.users
   */
  export type AcademicYear$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    where?: UserAcademicYearMappingWhereInput
    orderBy?: UserAcademicYearMappingOrderByWithRelationInput | UserAcademicYearMappingOrderByWithRelationInput[]
    cursor?: UserAcademicYearMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAcademicYearMappingScalarFieldEnum | UserAcademicYearMappingScalarFieldEnum[]
  }

  /**
   * AcademicYear without action
   */
  export type AcademicYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: bigint | null
    sortOrder: bigint | null
  }

  export type LocationMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    sortOrder: bigint | null
  }

  export type LocationMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    sortOrder: bigint | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isDeleted: number
    createdAt: number
    sortOrder: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeleted?: true
    createdAt?: true
    sortOrder?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeleted?: true
    createdAt?: true
    sortOrder?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isDeleted?: true
    createdAt?: true
    sortOrder?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: bigint
    name: string
    description: string | null
    isDeleted: boolean
    createdAt: Date
    sortOrder: bigint
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    sortOrder?: boolean
    profiles?: boolean | Location$profilesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    sortOrder?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    sortOrder?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    sortOrder?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isDeleted" | "createdAt" | "sortOrder", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | Location$profilesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      description: string | null
      isDeleted: boolean
      createdAt: Date
      sortOrder: bigint
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profiles<T extends Location$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Location$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'BigInt'>
    readonly name: FieldRef<"Location", 'String'>
    readonly description: FieldRef<"Location", 'String'>
    readonly isDeleted: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly sortOrder: FieldRef<"Location", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.profiles
   */
  export type Location$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    locationId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    locationId: bigint | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    avatarUrl: string | null
    gender: string | null
    dob: Date | null
    locationId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    userType: string | null
    phoneNumber: string | null
    email: string | null
    isDeleted: boolean | null
    isDeactivated: boolean | null
    deviceId: string | null
    fcmDeviceToken: string | null
    isNotificationEnabled: boolean | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    avatarUrl: string | null
    gender: string | null
    dob: Date | null
    locationId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    userType: string | null
    phoneNumber: string | null
    email: string | null
    isDeleted: boolean | null
    isDeactivated: boolean | null
    deviceId: string | null
    fcmDeviceToken: string | null
    isNotificationEnabled: boolean | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    fullName: number
    avatarUrl: number
    gender: number
    dob: number
    locationId: number
    createdAt: number
    updatedAt: number
    userType: number
    phoneNumber: number
    email: number
    isDeleted: number
    isDeactivated: number
    deviceId: number
    fcmDeviceToken: number
    isNotificationEnabled: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    locationId?: true
  }

  export type ProfileSumAggregateInputType = {
    locationId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    fullName?: true
    avatarUrl?: true
    gender?: true
    dob?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    userType?: true
    phoneNumber?: true
    email?: true
    isDeleted?: true
    isDeactivated?: true
    deviceId?: true
    fcmDeviceToken?: true
    isNotificationEnabled?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    fullName?: true
    avatarUrl?: true
    gender?: true
    dob?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    userType?: true
    phoneNumber?: true
    email?: true
    isDeleted?: true
    isDeactivated?: true
    deviceId?: true
    fcmDeviceToken?: true
    isNotificationEnabled?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    fullName?: true
    avatarUrl?: true
    gender?: true
    dob?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    userType?: true
    phoneNumber?: true
    email?: true
    isDeleted?: true
    isDeactivated?: true
    deviceId?: true
    fcmDeviceToken?: true
    isNotificationEnabled?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    fullName: string
    avatarUrl: string | null
    gender: string
    dob: Date | null
    locationId: bigint | null
    createdAt: Date
    updatedAt: Date | null
    userType: string
    phoneNumber: string | null
    email: string | null
    isDeleted: boolean
    isDeactivated: boolean
    deviceId: string
    fcmDeviceToken: string | null
    isNotificationEnabled: boolean
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    gender?: boolean
    dob?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userType?: boolean
    phoneNumber?: boolean
    email?: boolean
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: boolean
    fcmDeviceToken?: boolean
    isNotificationEnabled?: boolean
    location?: boolean | Profile$locationArgs<ExtArgs>
    schools?: boolean | Profile$schoolsArgs<ExtArgs>
    userCurriculums?: boolean | Profile$userCurriculumsArgs<ExtArgs>
    userGrades?: boolean | Profile$userGradesArgs<ExtArgs>
    userSubjects?: boolean | Profile$userSubjectsArgs<ExtArgs>
    academicYears?: boolean | Profile$academicYearsArgs<ExtArgs>
    authUser?: boolean | Profile$authUserArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    gender?: boolean
    dob?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userType?: boolean
    phoneNumber?: boolean
    email?: boolean
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: boolean
    fcmDeviceToken?: boolean
    isNotificationEnabled?: boolean
    location?: boolean | Profile$locationArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    gender?: boolean
    dob?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userType?: boolean
    phoneNumber?: boolean
    email?: boolean
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: boolean
    fcmDeviceToken?: boolean
    isNotificationEnabled?: boolean
    location?: boolean | Profile$locationArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    fullName?: boolean
    avatarUrl?: boolean
    gender?: boolean
    dob?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userType?: boolean
    phoneNumber?: boolean
    email?: boolean
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: boolean
    fcmDeviceToken?: boolean
    isNotificationEnabled?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "avatarUrl" | "gender" | "dob" | "locationId" | "createdAt" | "updatedAt" | "userType" | "phoneNumber" | "email" | "isDeleted" | "isDeactivated" | "deviceId" | "fcmDeviceToken" | "isNotificationEnabled", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Profile$locationArgs<ExtArgs>
    schools?: boolean | Profile$schoolsArgs<ExtArgs>
    userCurriculums?: boolean | Profile$userCurriculumsArgs<ExtArgs>
    userGrades?: boolean | Profile$userGradesArgs<ExtArgs>
    userSubjects?: boolean | Profile$userSubjectsArgs<ExtArgs>
    academicYears?: boolean | Profile$academicYearsArgs<ExtArgs>
    authUser?: boolean | Profile$authUserArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Profile$locationArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Profile$locationArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
      schools: Prisma.$SchoolPayload<ExtArgs>[]
      userCurriculums: Prisma.$UserCurriculumMappingPayload<ExtArgs>[]
      userGrades: Prisma.$UserGradeMappingPayload<ExtArgs>[]
      userSubjects: Prisma.$UserSubjectMappingPayload<ExtArgs>[]
      academicYears: Prisma.$UserAcademicYearMappingPayload<ExtArgs>[]
      authUser: Prisma.$AuthUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      avatarUrl: string | null
      gender: string
      dob: Date | null
      locationId: bigint | null
      createdAt: Date
      updatedAt: Date | null
      userType: string
      phoneNumber: string | null
      email: string | null
      isDeleted: boolean
      isDeactivated: boolean
      deviceId: string
      fcmDeviceToken: string | null
      isNotificationEnabled: boolean
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends Profile$locationArgs<ExtArgs> = {}>(args?: Subset<T, Profile$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schools<T extends Profile$schoolsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$schoolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userCurriculums<T extends Profile$userCurriculumsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$userCurriculumsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userGrades<T extends Profile$userGradesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$userGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSubjects<T extends Profile$userSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$userSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicYears<T extends Profile$academicYearsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$academicYearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authUser<T extends Profile$authUserArgs<ExtArgs> = {}>(args?: Subset<T, Profile$authUserArgs<ExtArgs>>): Prisma__AuthUserClient<$Result.GetResult<Prisma.$AuthUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly fullName: FieldRef<"Profile", 'String'>
    readonly avatarUrl: FieldRef<"Profile", 'String'>
    readonly gender: FieldRef<"Profile", 'String'>
    readonly dob: FieldRef<"Profile", 'DateTime'>
    readonly locationId: FieldRef<"Profile", 'BigInt'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly userType: FieldRef<"Profile", 'String'>
    readonly phoneNumber: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly isDeleted: FieldRef<"Profile", 'Boolean'>
    readonly isDeactivated: FieldRef<"Profile", 'Boolean'>
    readonly deviceId: FieldRef<"Profile", 'String'>
    readonly fcmDeviceToken: FieldRef<"Profile", 'String'>
    readonly isNotificationEnabled: FieldRef<"Profile", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.location
   */
  export type Profile$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Profile.schools
   */
  export type Profile$schoolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    cursor?: SchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * Profile.userCurriculums
   */
  export type Profile$userCurriculumsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    where?: UserCurriculumMappingWhereInput
    orderBy?: UserCurriculumMappingOrderByWithRelationInput | UserCurriculumMappingOrderByWithRelationInput[]
    cursor?: UserCurriculumMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCurriculumMappingScalarFieldEnum | UserCurriculumMappingScalarFieldEnum[]
  }

  /**
   * Profile.userGrades
   */
  export type Profile$userGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    where?: UserGradeMappingWhereInput
    orderBy?: UserGradeMappingOrderByWithRelationInput | UserGradeMappingOrderByWithRelationInput[]
    cursor?: UserGradeMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGradeMappingScalarFieldEnum | UserGradeMappingScalarFieldEnum[]
  }

  /**
   * Profile.userSubjects
   */
  export type Profile$userSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    where?: UserSubjectMappingWhereInput
    orderBy?: UserSubjectMappingOrderByWithRelationInput | UserSubjectMappingOrderByWithRelationInput[]
    cursor?: UserSubjectMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubjectMappingScalarFieldEnum | UserSubjectMappingScalarFieldEnum[]
  }

  /**
   * Profile.academicYears
   */
  export type Profile$academicYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    where?: UserAcademicYearMappingWhereInput
    orderBy?: UserAcademicYearMappingOrderByWithRelationInput | UserAcademicYearMappingOrderByWithRelationInput[]
    cursor?: UserAcademicYearMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAcademicYearMappingScalarFieldEnum | UserAcademicYearMappingScalarFieldEnum[]
  }

  /**
   * Profile.authUser
   */
  export type Profile$authUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthUser
     */
    select?: AuthUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthUser
     */
    omit?: AuthUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthUserInclude<ExtArgs> | null
    where?: AuthUserWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    id: number | null
    curriculumId: number | null
  }

  export type GradeSumAggregateOutputType = {
    id: bigint | null
    curriculumId: bigint | null
  }

  export type GradeMinAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    image: string | null
    description: string | null
    name: string | null
    isDeleted: boolean | null
    curriculumId: bigint | null
  }

  export type GradeMaxAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    image: string | null
    description: string | null
    name: string | null
    isDeleted: boolean | null
    curriculumId: bigint | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    createdAt: number
    image: number
    description: number
    name: number
    isDeleted: number
    curriculumId: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    id?: true
    curriculumId?: true
  }

  export type GradeSumAggregateInputType = {
    id?: true
    curriculumId?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    description?: true
    name?: true
    isDeleted?: true
    curriculumId?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    description?: true
    name?: true
    isDeleted?: true
    curriculumId?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    createdAt?: true
    image?: true
    description?: true
    name?: true
    isDeleted?: true
    curriculumId?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: bigint
    createdAt: Date
    image: string | null
    description: string | null
    name: string | null
    isDeleted: boolean
    curriculumId: bigint | null
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    image?: boolean
    description?: boolean
    name?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
    curriculum?: boolean | Grade$curriculumArgs<ExtArgs>
    subjects?: boolean | Grade$subjectsArgs<ExtArgs>
    academicYearMappings?: boolean | Grade$academicYearMappingsArgs<ExtArgs>
    userGradeMappings?: boolean | Grade$userGradeMappingsArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    image?: boolean
    description?: boolean
    name?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
    curriculum?: boolean | Grade$curriculumArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    image?: boolean
    description?: boolean
    name?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
    curriculum?: boolean | Grade$curriculumArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    image?: boolean
    description?: boolean
    name?: boolean
    isDeleted?: boolean
    curriculumId?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "image" | "description" | "name" | "isDeleted" | "curriculumId", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculum?: boolean | Grade$curriculumArgs<ExtArgs>
    subjects?: boolean | Grade$subjectsArgs<ExtArgs>
    academicYearMappings?: boolean | Grade$academicYearMappingsArgs<ExtArgs>
    userGradeMappings?: boolean | Grade$userGradeMappingsArgs<ExtArgs>
    _count?: boolean | GradeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculum?: boolean | Grade$curriculumArgs<ExtArgs>
  }
  export type GradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curriculum?: boolean | Grade$curriculumArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      curriculum: Prisma.$CurriculumPayload<ExtArgs> | null
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      academicYearMappings: Prisma.$UserAcademicYearMappingPayload<ExtArgs>[]
      userGradeMappings: Prisma.$UserGradeMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      createdAt: Date
      image: string | null
      description: string | null
      name: string | null
      isDeleted: boolean
      curriculumId: bigint | null
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades and returns the data updated in the database.
     * @param {GradeUpdateManyAndReturnArgs} args - Arguments to update many Grades.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GradeUpdateManyAndReturnArgs>(args: SelectSubset<T, GradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curriculum<T extends Grade$curriculumArgs<ExtArgs> = {}>(args?: Subset<T, Grade$curriculumArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Grade$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicYearMappings<T extends Grade$academicYearMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$academicYearMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userGradeMappings<T extends Grade$userGradeMappingsArgs<ExtArgs> = {}>(args?: Subset<T, Grade$userGradeMappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'BigInt'>
    readonly createdAt: FieldRef<"Grade", 'DateTime'>
    readonly image: FieldRef<"Grade", 'String'>
    readonly description: FieldRef<"Grade", 'String'>
    readonly name: FieldRef<"Grade", 'String'>
    readonly isDeleted: FieldRef<"Grade", 'Boolean'>
    readonly curriculumId: FieldRef<"Grade", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data?: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade updateManyAndReturn
   */
  export type GradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade.curriculum
   */
  export type Grade$curriculumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curriculum
     */
    select?: CurriculumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Curriculum
     */
    omit?: CurriculumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurriculumInclude<ExtArgs> | null
    where?: CurriculumWhereInput
  }

  /**
   * Grade.subjects
   */
  export type Grade$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Grade.academicYearMappings
   */
  export type Grade$academicYearMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    where?: UserAcademicYearMappingWhereInput
    orderBy?: UserAcademicYearMappingOrderByWithRelationInput | UserAcademicYearMappingOrderByWithRelationInput[]
    cursor?: UserAcademicYearMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAcademicYearMappingScalarFieldEnum | UserAcademicYearMappingScalarFieldEnum[]
  }

  /**
   * Grade.userGradeMappings
   */
  export type Grade$userGradeMappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    where?: UserGradeMappingWhereInput
    orderBy?: UserGradeMappingOrderByWithRelationInput | UserGradeMappingOrderByWithRelationInput[]
    cursor?: UserGradeMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserGradeMappingScalarFieldEnum | UserGradeMappingScalarFieldEnum[]
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    id: number | null
    gradeId: number | null
  }

  export type SubjectSumAggregateOutputType = {
    id: bigint | null
    gradeId: bigint | null
  }

  export type SubjectMinAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    name: string | null
    image: string | null
    description: string | null
    isDeleted: boolean | null
    gradeId: bigint | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    name: string | null
    image: string | null
    description: string | null
    isDeleted: boolean | null
    gradeId: bigint | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    createdAt: number
    name: number
    image: number
    description: number
    isDeleted: number
    gradeId: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    id?: true
    gradeId?: true
  }

  export type SubjectSumAggregateInputType = {
    id?: true
    gradeId?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    image?: true
    description?: true
    isDeleted?: true
    gradeId?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    image?: true
    description?: true
    isDeleted?: true
    gradeId?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    createdAt?: true
    name?: true
    image?: true
    description?: true
    isDeleted?: true
    gradeId?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: bigint
    createdAt: Date
    name: string | null
    image: string | null
    description: string | null
    isDeleted: boolean
    gradeId: bigint | null
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    isDeleted?: boolean
    gradeId?: boolean
    grade?: boolean | Subject$gradeArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    users?: boolean | Subject$usersArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    isDeleted?: boolean
    gradeId?: boolean
    grade?: boolean | Subject$gradeArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    isDeleted?: boolean
    gradeId?: boolean
    grade?: boolean | Subject$gradeArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    createdAt?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    isDeleted?: boolean
    gradeId?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "name" | "image" | "description" | "isDeleted" | "gradeId", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | Subject$gradeArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    users?: boolean | Subject$usersArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | Subject$gradeArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grade?: boolean | Subject$gradeArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      grade: Prisma.$GradePayload<ExtArgs> | null
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      users: Prisma.$UserSubjectMappingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      createdAt: Date
      name: string | null
      image: string | null
      description: string | null
      isDeleted: boolean
      gradeId: bigint | null
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grade<T extends Subject$gradeArgs<ExtArgs> = {}>(args?: Subset<T, Subject$gradeArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chapters<T extends Subject$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Subject$usersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'BigInt'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly image: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly isDeleted: FieldRef<"Subject", 'Boolean'>
    readonly gradeId: FieldRef<"Subject", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data?: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.grade
   */
  export type Subject$gradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
  }

  /**
   * Subject.chapters
   */
  export type Subject$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Subject.users
   */
  export type Subject$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    where?: UserSubjectMappingWhereInput
    orderBy?: UserSubjectMappingOrderByWithRelationInput | UserSubjectMappingOrderByWithRelationInput[]
    cursor?: UserSubjectMappingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSubjectMappingScalarFieldEnum | UserSubjectMappingScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    id: number | null
    sortOrder: Decimal | null
    subjectId: number | null
  }

  export type ChapterSumAggregateOutputType = {
    id: bigint | null
    sortOrder: Decimal | null
    subjectId: bigint | null
  }

  export type ChapterMinAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    title: string | null
    sortOrder: Decimal | null
    imageUrl: string | null
    isDeleted: boolean | null
    subjectId: bigint | null
    label: string | null
    updatedAt: Date | null
    content: string | null
    teacherGuide: string | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: bigint | null
    createdAt: Date | null
    title: string | null
    sortOrder: Decimal | null
    imageUrl: string | null
    isDeleted: boolean | null
    subjectId: bigint | null
    label: string | null
    updatedAt: Date | null
    content: string | null
    teacherGuide: string | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    createdAt: number
    title: number
    sortOrder: number
    imageUrl: number
    isDeleted: number
    subjectId: number
    label: number
    updatedAt: number
    content: number
    teacherGuide: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    id?: true
    sortOrder?: true
    subjectId?: true
  }

  export type ChapterSumAggregateInputType = {
    id?: true
    sortOrder?: true
    subjectId?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    sortOrder?: true
    imageUrl?: true
    isDeleted?: true
    subjectId?: true
    label?: true
    updatedAt?: true
    content?: true
    teacherGuide?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    sortOrder?: true
    imageUrl?: true
    isDeleted?: true
    subjectId?: true
    label?: true
    updatedAt?: true
    content?: true
    teacherGuide?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    createdAt?: true
    title?: true
    sortOrder?: true
    imageUrl?: true
    isDeleted?: true
    subjectId?: true
    label?: true
    updatedAt?: true
    content?: true
    teacherGuide?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: bigint
    createdAt: Date
    title: string
    sortOrder: Decimal
    imageUrl: string | null
    isDeleted: boolean
    subjectId: bigint | null
    label: string | null
    updatedAt: Date | null
    content: string | null
    teacherGuide: string | null
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    sortOrder?: boolean
    imageUrl?: boolean
    isDeleted?: boolean
    subjectId?: boolean
    label?: boolean
    updatedAt?: boolean
    content?: boolean
    teacherGuide?: boolean
    subject?: boolean | Chapter$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    sortOrder?: boolean
    imageUrl?: boolean
    isDeleted?: boolean
    subjectId?: boolean
    label?: boolean
    updatedAt?: boolean
    content?: boolean
    teacherGuide?: boolean
    subject?: boolean | Chapter$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    title?: boolean
    sortOrder?: boolean
    imageUrl?: boolean
    isDeleted?: boolean
    subjectId?: boolean
    label?: boolean
    updatedAt?: boolean
    content?: boolean
    teacherGuide?: boolean
    subject?: boolean | Chapter$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    createdAt?: boolean
    title?: boolean
    sortOrder?: boolean
    imageUrl?: boolean
    isDeleted?: boolean
    subjectId?: boolean
    label?: boolean
    updatedAt?: boolean
    content?: boolean
    teacherGuide?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "title" | "sortOrder" | "imageUrl" | "isDeleted" | "subjectId" | "label" | "updatedAt" | "content" | "teacherGuide", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Chapter$subjectArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Chapter$subjectArgs<ExtArgs>
  }
  export type ChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | Chapter$subjectArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      createdAt: Date
      title: string
      sortOrder: Prisma.Decimal
      imageUrl: string | null
      isDeleted: boolean
      subjectId: bigint | null
      label: string | null
      updatedAt: Date | null
      content: string | null
      teacherGuide: string | null
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends Chapter$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'BigInt'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly sortOrder: FieldRef<"Chapter", 'Decimal'>
    readonly imageUrl: FieldRef<"Chapter", 'String'>
    readonly isDeleted: FieldRef<"Chapter", 'Boolean'>
    readonly subjectId: FieldRef<"Chapter", 'BigInt'>
    readonly label: FieldRef<"Chapter", 'String'>
    readonly updatedAt: FieldRef<"Chapter", 'DateTime'>
    readonly content: FieldRef<"Chapter", 'String'>
    readonly teacherGuide: FieldRef<"Chapter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter updateManyAndReturn
   */
  export type ChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter.subject
   */
  export type Chapter$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    id: number | null
  }

  export type SchoolSumAggregateOutputType = {
    id: bigint | null
  }

  export type SchoolMinAggregateOutputType = {
    id: bigint | null
    schoolName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: bigint | null
    schoolName: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    schoolName: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    id?: true
  }

  export type SchoolSumAggregateInputType = {
    id?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    schoolName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    schoolName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    schoolName?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: bigint
    schoolName: string
    userId: string
    createdAt: Date
    updatedAt: Date | null
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    schoolName?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolName" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      user: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      schoolName: string
      userId: string
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'BigInt'>
    readonly schoolName: FieldRef<"School", 'String'>
    readonly userId: FieldRef<"School", 'String'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model UserAcademicYearMapping
   */

  export type AggregateUserAcademicYearMapping = {
    _count: UserAcademicYearMappingCountAggregateOutputType | null
    _avg: UserAcademicYearMappingAvgAggregateOutputType | null
    _sum: UserAcademicYearMappingSumAggregateOutputType | null
    _min: UserAcademicYearMappingMinAggregateOutputType | null
    _max: UserAcademicYearMappingMaxAggregateOutputType | null
  }

  export type UserAcademicYearMappingAvgAggregateOutputType = {
    id: number | null
    studentGradeId: number | null
    academicYearId: number | null
  }

  export type UserAcademicYearMappingSumAggregateOutputType = {
    id: bigint | null
    studentGradeId: bigint | null
    academicYearId: bigint | null
  }

  export type UserAcademicYearMappingMinAggregateOutputType = {
    id: bigint | null
    userId: string | null
    studentGradeId: bigint | null
    academicYearId: bigint | null
    createdAt: Date | null
  }

  export type UserAcademicYearMappingMaxAggregateOutputType = {
    id: bigint | null
    userId: string | null
    studentGradeId: bigint | null
    academicYearId: bigint | null
    createdAt: Date | null
  }

  export type UserAcademicYearMappingCountAggregateOutputType = {
    id: number
    userId: number
    studentGradeId: number
    academicYearId: number
    createdAt: number
    _all: number
  }


  export type UserAcademicYearMappingAvgAggregateInputType = {
    id?: true
    studentGradeId?: true
    academicYearId?: true
  }

  export type UserAcademicYearMappingSumAggregateInputType = {
    id?: true
    studentGradeId?: true
    academicYearId?: true
  }

  export type UserAcademicYearMappingMinAggregateInputType = {
    id?: true
    userId?: true
    studentGradeId?: true
    academicYearId?: true
    createdAt?: true
  }

  export type UserAcademicYearMappingMaxAggregateInputType = {
    id?: true
    userId?: true
    studentGradeId?: true
    academicYearId?: true
    createdAt?: true
  }

  export type UserAcademicYearMappingCountAggregateInputType = {
    id?: true
    userId?: true
    studentGradeId?: true
    academicYearId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAcademicYearMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAcademicYearMapping to aggregate.
     */
    where?: UserAcademicYearMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademicYearMappings to fetch.
     */
    orderBy?: UserAcademicYearMappingOrderByWithRelationInput | UserAcademicYearMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAcademicYearMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademicYearMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademicYearMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAcademicYearMappings
    **/
    _count?: true | UserAcademicYearMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAcademicYearMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAcademicYearMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAcademicYearMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAcademicYearMappingMaxAggregateInputType
  }

  export type GetUserAcademicYearMappingAggregateType<T extends UserAcademicYearMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAcademicYearMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAcademicYearMapping[P]>
      : GetScalarType<T[P], AggregateUserAcademicYearMapping[P]>
  }




  export type UserAcademicYearMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAcademicYearMappingWhereInput
    orderBy?: UserAcademicYearMappingOrderByWithAggregationInput | UserAcademicYearMappingOrderByWithAggregationInput[]
    by: UserAcademicYearMappingScalarFieldEnum[] | UserAcademicYearMappingScalarFieldEnum
    having?: UserAcademicYearMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAcademicYearMappingCountAggregateInputType | true
    _avg?: UserAcademicYearMappingAvgAggregateInputType
    _sum?: UserAcademicYearMappingSumAggregateInputType
    _min?: UserAcademicYearMappingMinAggregateInputType
    _max?: UserAcademicYearMappingMaxAggregateInputType
  }

  export type UserAcademicYearMappingGroupByOutputType = {
    id: bigint
    userId: string
    studentGradeId: bigint | null
    academicYearId: bigint | null
    createdAt: Date
    _count: UserAcademicYearMappingCountAggregateOutputType | null
    _avg: UserAcademicYearMappingAvgAggregateOutputType | null
    _sum: UserAcademicYearMappingSumAggregateOutputType | null
    _min: UserAcademicYearMappingMinAggregateOutputType | null
    _max: UserAcademicYearMappingMaxAggregateOutputType | null
  }

  type GetUserAcademicYearMappingGroupByPayload<T extends UserAcademicYearMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAcademicYearMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAcademicYearMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAcademicYearMappingGroupByOutputType[P]>
            : GetScalarType<T[P], UserAcademicYearMappingGroupByOutputType[P]>
        }
      >
    >


  export type UserAcademicYearMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentGradeId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    studentGrade?: boolean | UserAcademicYearMapping$studentGradeArgs<ExtArgs>
    academicYear?: boolean | UserAcademicYearMapping$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["userAcademicYearMapping"]>

  export type UserAcademicYearMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentGradeId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    studentGrade?: boolean | UserAcademicYearMapping$studentGradeArgs<ExtArgs>
    academicYear?: boolean | UserAcademicYearMapping$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["userAcademicYearMapping"]>

  export type UserAcademicYearMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentGradeId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    studentGrade?: boolean | UserAcademicYearMapping$studentGradeArgs<ExtArgs>
    academicYear?: boolean | UserAcademicYearMapping$academicYearArgs<ExtArgs>
  }, ExtArgs["result"]["userAcademicYearMapping"]>

  export type UserAcademicYearMappingSelectScalar = {
    id?: boolean
    userId?: boolean
    studentGradeId?: boolean
    academicYearId?: boolean
    createdAt?: boolean
  }

  export type UserAcademicYearMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studentGradeId" | "academicYearId" | "createdAt", ExtArgs["result"]["userAcademicYearMapping"]>
  export type UserAcademicYearMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    studentGrade?: boolean | UserAcademicYearMapping$studentGradeArgs<ExtArgs>
    academicYear?: boolean | UserAcademicYearMapping$academicYearArgs<ExtArgs>
  }
  export type UserAcademicYearMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    studentGrade?: boolean | UserAcademicYearMapping$studentGradeArgs<ExtArgs>
    academicYear?: boolean | UserAcademicYearMapping$academicYearArgs<ExtArgs>
  }
  export type UserAcademicYearMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    studentGrade?: boolean | UserAcademicYearMapping$studentGradeArgs<ExtArgs>
    academicYear?: boolean | UserAcademicYearMapping$academicYearArgs<ExtArgs>
  }

  export type $UserAcademicYearMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAcademicYearMapping"
    objects: {
      user: Prisma.$ProfilePayload<ExtArgs>
      studentGrade: Prisma.$GradePayload<ExtArgs> | null
      academicYear: Prisma.$AcademicYearPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      userId: string
      studentGradeId: bigint | null
      academicYearId: bigint | null
      createdAt: Date
    }, ExtArgs["result"]["userAcademicYearMapping"]>
    composites: {}
  }

  type UserAcademicYearMappingGetPayload<S extends boolean | null | undefined | UserAcademicYearMappingDefaultArgs> = $Result.GetResult<Prisma.$UserAcademicYearMappingPayload, S>

  type UserAcademicYearMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAcademicYearMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAcademicYearMappingCountAggregateInputType | true
    }

  export interface UserAcademicYearMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAcademicYearMapping'], meta: { name: 'UserAcademicYearMapping' } }
    /**
     * Find zero or one UserAcademicYearMapping that matches the filter.
     * @param {UserAcademicYearMappingFindUniqueArgs} args - Arguments to find a UserAcademicYearMapping
     * @example
     * // Get one UserAcademicYearMapping
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAcademicYearMappingFindUniqueArgs>(args: SelectSubset<T, UserAcademicYearMappingFindUniqueArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAcademicYearMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAcademicYearMappingFindUniqueOrThrowArgs} args - Arguments to find a UserAcademicYearMapping
     * @example
     * // Get one UserAcademicYearMapping
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAcademicYearMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAcademicYearMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAcademicYearMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademicYearMappingFindFirstArgs} args - Arguments to find a UserAcademicYearMapping
     * @example
     * // Get one UserAcademicYearMapping
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAcademicYearMappingFindFirstArgs>(args?: SelectSubset<T, UserAcademicYearMappingFindFirstArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAcademicYearMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademicYearMappingFindFirstOrThrowArgs} args - Arguments to find a UserAcademicYearMapping
     * @example
     * // Get one UserAcademicYearMapping
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAcademicYearMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAcademicYearMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAcademicYearMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademicYearMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAcademicYearMappings
     * const userAcademicYearMappings = await prisma.userAcademicYearMapping.findMany()
     * 
     * // Get first 10 UserAcademicYearMappings
     * const userAcademicYearMappings = await prisma.userAcademicYearMapping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAcademicYearMappingWithIdOnly = await prisma.userAcademicYearMapping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAcademicYearMappingFindManyArgs>(args?: SelectSubset<T, UserAcademicYearMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAcademicYearMapping.
     * @param {UserAcademicYearMappingCreateArgs} args - Arguments to create a UserAcademicYearMapping.
     * @example
     * // Create one UserAcademicYearMapping
     * const UserAcademicYearMapping = await prisma.userAcademicYearMapping.create({
     *   data: {
     *     // ... data to create a UserAcademicYearMapping
     *   }
     * })
     * 
     */
    create<T extends UserAcademicYearMappingCreateArgs>(args: SelectSubset<T, UserAcademicYearMappingCreateArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAcademicYearMappings.
     * @param {UserAcademicYearMappingCreateManyArgs} args - Arguments to create many UserAcademicYearMappings.
     * @example
     * // Create many UserAcademicYearMappings
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAcademicYearMappingCreateManyArgs>(args?: SelectSubset<T, UserAcademicYearMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAcademicYearMappings and returns the data saved in the database.
     * @param {UserAcademicYearMappingCreateManyAndReturnArgs} args - Arguments to create many UserAcademicYearMappings.
     * @example
     * // Create many UserAcademicYearMappings
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAcademicYearMappings and only return the `id`
     * const userAcademicYearMappingWithIdOnly = await prisma.userAcademicYearMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAcademicYearMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAcademicYearMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAcademicYearMapping.
     * @param {UserAcademicYearMappingDeleteArgs} args - Arguments to delete one UserAcademicYearMapping.
     * @example
     * // Delete one UserAcademicYearMapping
     * const UserAcademicYearMapping = await prisma.userAcademicYearMapping.delete({
     *   where: {
     *     // ... filter to delete one UserAcademicYearMapping
     *   }
     * })
     * 
     */
    delete<T extends UserAcademicYearMappingDeleteArgs>(args: SelectSubset<T, UserAcademicYearMappingDeleteArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAcademicYearMapping.
     * @param {UserAcademicYearMappingUpdateArgs} args - Arguments to update one UserAcademicYearMapping.
     * @example
     * // Update one UserAcademicYearMapping
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAcademicYearMappingUpdateArgs>(args: SelectSubset<T, UserAcademicYearMappingUpdateArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAcademicYearMappings.
     * @param {UserAcademicYearMappingDeleteManyArgs} args - Arguments to filter UserAcademicYearMappings to delete.
     * @example
     * // Delete a few UserAcademicYearMappings
     * const { count } = await prisma.userAcademicYearMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAcademicYearMappingDeleteManyArgs>(args?: SelectSubset<T, UserAcademicYearMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAcademicYearMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademicYearMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAcademicYearMappings
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAcademicYearMappingUpdateManyArgs>(args: SelectSubset<T, UserAcademicYearMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAcademicYearMappings and returns the data updated in the database.
     * @param {UserAcademicYearMappingUpdateManyAndReturnArgs} args - Arguments to update many UserAcademicYearMappings.
     * @example
     * // Update many UserAcademicYearMappings
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAcademicYearMappings and only return the `id`
     * const userAcademicYearMappingWithIdOnly = await prisma.userAcademicYearMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAcademicYearMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAcademicYearMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAcademicYearMapping.
     * @param {UserAcademicYearMappingUpsertArgs} args - Arguments to update or create a UserAcademicYearMapping.
     * @example
     * // Update or create a UserAcademicYearMapping
     * const userAcademicYearMapping = await prisma.userAcademicYearMapping.upsert({
     *   create: {
     *     // ... data to create a UserAcademicYearMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAcademicYearMapping we want to update
     *   }
     * })
     */
    upsert<T extends UserAcademicYearMappingUpsertArgs>(args: SelectSubset<T, UserAcademicYearMappingUpsertArgs<ExtArgs>>): Prisma__UserAcademicYearMappingClient<$Result.GetResult<Prisma.$UserAcademicYearMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAcademicYearMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademicYearMappingCountArgs} args - Arguments to filter UserAcademicYearMappings to count.
     * @example
     * // Count the number of UserAcademicYearMappings
     * const count = await prisma.userAcademicYearMapping.count({
     *   where: {
     *     // ... the filter for the UserAcademicYearMappings we want to count
     *   }
     * })
    **/
    count<T extends UserAcademicYearMappingCountArgs>(
      args?: Subset<T, UserAcademicYearMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAcademicYearMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAcademicYearMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademicYearMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAcademicYearMappingAggregateArgs>(args: Subset<T, UserAcademicYearMappingAggregateArgs>): Prisma.PrismaPromise<GetUserAcademicYearMappingAggregateType<T>>

    /**
     * Group by UserAcademicYearMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademicYearMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAcademicYearMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAcademicYearMappingGroupByArgs['orderBy'] }
        : { orderBy?: UserAcademicYearMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAcademicYearMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAcademicYearMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAcademicYearMapping model
   */
  readonly fields: UserAcademicYearMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAcademicYearMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAcademicYearMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentGrade<T extends UserAcademicYearMapping$studentGradeArgs<ExtArgs> = {}>(args?: Subset<T, UserAcademicYearMapping$studentGradeArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends UserAcademicYearMapping$academicYearArgs<ExtArgs> = {}>(args?: Subset<T, UserAcademicYearMapping$academicYearArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAcademicYearMapping model
   */
  interface UserAcademicYearMappingFieldRefs {
    readonly id: FieldRef<"UserAcademicYearMapping", 'BigInt'>
    readonly userId: FieldRef<"UserAcademicYearMapping", 'String'>
    readonly studentGradeId: FieldRef<"UserAcademicYearMapping", 'BigInt'>
    readonly academicYearId: FieldRef<"UserAcademicYearMapping", 'BigInt'>
    readonly createdAt: FieldRef<"UserAcademicYearMapping", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAcademicYearMapping findUnique
   */
  export type UserAcademicYearMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademicYearMapping to fetch.
     */
    where: UserAcademicYearMappingWhereUniqueInput
  }

  /**
   * UserAcademicYearMapping findUniqueOrThrow
   */
  export type UserAcademicYearMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademicYearMapping to fetch.
     */
    where: UserAcademicYearMappingWhereUniqueInput
  }

  /**
   * UserAcademicYearMapping findFirst
   */
  export type UserAcademicYearMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademicYearMapping to fetch.
     */
    where?: UserAcademicYearMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademicYearMappings to fetch.
     */
    orderBy?: UserAcademicYearMappingOrderByWithRelationInput | UserAcademicYearMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAcademicYearMappings.
     */
    cursor?: UserAcademicYearMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademicYearMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademicYearMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAcademicYearMappings.
     */
    distinct?: UserAcademicYearMappingScalarFieldEnum | UserAcademicYearMappingScalarFieldEnum[]
  }

  /**
   * UserAcademicYearMapping findFirstOrThrow
   */
  export type UserAcademicYearMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademicYearMapping to fetch.
     */
    where?: UserAcademicYearMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademicYearMappings to fetch.
     */
    orderBy?: UserAcademicYearMappingOrderByWithRelationInput | UserAcademicYearMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAcademicYearMappings.
     */
    cursor?: UserAcademicYearMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademicYearMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademicYearMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAcademicYearMappings.
     */
    distinct?: UserAcademicYearMappingScalarFieldEnum | UserAcademicYearMappingScalarFieldEnum[]
  }

  /**
   * UserAcademicYearMapping findMany
   */
  export type UserAcademicYearMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademicYearMappings to fetch.
     */
    where?: UserAcademicYearMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademicYearMappings to fetch.
     */
    orderBy?: UserAcademicYearMappingOrderByWithRelationInput | UserAcademicYearMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAcademicYearMappings.
     */
    cursor?: UserAcademicYearMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademicYearMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademicYearMappings.
     */
    skip?: number
    distinct?: UserAcademicYearMappingScalarFieldEnum | UserAcademicYearMappingScalarFieldEnum[]
  }

  /**
   * UserAcademicYearMapping create
   */
  export type UserAcademicYearMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAcademicYearMapping.
     */
    data: XOR<UserAcademicYearMappingCreateInput, UserAcademicYearMappingUncheckedCreateInput>
  }

  /**
   * UserAcademicYearMapping createMany
   */
  export type UserAcademicYearMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAcademicYearMappings.
     */
    data: UserAcademicYearMappingCreateManyInput | UserAcademicYearMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAcademicYearMapping createManyAndReturn
   */
  export type UserAcademicYearMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * The data used to create many UserAcademicYearMappings.
     */
    data: UserAcademicYearMappingCreateManyInput | UserAcademicYearMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAcademicYearMapping update
   */
  export type UserAcademicYearMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAcademicYearMapping.
     */
    data: XOR<UserAcademicYearMappingUpdateInput, UserAcademicYearMappingUncheckedUpdateInput>
    /**
     * Choose, which UserAcademicYearMapping to update.
     */
    where: UserAcademicYearMappingWhereUniqueInput
  }

  /**
   * UserAcademicYearMapping updateMany
   */
  export type UserAcademicYearMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAcademicYearMappings.
     */
    data: XOR<UserAcademicYearMappingUpdateManyMutationInput, UserAcademicYearMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserAcademicYearMappings to update
     */
    where?: UserAcademicYearMappingWhereInput
    /**
     * Limit how many UserAcademicYearMappings to update.
     */
    limit?: number
  }

  /**
   * UserAcademicYearMapping updateManyAndReturn
   */
  export type UserAcademicYearMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * The data used to update UserAcademicYearMappings.
     */
    data: XOR<UserAcademicYearMappingUpdateManyMutationInput, UserAcademicYearMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserAcademicYearMappings to update
     */
    where?: UserAcademicYearMappingWhereInput
    /**
     * Limit how many UserAcademicYearMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAcademicYearMapping upsert
   */
  export type UserAcademicYearMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAcademicYearMapping to update in case it exists.
     */
    where: UserAcademicYearMappingWhereUniqueInput
    /**
     * In case the UserAcademicYearMapping found by the `where` argument doesn't exist, create a new UserAcademicYearMapping with this data.
     */
    create: XOR<UserAcademicYearMappingCreateInput, UserAcademicYearMappingUncheckedCreateInput>
    /**
     * In case the UserAcademicYearMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAcademicYearMappingUpdateInput, UserAcademicYearMappingUncheckedUpdateInput>
  }

  /**
   * UserAcademicYearMapping delete
   */
  export type UserAcademicYearMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
    /**
     * Filter which UserAcademicYearMapping to delete.
     */
    where: UserAcademicYearMappingWhereUniqueInput
  }

  /**
   * UserAcademicYearMapping deleteMany
   */
  export type UserAcademicYearMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAcademicYearMappings to delete
     */
    where?: UserAcademicYearMappingWhereInput
    /**
     * Limit how many UserAcademicYearMappings to delete.
     */
    limit?: number
  }

  /**
   * UserAcademicYearMapping.studentGrade
   */
  export type UserAcademicYearMapping$studentGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
  }

  /**
   * UserAcademicYearMapping.academicYear
   */
  export type UserAcademicYearMapping$academicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
  }

  /**
   * UserAcademicYearMapping without action
   */
  export type UserAcademicYearMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademicYearMapping
     */
    select?: UserAcademicYearMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAcademicYearMapping
     */
    omit?: UserAcademicYearMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademicYearMappingInclude<ExtArgs> | null
  }


  /**
   * Model UserCurriculumMapping
   */

  export type AggregateUserCurriculumMapping = {
    _count: UserCurriculumMappingCountAggregateOutputType | null
    _avg: UserCurriculumMappingAvgAggregateOutputType | null
    _sum: UserCurriculumMappingSumAggregateOutputType | null
    _min: UserCurriculumMappingMinAggregateOutputType | null
    _max: UserCurriculumMappingMaxAggregateOutputType | null
  }

  export type UserCurriculumMappingAvgAggregateOutputType = {
    curriculumId: number | null
  }

  export type UserCurriculumMappingSumAggregateOutputType = {
    curriculumId: bigint | null
  }

  export type UserCurriculumMappingMinAggregateOutputType = {
    userId: string | null
    curriculumId: bigint | null
  }

  export type UserCurriculumMappingMaxAggregateOutputType = {
    userId: string | null
    curriculumId: bigint | null
  }

  export type UserCurriculumMappingCountAggregateOutputType = {
    userId: number
    curriculumId: number
    _all: number
  }


  export type UserCurriculumMappingAvgAggregateInputType = {
    curriculumId?: true
  }

  export type UserCurriculumMappingSumAggregateInputType = {
    curriculumId?: true
  }

  export type UserCurriculumMappingMinAggregateInputType = {
    userId?: true
    curriculumId?: true
  }

  export type UserCurriculumMappingMaxAggregateInputType = {
    userId?: true
    curriculumId?: true
  }

  export type UserCurriculumMappingCountAggregateInputType = {
    userId?: true
    curriculumId?: true
    _all?: true
  }

  export type UserCurriculumMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCurriculumMapping to aggregate.
     */
    where?: UserCurriculumMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCurriculumMappings to fetch.
     */
    orderBy?: UserCurriculumMappingOrderByWithRelationInput | UserCurriculumMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCurriculumMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCurriculumMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCurriculumMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCurriculumMappings
    **/
    _count?: true | UserCurriculumMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCurriculumMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCurriculumMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCurriculumMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCurriculumMappingMaxAggregateInputType
  }

  export type GetUserCurriculumMappingAggregateType<T extends UserCurriculumMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCurriculumMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCurriculumMapping[P]>
      : GetScalarType<T[P], AggregateUserCurriculumMapping[P]>
  }




  export type UserCurriculumMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCurriculumMappingWhereInput
    orderBy?: UserCurriculumMappingOrderByWithAggregationInput | UserCurriculumMappingOrderByWithAggregationInput[]
    by: UserCurriculumMappingScalarFieldEnum[] | UserCurriculumMappingScalarFieldEnum
    having?: UserCurriculumMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCurriculumMappingCountAggregateInputType | true
    _avg?: UserCurriculumMappingAvgAggregateInputType
    _sum?: UserCurriculumMappingSumAggregateInputType
    _min?: UserCurriculumMappingMinAggregateInputType
    _max?: UserCurriculumMappingMaxAggregateInputType
  }

  export type UserCurriculumMappingGroupByOutputType = {
    userId: string
    curriculumId: bigint
    _count: UserCurriculumMappingCountAggregateOutputType | null
    _avg: UserCurriculumMappingAvgAggregateOutputType | null
    _sum: UserCurriculumMappingSumAggregateOutputType | null
    _min: UserCurriculumMappingMinAggregateOutputType | null
    _max: UserCurriculumMappingMaxAggregateOutputType | null
  }

  type GetUserCurriculumMappingGroupByPayload<T extends UserCurriculumMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCurriculumMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCurriculumMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCurriculumMappingGroupByOutputType[P]>
            : GetScalarType<T[P], UserCurriculumMappingGroupByOutputType[P]>
        }
      >
    >


  export type UserCurriculumMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    curriculumId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    curriculum?: boolean | CurriculumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCurriculumMapping"]>

  export type UserCurriculumMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    curriculumId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    curriculum?: boolean | CurriculumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCurriculumMapping"]>

  export type UserCurriculumMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    curriculumId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    curriculum?: boolean | CurriculumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCurriculumMapping"]>

  export type UserCurriculumMappingSelectScalar = {
    userId?: boolean
    curriculumId?: boolean
  }

  export type UserCurriculumMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "curriculumId", ExtArgs["result"]["userCurriculumMapping"]>
  export type UserCurriculumMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    curriculum?: boolean | CurriculumDefaultArgs<ExtArgs>
  }
  export type UserCurriculumMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    curriculum?: boolean | CurriculumDefaultArgs<ExtArgs>
  }
  export type UserCurriculumMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    curriculum?: boolean | CurriculumDefaultArgs<ExtArgs>
  }

  export type $UserCurriculumMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCurriculumMapping"
    objects: {
      user: Prisma.$ProfilePayload<ExtArgs>
      curriculum: Prisma.$CurriculumPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      curriculumId: bigint
    }, ExtArgs["result"]["userCurriculumMapping"]>
    composites: {}
  }

  type UserCurriculumMappingGetPayload<S extends boolean | null | undefined | UserCurriculumMappingDefaultArgs> = $Result.GetResult<Prisma.$UserCurriculumMappingPayload, S>

  type UserCurriculumMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCurriculumMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCurriculumMappingCountAggregateInputType | true
    }

  export interface UserCurriculumMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCurriculumMapping'], meta: { name: 'UserCurriculumMapping' } }
    /**
     * Find zero or one UserCurriculumMapping that matches the filter.
     * @param {UserCurriculumMappingFindUniqueArgs} args - Arguments to find a UserCurriculumMapping
     * @example
     * // Get one UserCurriculumMapping
     * const userCurriculumMapping = await prisma.userCurriculumMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCurriculumMappingFindUniqueArgs>(args: SelectSubset<T, UserCurriculumMappingFindUniqueArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCurriculumMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCurriculumMappingFindUniqueOrThrowArgs} args - Arguments to find a UserCurriculumMapping
     * @example
     * // Get one UserCurriculumMapping
     * const userCurriculumMapping = await prisma.userCurriculumMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCurriculumMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCurriculumMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCurriculumMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCurriculumMappingFindFirstArgs} args - Arguments to find a UserCurriculumMapping
     * @example
     * // Get one UserCurriculumMapping
     * const userCurriculumMapping = await prisma.userCurriculumMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCurriculumMappingFindFirstArgs>(args?: SelectSubset<T, UserCurriculumMappingFindFirstArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCurriculumMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCurriculumMappingFindFirstOrThrowArgs} args - Arguments to find a UserCurriculumMapping
     * @example
     * // Get one UserCurriculumMapping
     * const userCurriculumMapping = await prisma.userCurriculumMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCurriculumMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCurriculumMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCurriculumMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCurriculumMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCurriculumMappings
     * const userCurriculumMappings = await prisma.userCurriculumMapping.findMany()
     * 
     * // Get first 10 UserCurriculumMappings
     * const userCurriculumMappings = await prisma.userCurriculumMapping.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userCurriculumMappingWithUserIdOnly = await prisma.userCurriculumMapping.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserCurriculumMappingFindManyArgs>(args?: SelectSubset<T, UserCurriculumMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCurriculumMapping.
     * @param {UserCurriculumMappingCreateArgs} args - Arguments to create a UserCurriculumMapping.
     * @example
     * // Create one UserCurriculumMapping
     * const UserCurriculumMapping = await prisma.userCurriculumMapping.create({
     *   data: {
     *     // ... data to create a UserCurriculumMapping
     *   }
     * })
     * 
     */
    create<T extends UserCurriculumMappingCreateArgs>(args: SelectSubset<T, UserCurriculumMappingCreateArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCurriculumMappings.
     * @param {UserCurriculumMappingCreateManyArgs} args - Arguments to create many UserCurriculumMappings.
     * @example
     * // Create many UserCurriculumMappings
     * const userCurriculumMapping = await prisma.userCurriculumMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCurriculumMappingCreateManyArgs>(args?: SelectSubset<T, UserCurriculumMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCurriculumMappings and returns the data saved in the database.
     * @param {UserCurriculumMappingCreateManyAndReturnArgs} args - Arguments to create many UserCurriculumMappings.
     * @example
     * // Create many UserCurriculumMappings
     * const userCurriculumMapping = await prisma.userCurriculumMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCurriculumMappings and only return the `userId`
     * const userCurriculumMappingWithUserIdOnly = await prisma.userCurriculumMapping.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCurriculumMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCurriculumMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCurriculumMapping.
     * @param {UserCurriculumMappingDeleteArgs} args - Arguments to delete one UserCurriculumMapping.
     * @example
     * // Delete one UserCurriculumMapping
     * const UserCurriculumMapping = await prisma.userCurriculumMapping.delete({
     *   where: {
     *     // ... filter to delete one UserCurriculumMapping
     *   }
     * })
     * 
     */
    delete<T extends UserCurriculumMappingDeleteArgs>(args: SelectSubset<T, UserCurriculumMappingDeleteArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCurriculumMapping.
     * @param {UserCurriculumMappingUpdateArgs} args - Arguments to update one UserCurriculumMapping.
     * @example
     * // Update one UserCurriculumMapping
     * const userCurriculumMapping = await prisma.userCurriculumMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCurriculumMappingUpdateArgs>(args: SelectSubset<T, UserCurriculumMappingUpdateArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCurriculumMappings.
     * @param {UserCurriculumMappingDeleteManyArgs} args - Arguments to filter UserCurriculumMappings to delete.
     * @example
     * // Delete a few UserCurriculumMappings
     * const { count } = await prisma.userCurriculumMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCurriculumMappingDeleteManyArgs>(args?: SelectSubset<T, UserCurriculumMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCurriculumMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCurriculumMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCurriculumMappings
     * const userCurriculumMapping = await prisma.userCurriculumMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCurriculumMappingUpdateManyArgs>(args: SelectSubset<T, UserCurriculumMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCurriculumMappings and returns the data updated in the database.
     * @param {UserCurriculumMappingUpdateManyAndReturnArgs} args - Arguments to update many UserCurriculumMappings.
     * @example
     * // Update many UserCurriculumMappings
     * const userCurriculumMapping = await prisma.userCurriculumMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCurriculumMappings and only return the `userId`
     * const userCurriculumMappingWithUserIdOnly = await prisma.userCurriculumMapping.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCurriculumMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCurriculumMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCurriculumMapping.
     * @param {UserCurriculumMappingUpsertArgs} args - Arguments to update or create a UserCurriculumMapping.
     * @example
     * // Update or create a UserCurriculumMapping
     * const userCurriculumMapping = await prisma.userCurriculumMapping.upsert({
     *   create: {
     *     // ... data to create a UserCurriculumMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCurriculumMapping we want to update
     *   }
     * })
     */
    upsert<T extends UserCurriculumMappingUpsertArgs>(args: SelectSubset<T, UserCurriculumMappingUpsertArgs<ExtArgs>>): Prisma__UserCurriculumMappingClient<$Result.GetResult<Prisma.$UserCurriculumMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCurriculumMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCurriculumMappingCountArgs} args - Arguments to filter UserCurriculumMappings to count.
     * @example
     * // Count the number of UserCurriculumMappings
     * const count = await prisma.userCurriculumMapping.count({
     *   where: {
     *     // ... the filter for the UserCurriculumMappings we want to count
     *   }
     * })
    **/
    count<T extends UserCurriculumMappingCountArgs>(
      args?: Subset<T, UserCurriculumMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCurriculumMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCurriculumMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCurriculumMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCurriculumMappingAggregateArgs>(args: Subset<T, UserCurriculumMappingAggregateArgs>): Prisma.PrismaPromise<GetUserCurriculumMappingAggregateType<T>>

    /**
     * Group by UserCurriculumMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCurriculumMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCurriculumMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCurriculumMappingGroupByArgs['orderBy'] }
        : { orderBy?: UserCurriculumMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCurriculumMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCurriculumMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCurriculumMapping model
   */
  readonly fields: UserCurriculumMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCurriculumMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCurriculumMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    curriculum<T extends CurriculumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurriculumDefaultArgs<ExtArgs>>): Prisma__CurriculumClient<$Result.GetResult<Prisma.$CurriculumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCurriculumMapping model
   */
  interface UserCurriculumMappingFieldRefs {
    readonly userId: FieldRef<"UserCurriculumMapping", 'String'>
    readonly curriculumId: FieldRef<"UserCurriculumMapping", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * UserCurriculumMapping findUnique
   */
  export type UserCurriculumMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserCurriculumMapping to fetch.
     */
    where: UserCurriculumMappingWhereUniqueInput
  }

  /**
   * UserCurriculumMapping findUniqueOrThrow
   */
  export type UserCurriculumMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserCurriculumMapping to fetch.
     */
    where: UserCurriculumMappingWhereUniqueInput
  }

  /**
   * UserCurriculumMapping findFirst
   */
  export type UserCurriculumMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserCurriculumMapping to fetch.
     */
    where?: UserCurriculumMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCurriculumMappings to fetch.
     */
    orderBy?: UserCurriculumMappingOrderByWithRelationInput | UserCurriculumMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCurriculumMappings.
     */
    cursor?: UserCurriculumMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCurriculumMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCurriculumMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCurriculumMappings.
     */
    distinct?: UserCurriculumMappingScalarFieldEnum | UserCurriculumMappingScalarFieldEnum[]
  }

  /**
   * UserCurriculumMapping findFirstOrThrow
   */
  export type UserCurriculumMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserCurriculumMapping to fetch.
     */
    where?: UserCurriculumMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCurriculumMappings to fetch.
     */
    orderBy?: UserCurriculumMappingOrderByWithRelationInput | UserCurriculumMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCurriculumMappings.
     */
    cursor?: UserCurriculumMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCurriculumMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCurriculumMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCurriculumMappings.
     */
    distinct?: UserCurriculumMappingScalarFieldEnum | UserCurriculumMappingScalarFieldEnum[]
  }

  /**
   * UserCurriculumMapping findMany
   */
  export type UserCurriculumMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserCurriculumMappings to fetch.
     */
    where?: UserCurriculumMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCurriculumMappings to fetch.
     */
    orderBy?: UserCurriculumMappingOrderByWithRelationInput | UserCurriculumMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCurriculumMappings.
     */
    cursor?: UserCurriculumMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCurriculumMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCurriculumMappings.
     */
    skip?: number
    distinct?: UserCurriculumMappingScalarFieldEnum | UserCurriculumMappingScalarFieldEnum[]
  }

  /**
   * UserCurriculumMapping create
   */
  export type UserCurriculumMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCurriculumMapping.
     */
    data: XOR<UserCurriculumMappingCreateInput, UserCurriculumMappingUncheckedCreateInput>
  }

  /**
   * UserCurriculumMapping createMany
   */
  export type UserCurriculumMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCurriculumMappings.
     */
    data: UserCurriculumMappingCreateManyInput | UserCurriculumMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCurriculumMapping createManyAndReturn
   */
  export type UserCurriculumMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * The data used to create many UserCurriculumMappings.
     */
    data: UserCurriculumMappingCreateManyInput | UserCurriculumMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCurriculumMapping update
   */
  export type UserCurriculumMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCurriculumMapping.
     */
    data: XOR<UserCurriculumMappingUpdateInput, UserCurriculumMappingUncheckedUpdateInput>
    /**
     * Choose, which UserCurriculumMapping to update.
     */
    where: UserCurriculumMappingWhereUniqueInput
  }

  /**
   * UserCurriculumMapping updateMany
   */
  export type UserCurriculumMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCurriculumMappings.
     */
    data: XOR<UserCurriculumMappingUpdateManyMutationInput, UserCurriculumMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserCurriculumMappings to update
     */
    where?: UserCurriculumMappingWhereInput
    /**
     * Limit how many UserCurriculumMappings to update.
     */
    limit?: number
  }

  /**
   * UserCurriculumMapping updateManyAndReturn
   */
  export type UserCurriculumMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * The data used to update UserCurriculumMappings.
     */
    data: XOR<UserCurriculumMappingUpdateManyMutationInput, UserCurriculumMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserCurriculumMappings to update
     */
    where?: UserCurriculumMappingWhereInput
    /**
     * Limit how many UserCurriculumMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCurriculumMapping upsert
   */
  export type UserCurriculumMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCurriculumMapping to update in case it exists.
     */
    where: UserCurriculumMappingWhereUniqueInput
    /**
     * In case the UserCurriculumMapping found by the `where` argument doesn't exist, create a new UserCurriculumMapping with this data.
     */
    create: XOR<UserCurriculumMappingCreateInput, UserCurriculumMappingUncheckedCreateInput>
    /**
     * In case the UserCurriculumMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCurriculumMappingUpdateInput, UserCurriculumMappingUncheckedUpdateInput>
  }

  /**
   * UserCurriculumMapping delete
   */
  export type UserCurriculumMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
    /**
     * Filter which UserCurriculumMapping to delete.
     */
    where: UserCurriculumMappingWhereUniqueInput
  }

  /**
   * UserCurriculumMapping deleteMany
   */
  export type UserCurriculumMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCurriculumMappings to delete
     */
    where?: UserCurriculumMappingWhereInput
    /**
     * Limit how many UserCurriculumMappings to delete.
     */
    limit?: number
  }

  /**
   * UserCurriculumMapping without action
   */
  export type UserCurriculumMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCurriculumMapping
     */
    select?: UserCurriculumMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCurriculumMapping
     */
    omit?: UserCurriculumMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCurriculumMappingInclude<ExtArgs> | null
  }


  /**
   * Model UserGradeMapping
   */

  export type AggregateUserGradeMapping = {
    _count: UserGradeMappingCountAggregateOutputType | null
    _avg: UserGradeMappingAvgAggregateOutputType | null
    _sum: UserGradeMappingSumAggregateOutputType | null
    _min: UserGradeMappingMinAggregateOutputType | null
    _max: UserGradeMappingMaxAggregateOutputType | null
  }

  export type UserGradeMappingAvgAggregateOutputType = {
    gradeId: number | null
  }

  export type UserGradeMappingSumAggregateOutputType = {
    gradeId: bigint | null
  }

  export type UserGradeMappingMinAggregateOutputType = {
    userId: string | null
    gradeId: bigint | null
  }

  export type UserGradeMappingMaxAggregateOutputType = {
    userId: string | null
    gradeId: bigint | null
  }

  export type UserGradeMappingCountAggregateOutputType = {
    userId: number
    gradeId: number
    _all: number
  }


  export type UserGradeMappingAvgAggregateInputType = {
    gradeId?: true
  }

  export type UserGradeMappingSumAggregateInputType = {
    gradeId?: true
  }

  export type UserGradeMappingMinAggregateInputType = {
    userId?: true
    gradeId?: true
  }

  export type UserGradeMappingMaxAggregateInputType = {
    userId?: true
    gradeId?: true
  }

  export type UserGradeMappingCountAggregateInputType = {
    userId?: true
    gradeId?: true
    _all?: true
  }

  export type UserGradeMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGradeMapping to aggregate.
     */
    where?: UserGradeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGradeMappings to fetch.
     */
    orderBy?: UserGradeMappingOrderByWithRelationInput | UserGradeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserGradeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGradeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGradeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserGradeMappings
    **/
    _count?: true | UserGradeMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserGradeMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserGradeMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserGradeMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserGradeMappingMaxAggregateInputType
  }

  export type GetUserGradeMappingAggregateType<T extends UserGradeMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserGradeMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserGradeMapping[P]>
      : GetScalarType<T[P], AggregateUserGradeMapping[P]>
  }




  export type UserGradeMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserGradeMappingWhereInput
    orderBy?: UserGradeMappingOrderByWithAggregationInput | UserGradeMappingOrderByWithAggregationInput[]
    by: UserGradeMappingScalarFieldEnum[] | UserGradeMappingScalarFieldEnum
    having?: UserGradeMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserGradeMappingCountAggregateInputType | true
    _avg?: UserGradeMappingAvgAggregateInputType
    _sum?: UserGradeMappingSumAggregateInputType
    _min?: UserGradeMappingMinAggregateInputType
    _max?: UserGradeMappingMaxAggregateInputType
  }

  export type UserGradeMappingGroupByOutputType = {
    userId: string
    gradeId: bigint
    _count: UserGradeMappingCountAggregateOutputType | null
    _avg: UserGradeMappingAvgAggregateOutputType | null
    _sum: UserGradeMappingSumAggregateOutputType | null
    _min: UserGradeMappingMinAggregateOutputType | null
    _max: UserGradeMappingMaxAggregateOutputType | null
  }

  type GetUserGradeMappingGroupByPayload<T extends UserGradeMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGradeMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGradeMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGradeMappingGroupByOutputType[P]>
            : GetScalarType<T[P], UserGradeMappingGroupByOutputType[P]>
        }
      >
    >


  export type UserGradeMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    gradeId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGradeMapping"]>

  export type UserGradeMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    gradeId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGradeMapping"]>

  export type UserGradeMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    gradeId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userGradeMapping"]>

  export type UserGradeMappingSelectScalar = {
    userId?: boolean
    gradeId?: boolean
  }

  export type UserGradeMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "gradeId", ExtArgs["result"]["userGradeMapping"]>
  export type UserGradeMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }
  export type UserGradeMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }
  export type UserGradeMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    grade?: boolean | GradeDefaultArgs<ExtArgs>
  }

  export type $UserGradeMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserGradeMapping"
    objects: {
      user: Prisma.$ProfilePayload<ExtArgs>
      grade: Prisma.$GradePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      gradeId: bigint
    }, ExtArgs["result"]["userGradeMapping"]>
    composites: {}
  }

  type UserGradeMappingGetPayload<S extends boolean | null | undefined | UserGradeMappingDefaultArgs> = $Result.GetResult<Prisma.$UserGradeMappingPayload, S>

  type UserGradeMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserGradeMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserGradeMappingCountAggregateInputType | true
    }

  export interface UserGradeMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserGradeMapping'], meta: { name: 'UserGradeMapping' } }
    /**
     * Find zero or one UserGradeMapping that matches the filter.
     * @param {UserGradeMappingFindUniqueArgs} args - Arguments to find a UserGradeMapping
     * @example
     * // Get one UserGradeMapping
     * const userGradeMapping = await prisma.userGradeMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserGradeMappingFindUniqueArgs>(args: SelectSubset<T, UserGradeMappingFindUniqueArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserGradeMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserGradeMappingFindUniqueOrThrowArgs} args - Arguments to find a UserGradeMapping
     * @example
     * // Get one UserGradeMapping
     * const userGradeMapping = await prisma.userGradeMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserGradeMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserGradeMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGradeMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGradeMappingFindFirstArgs} args - Arguments to find a UserGradeMapping
     * @example
     * // Get one UserGradeMapping
     * const userGradeMapping = await prisma.userGradeMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserGradeMappingFindFirstArgs>(args?: SelectSubset<T, UserGradeMappingFindFirstArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserGradeMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGradeMappingFindFirstOrThrowArgs} args - Arguments to find a UserGradeMapping
     * @example
     * // Get one UserGradeMapping
     * const userGradeMapping = await prisma.userGradeMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserGradeMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserGradeMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserGradeMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGradeMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserGradeMappings
     * const userGradeMappings = await prisma.userGradeMapping.findMany()
     * 
     * // Get first 10 UserGradeMappings
     * const userGradeMappings = await prisma.userGradeMapping.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userGradeMappingWithUserIdOnly = await prisma.userGradeMapping.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserGradeMappingFindManyArgs>(args?: SelectSubset<T, UserGradeMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserGradeMapping.
     * @param {UserGradeMappingCreateArgs} args - Arguments to create a UserGradeMapping.
     * @example
     * // Create one UserGradeMapping
     * const UserGradeMapping = await prisma.userGradeMapping.create({
     *   data: {
     *     // ... data to create a UserGradeMapping
     *   }
     * })
     * 
     */
    create<T extends UserGradeMappingCreateArgs>(args: SelectSubset<T, UserGradeMappingCreateArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserGradeMappings.
     * @param {UserGradeMappingCreateManyArgs} args - Arguments to create many UserGradeMappings.
     * @example
     * // Create many UserGradeMappings
     * const userGradeMapping = await prisma.userGradeMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserGradeMappingCreateManyArgs>(args?: SelectSubset<T, UserGradeMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserGradeMappings and returns the data saved in the database.
     * @param {UserGradeMappingCreateManyAndReturnArgs} args - Arguments to create many UserGradeMappings.
     * @example
     * // Create many UserGradeMappings
     * const userGradeMapping = await prisma.userGradeMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserGradeMappings and only return the `userId`
     * const userGradeMappingWithUserIdOnly = await prisma.userGradeMapping.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserGradeMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserGradeMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserGradeMapping.
     * @param {UserGradeMappingDeleteArgs} args - Arguments to delete one UserGradeMapping.
     * @example
     * // Delete one UserGradeMapping
     * const UserGradeMapping = await prisma.userGradeMapping.delete({
     *   where: {
     *     // ... filter to delete one UserGradeMapping
     *   }
     * })
     * 
     */
    delete<T extends UserGradeMappingDeleteArgs>(args: SelectSubset<T, UserGradeMappingDeleteArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserGradeMapping.
     * @param {UserGradeMappingUpdateArgs} args - Arguments to update one UserGradeMapping.
     * @example
     * // Update one UserGradeMapping
     * const userGradeMapping = await prisma.userGradeMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserGradeMappingUpdateArgs>(args: SelectSubset<T, UserGradeMappingUpdateArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserGradeMappings.
     * @param {UserGradeMappingDeleteManyArgs} args - Arguments to filter UserGradeMappings to delete.
     * @example
     * // Delete a few UserGradeMappings
     * const { count } = await prisma.userGradeMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserGradeMappingDeleteManyArgs>(args?: SelectSubset<T, UserGradeMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGradeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGradeMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserGradeMappings
     * const userGradeMapping = await prisma.userGradeMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserGradeMappingUpdateManyArgs>(args: SelectSubset<T, UserGradeMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserGradeMappings and returns the data updated in the database.
     * @param {UserGradeMappingUpdateManyAndReturnArgs} args - Arguments to update many UserGradeMappings.
     * @example
     * // Update many UserGradeMappings
     * const userGradeMapping = await prisma.userGradeMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserGradeMappings and only return the `userId`
     * const userGradeMappingWithUserIdOnly = await prisma.userGradeMapping.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserGradeMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserGradeMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserGradeMapping.
     * @param {UserGradeMappingUpsertArgs} args - Arguments to update or create a UserGradeMapping.
     * @example
     * // Update or create a UserGradeMapping
     * const userGradeMapping = await prisma.userGradeMapping.upsert({
     *   create: {
     *     // ... data to create a UserGradeMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserGradeMapping we want to update
     *   }
     * })
     */
    upsert<T extends UserGradeMappingUpsertArgs>(args: SelectSubset<T, UserGradeMappingUpsertArgs<ExtArgs>>): Prisma__UserGradeMappingClient<$Result.GetResult<Prisma.$UserGradeMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserGradeMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGradeMappingCountArgs} args - Arguments to filter UserGradeMappings to count.
     * @example
     * // Count the number of UserGradeMappings
     * const count = await prisma.userGradeMapping.count({
     *   where: {
     *     // ... the filter for the UserGradeMappings we want to count
     *   }
     * })
    **/
    count<T extends UserGradeMappingCountArgs>(
      args?: Subset<T, UserGradeMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserGradeMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserGradeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGradeMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserGradeMappingAggregateArgs>(args: Subset<T, UserGradeMappingAggregateArgs>): Prisma.PrismaPromise<GetUserGradeMappingAggregateType<T>>

    /**
     * Group by UserGradeMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGradeMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGradeMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGradeMappingGroupByArgs['orderBy'] }
        : { orderBy?: UserGradeMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGradeMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGradeMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserGradeMapping model
   */
  readonly fields: UserGradeMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserGradeMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserGradeMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grade<T extends GradeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GradeDefaultArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserGradeMapping model
   */
  interface UserGradeMappingFieldRefs {
    readonly userId: FieldRef<"UserGradeMapping", 'String'>
    readonly gradeId: FieldRef<"UserGradeMapping", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * UserGradeMapping findUnique
   */
  export type UserGradeMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserGradeMapping to fetch.
     */
    where: UserGradeMappingWhereUniqueInput
  }

  /**
   * UserGradeMapping findUniqueOrThrow
   */
  export type UserGradeMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserGradeMapping to fetch.
     */
    where: UserGradeMappingWhereUniqueInput
  }

  /**
   * UserGradeMapping findFirst
   */
  export type UserGradeMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserGradeMapping to fetch.
     */
    where?: UserGradeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGradeMappings to fetch.
     */
    orderBy?: UserGradeMappingOrderByWithRelationInput | UserGradeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGradeMappings.
     */
    cursor?: UserGradeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGradeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGradeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGradeMappings.
     */
    distinct?: UserGradeMappingScalarFieldEnum | UserGradeMappingScalarFieldEnum[]
  }

  /**
   * UserGradeMapping findFirstOrThrow
   */
  export type UserGradeMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserGradeMapping to fetch.
     */
    where?: UserGradeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGradeMappings to fetch.
     */
    orderBy?: UserGradeMappingOrderByWithRelationInput | UserGradeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserGradeMappings.
     */
    cursor?: UserGradeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGradeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGradeMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserGradeMappings.
     */
    distinct?: UserGradeMappingScalarFieldEnum | UserGradeMappingScalarFieldEnum[]
  }

  /**
   * UserGradeMapping findMany
   */
  export type UserGradeMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserGradeMappings to fetch.
     */
    where?: UserGradeMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserGradeMappings to fetch.
     */
    orderBy?: UserGradeMappingOrderByWithRelationInput | UserGradeMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserGradeMappings.
     */
    cursor?: UserGradeMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserGradeMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserGradeMappings.
     */
    skip?: number
    distinct?: UserGradeMappingScalarFieldEnum | UserGradeMappingScalarFieldEnum[]
  }

  /**
   * UserGradeMapping create
   */
  export type UserGradeMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserGradeMapping.
     */
    data: XOR<UserGradeMappingCreateInput, UserGradeMappingUncheckedCreateInput>
  }

  /**
   * UserGradeMapping createMany
   */
  export type UserGradeMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserGradeMappings.
     */
    data: UserGradeMappingCreateManyInput | UserGradeMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserGradeMapping createManyAndReturn
   */
  export type UserGradeMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * The data used to create many UserGradeMappings.
     */
    data: UserGradeMappingCreateManyInput | UserGradeMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGradeMapping update
   */
  export type UserGradeMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserGradeMapping.
     */
    data: XOR<UserGradeMappingUpdateInput, UserGradeMappingUncheckedUpdateInput>
    /**
     * Choose, which UserGradeMapping to update.
     */
    where: UserGradeMappingWhereUniqueInput
  }

  /**
   * UserGradeMapping updateMany
   */
  export type UserGradeMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserGradeMappings.
     */
    data: XOR<UserGradeMappingUpdateManyMutationInput, UserGradeMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserGradeMappings to update
     */
    where?: UserGradeMappingWhereInput
    /**
     * Limit how many UserGradeMappings to update.
     */
    limit?: number
  }

  /**
   * UserGradeMapping updateManyAndReturn
   */
  export type UserGradeMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * The data used to update UserGradeMappings.
     */
    data: XOR<UserGradeMappingUpdateManyMutationInput, UserGradeMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserGradeMappings to update
     */
    where?: UserGradeMappingWhereInput
    /**
     * Limit how many UserGradeMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserGradeMapping upsert
   */
  export type UserGradeMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserGradeMapping to update in case it exists.
     */
    where: UserGradeMappingWhereUniqueInput
    /**
     * In case the UserGradeMapping found by the `where` argument doesn't exist, create a new UserGradeMapping with this data.
     */
    create: XOR<UserGradeMappingCreateInput, UserGradeMappingUncheckedCreateInput>
    /**
     * In case the UserGradeMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserGradeMappingUpdateInput, UserGradeMappingUncheckedUpdateInput>
  }

  /**
   * UserGradeMapping delete
   */
  export type UserGradeMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
    /**
     * Filter which UserGradeMapping to delete.
     */
    where: UserGradeMappingWhereUniqueInput
  }

  /**
   * UserGradeMapping deleteMany
   */
  export type UserGradeMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserGradeMappings to delete
     */
    where?: UserGradeMappingWhereInput
    /**
     * Limit how many UserGradeMappings to delete.
     */
    limit?: number
  }

  /**
   * UserGradeMapping without action
   */
  export type UserGradeMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserGradeMapping
     */
    select?: UserGradeMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserGradeMapping
     */
    omit?: UserGradeMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserGradeMappingInclude<ExtArgs> | null
  }


  /**
   * Model UserSubjectMapping
   */

  export type AggregateUserSubjectMapping = {
    _count: UserSubjectMappingCountAggregateOutputType | null
    _avg: UserSubjectMappingAvgAggregateOutputType | null
    _sum: UserSubjectMappingSumAggregateOutputType | null
    _min: UserSubjectMappingMinAggregateOutputType | null
    _max: UserSubjectMappingMaxAggregateOutputType | null
  }

  export type UserSubjectMappingAvgAggregateOutputType = {
    subjectId: number | null
  }

  export type UserSubjectMappingSumAggregateOutputType = {
    subjectId: bigint | null
  }

  export type UserSubjectMappingMinAggregateOutputType = {
    userId: string | null
    subjectId: bigint | null
  }

  export type UserSubjectMappingMaxAggregateOutputType = {
    userId: string | null
    subjectId: bigint | null
  }

  export type UserSubjectMappingCountAggregateOutputType = {
    userId: number
    subjectId: number
    _all: number
  }


  export type UserSubjectMappingAvgAggregateInputType = {
    subjectId?: true
  }

  export type UserSubjectMappingSumAggregateInputType = {
    subjectId?: true
  }

  export type UserSubjectMappingMinAggregateInputType = {
    userId?: true
    subjectId?: true
  }

  export type UserSubjectMappingMaxAggregateInputType = {
    userId?: true
    subjectId?: true
  }

  export type UserSubjectMappingCountAggregateInputType = {
    userId?: true
    subjectId?: true
    _all?: true
  }

  export type UserSubjectMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubjectMapping to aggregate.
     */
    where?: UserSubjectMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubjectMappings to fetch.
     */
    orderBy?: UserSubjectMappingOrderByWithRelationInput | UserSubjectMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubjectMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubjectMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubjectMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubjectMappings
    **/
    _count?: true | UserSubjectMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSubjectMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSubjectMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubjectMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubjectMappingMaxAggregateInputType
  }

  export type GetUserSubjectMappingAggregateType<T extends UserSubjectMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubjectMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubjectMapping[P]>
      : GetScalarType<T[P], AggregateUserSubjectMapping[P]>
  }




  export type UserSubjectMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubjectMappingWhereInput
    orderBy?: UserSubjectMappingOrderByWithAggregationInput | UserSubjectMappingOrderByWithAggregationInput[]
    by: UserSubjectMappingScalarFieldEnum[] | UserSubjectMappingScalarFieldEnum
    having?: UserSubjectMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubjectMappingCountAggregateInputType | true
    _avg?: UserSubjectMappingAvgAggregateInputType
    _sum?: UserSubjectMappingSumAggregateInputType
    _min?: UserSubjectMappingMinAggregateInputType
    _max?: UserSubjectMappingMaxAggregateInputType
  }

  export type UserSubjectMappingGroupByOutputType = {
    userId: string
    subjectId: bigint
    _count: UserSubjectMappingCountAggregateOutputType | null
    _avg: UserSubjectMappingAvgAggregateOutputType | null
    _sum: UserSubjectMappingSumAggregateOutputType | null
    _min: UserSubjectMappingMinAggregateOutputType | null
    _max: UserSubjectMappingMaxAggregateOutputType | null
  }

  type GetUserSubjectMappingGroupByPayload<T extends UserSubjectMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubjectMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubjectMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubjectMappingGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubjectMappingGroupByOutputType[P]>
        }
      >
    >


  export type UserSubjectMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    subjectId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubjectMapping"]>

  export type UserSubjectMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    subjectId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubjectMapping"]>

  export type UserSubjectMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    subjectId?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSubjectMapping"]>

  export type UserSubjectMappingSelectScalar = {
    userId?: boolean
    subjectId?: boolean
  }

  export type UserSubjectMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "subjectId", ExtArgs["result"]["userSubjectMapping"]>
  export type UserSubjectMappingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type UserSubjectMappingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type UserSubjectMappingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $UserSubjectMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubjectMapping"
    objects: {
      user: Prisma.$ProfilePayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      subjectId: bigint
    }, ExtArgs["result"]["userSubjectMapping"]>
    composites: {}
  }

  type UserSubjectMappingGetPayload<S extends boolean | null | undefined | UserSubjectMappingDefaultArgs> = $Result.GetResult<Prisma.$UserSubjectMappingPayload, S>

  type UserSubjectMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSubjectMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSubjectMappingCountAggregateInputType | true
    }

  export interface UserSubjectMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubjectMapping'], meta: { name: 'UserSubjectMapping' } }
    /**
     * Find zero or one UserSubjectMapping that matches the filter.
     * @param {UserSubjectMappingFindUniqueArgs} args - Arguments to find a UserSubjectMapping
     * @example
     * // Get one UserSubjectMapping
     * const userSubjectMapping = await prisma.userSubjectMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubjectMappingFindUniqueArgs>(args: SelectSubset<T, UserSubjectMappingFindUniqueArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSubjectMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSubjectMappingFindUniqueOrThrowArgs} args - Arguments to find a UserSubjectMapping
     * @example
     * // Get one UserSubjectMapping
     * const userSubjectMapping = await prisma.userSubjectMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubjectMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubjectMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubjectMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubjectMappingFindFirstArgs} args - Arguments to find a UserSubjectMapping
     * @example
     * // Get one UserSubjectMapping
     * const userSubjectMapping = await prisma.userSubjectMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubjectMappingFindFirstArgs>(args?: SelectSubset<T, UserSubjectMappingFindFirstArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSubjectMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubjectMappingFindFirstOrThrowArgs} args - Arguments to find a UserSubjectMapping
     * @example
     * // Get one UserSubjectMapping
     * const userSubjectMapping = await prisma.userSubjectMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubjectMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubjectMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSubjectMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubjectMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubjectMappings
     * const userSubjectMappings = await prisma.userSubjectMapping.findMany()
     * 
     * // Get first 10 UserSubjectMappings
     * const userSubjectMappings = await prisma.userSubjectMapping.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSubjectMappingWithUserIdOnly = await prisma.userSubjectMapping.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSubjectMappingFindManyArgs>(args?: SelectSubset<T, UserSubjectMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSubjectMapping.
     * @param {UserSubjectMappingCreateArgs} args - Arguments to create a UserSubjectMapping.
     * @example
     * // Create one UserSubjectMapping
     * const UserSubjectMapping = await prisma.userSubjectMapping.create({
     *   data: {
     *     // ... data to create a UserSubjectMapping
     *   }
     * })
     * 
     */
    create<T extends UserSubjectMappingCreateArgs>(args: SelectSubset<T, UserSubjectMappingCreateArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSubjectMappings.
     * @param {UserSubjectMappingCreateManyArgs} args - Arguments to create many UserSubjectMappings.
     * @example
     * // Create many UserSubjectMappings
     * const userSubjectMapping = await prisma.userSubjectMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubjectMappingCreateManyArgs>(args?: SelectSubset<T, UserSubjectMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubjectMappings and returns the data saved in the database.
     * @param {UserSubjectMappingCreateManyAndReturnArgs} args - Arguments to create many UserSubjectMappings.
     * @example
     * // Create many UserSubjectMappings
     * const userSubjectMapping = await prisma.userSubjectMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubjectMappings and only return the `userId`
     * const userSubjectMappingWithUserIdOnly = await prisma.userSubjectMapping.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubjectMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubjectMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSubjectMapping.
     * @param {UserSubjectMappingDeleteArgs} args - Arguments to delete one UserSubjectMapping.
     * @example
     * // Delete one UserSubjectMapping
     * const UserSubjectMapping = await prisma.userSubjectMapping.delete({
     *   where: {
     *     // ... filter to delete one UserSubjectMapping
     *   }
     * })
     * 
     */
    delete<T extends UserSubjectMappingDeleteArgs>(args: SelectSubset<T, UserSubjectMappingDeleteArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSubjectMapping.
     * @param {UserSubjectMappingUpdateArgs} args - Arguments to update one UserSubjectMapping.
     * @example
     * // Update one UserSubjectMapping
     * const userSubjectMapping = await prisma.userSubjectMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubjectMappingUpdateArgs>(args: SelectSubset<T, UserSubjectMappingUpdateArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSubjectMappings.
     * @param {UserSubjectMappingDeleteManyArgs} args - Arguments to filter UserSubjectMappings to delete.
     * @example
     * // Delete a few UserSubjectMappings
     * const { count } = await prisma.userSubjectMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubjectMappingDeleteManyArgs>(args?: SelectSubset<T, UserSubjectMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubjectMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubjectMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubjectMappings
     * const userSubjectMapping = await prisma.userSubjectMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubjectMappingUpdateManyArgs>(args: SelectSubset<T, UserSubjectMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubjectMappings and returns the data updated in the database.
     * @param {UserSubjectMappingUpdateManyAndReturnArgs} args - Arguments to update many UserSubjectMappings.
     * @example
     * // Update many UserSubjectMappings
     * const userSubjectMapping = await prisma.userSubjectMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSubjectMappings and only return the `userId`
     * const userSubjectMappingWithUserIdOnly = await prisma.userSubjectMapping.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSubjectMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSubjectMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSubjectMapping.
     * @param {UserSubjectMappingUpsertArgs} args - Arguments to update or create a UserSubjectMapping.
     * @example
     * // Update or create a UserSubjectMapping
     * const userSubjectMapping = await prisma.userSubjectMapping.upsert({
     *   create: {
     *     // ... data to create a UserSubjectMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubjectMapping we want to update
     *   }
     * })
     */
    upsert<T extends UserSubjectMappingUpsertArgs>(args: SelectSubset<T, UserSubjectMappingUpsertArgs<ExtArgs>>): Prisma__UserSubjectMappingClient<$Result.GetResult<Prisma.$UserSubjectMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSubjectMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubjectMappingCountArgs} args - Arguments to filter UserSubjectMappings to count.
     * @example
     * // Count the number of UserSubjectMappings
     * const count = await prisma.userSubjectMapping.count({
     *   where: {
     *     // ... the filter for the UserSubjectMappings we want to count
     *   }
     * })
    **/
    count<T extends UserSubjectMappingCountArgs>(
      args?: Subset<T, UserSubjectMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubjectMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubjectMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubjectMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubjectMappingAggregateArgs>(args: Subset<T, UserSubjectMappingAggregateArgs>): Prisma.PrismaPromise<GetUserSubjectMappingAggregateType<T>>

    /**
     * Group by UserSubjectMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubjectMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubjectMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubjectMappingGroupByArgs['orderBy'] }
        : { orderBy?: UserSubjectMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubjectMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubjectMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubjectMapping model
   */
  readonly fields: UserSubjectMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubjectMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubjectMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubjectMapping model
   */
  interface UserSubjectMappingFieldRefs {
    readonly userId: FieldRef<"UserSubjectMapping", 'String'>
    readonly subjectId: FieldRef<"UserSubjectMapping", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * UserSubjectMapping findUnique
   */
  export type UserSubjectMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserSubjectMapping to fetch.
     */
    where: UserSubjectMappingWhereUniqueInput
  }

  /**
   * UserSubjectMapping findUniqueOrThrow
   */
  export type UserSubjectMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserSubjectMapping to fetch.
     */
    where: UserSubjectMappingWhereUniqueInput
  }

  /**
   * UserSubjectMapping findFirst
   */
  export type UserSubjectMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserSubjectMapping to fetch.
     */
    where?: UserSubjectMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubjectMappings to fetch.
     */
    orderBy?: UserSubjectMappingOrderByWithRelationInput | UserSubjectMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubjectMappings.
     */
    cursor?: UserSubjectMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubjectMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubjectMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubjectMappings.
     */
    distinct?: UserSubjectMappingScalarFieldEnum | UserSubjectMappingScalarFieldEnum[]
  }

  /**
   * UserSubjectMapping findFirstOrThrow
   */
  export type UserSubjectMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserSubjectMapping to fetch.
     */
    where?: UserSubjectMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubjectMappings to fetch.
     */
    orderBy?: UserSubjectMappingOrderByWithRelationInput | UserSubjectMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubjectMappings.
     */
    cursor?: UserSubjectMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubjectMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubjectMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubjectMappings.
     */
    distinct?: UserSubjectMappingScalarFieldEnum | UserSubjectMappingScalarFieldEnum[]
  }

  /**
   * UserSubjectMapping findMany
   */
  export type UserSubjectMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * Filter, which UserSubjectMappings to fetch.
     */
    where?: UserSubjectMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubjectMappings to fetch.
     */
    orderBy?: UserSubjectMappingOrderByWithRelationInput | UserSubjectMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubjectMappings.
     */
    cursor?: UserSubjectMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubjectMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubjectMappings.
     */
    skip?: number
    distinct?: UserSubjectMappingScalarFieldEnum | UserSubjectMappingScalarFieldEnum[]
  }

  /**
   * UserSubjectMapping create
   */
  export type UserSubjectMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSubjectMapping.
     */
    data: XOR<UserSubjectMappingCreateInput, UserSubjectMappingUncheckedCreateInput>
  }

  /**
   * UserSubjectMapping createMany
   */
  export type UserSubjectMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubjectMappings.
     */
    data: UserSubjectMappingCreateManyInput | UserSubjectMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubjectMapping createManyAndReturn
   */
  export type UserSubjectMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * The data used to create many UserSubjectMappings.
     */
    data: UserSubjectMappingCreateManyInput | UserSubjectMappingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubjectMapping update
   */
  export type UserSubjectMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSubjectMapping.
     */
    data: XOR<UserSubjectMappingUpdateInput, UserSubjectMappingUncheckedUpdateInput>
    /**
     * Choose, which UserSubjectMapping to update.
     */
    where: UserSubjectMappingWhereUniqueInput
  }

  /**
   * UserSubjectMapping updateMany
   */
  export type UserSubjectMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubjectMappings.
     */
    data: XOR<UserSubjectMappingUpdateManyMutationInput, UserSubjectMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserSubjectMappings to update
     */
    where?: UserSubjectMappingWhereInput
    /**
     * Limit how many UserSubjectMappings to update.
     */
    limit?: number
  }

  /**
   * UserSubjectMapping updateManyAndReturn
   */
  export type UserSubjectMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * The data used to update UserSubjectMappings.
     */
    data: XOR<UserSubjectMappingUpdateManyMutationInput, UserSubjectMappingUncheckedUpdateManyInput>
    /**
     * Filter which UserSubjectMappings to update
     */
    where?: UserSubjectMappingWhereInput
    /**
     * Limit how many UserSubjectMappings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSubjectMapping upsert
   */
  export type UserSubjectMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSubjectMapping to update in case it exists.
     */
    where: UserSubjectMappingWhereUniqueInput
    /**
     * In case the UserSubjectMapping found by the `where` argument doesn't exist, create a new UserSubjectMapping with this data.
     */
    create: XOR<UserSubjectMappingCreateInput, UserSubjectMappingUncheckedCreateInput>
    /**
     * In case the UserSubjectMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubjectMappingUpdateInput, UserSubjectMappingUncheckedUpdateInput>
  }

  /**
   * UserSubjectMapping delete
   */
  export type UserSubjectMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
    /**
     * Filter which UserSubjectMapping to delete.
     */
    where: UserSubjectMappingWhereUniqueInput
  }

  /**
   * UserSubjectMapping deleteMany
   */
  export type UserSubjectMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubjectMappings to delete
     */
    where?: UserSubjectMappingWhereInput
    /**
     * Limit how many UserSubjectMappings to delete.
     */
    limit?: number
  }

  /**
   * UserSubjectMapping without action
   */
  export type UserSubjectMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubjectMapping
     */
    select?: UserSubjectMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSubjectMapping
     */
    omit?: UserSubjectMappingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSubjectMappingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuthUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    emailVerifiedAt: 'emailVerifiedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId'
  };

  export type AuthUserScalarFieldEnum = (typeof AuthUserScalarFieldEnum)[keyof typeof AuthUserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    authId: 'authId',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const IdentityScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    providerId: 'providerId',
    authId: 'authId',
    createdAt: 'createdAt'
  };

  export type IdentityScalarFieldEnum = (typeof IdentityScalarFieldEnum)[keyof typeof IdentityScalarFieldEnum]


  export const CurriculumScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    image: 'image',
    name: 'name',
    description: 'description',
    isDeleted: 'isDeleted'
  };

  export type CurriculumScalarFieldEnum = (typeof CurriculumScalarFieldEnum)[keyof typeof CurriculumScalarFieldEnum]


  export const AcademicYearScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActiveSession: 'isActiveSession',
    isDeleted: 'isDeleted',
    curriculumId: 'curriculumId'
  };

  export type AcademicYearScalarFieldEnum = (typeof AcademicYearScalarFieldEnum)[keyof typeof AcademicYearScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    sortOrder: 'sortOrder'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    avatarUrl: 'avatarUrl',
    gender: 'gender',
    dob: 'dob',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userType: 'userType',
    phoneNumber: 'phoneNumber',
    email: 'email',
    isDeleted: 'isDeleted',
    isDeactivated: 'isDeactivated',
    deviceId: 'deviceId',
    fcmDeviceToken: 'fcmDeviceToken',
    isNotificationEnabled: 'isNotificationEnabled'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    image: 'image',
    description: 'description',
    name: 'name',
    isDeleted: 'isDeleted',
    curriculumId: 'curriculumId'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    name: 'name',
    image: 'image',
    description: 'description',
    isDeleted: 'isDeleted',
    gradeId: 'gradeId'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    title: 'title',
    sortOrder: 'sortOrder',
    imageUrl: 'imageUrl',
    isDeleted: 'isDeleted',
    subjectId: 'subjectId',
    label: 'label',
    updatedAt: 'updatedAt',
    content: 'content',
    teacherGuide: 'teacherGuide'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    schoolName: 'schoolName',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const UserAcademicYearMappingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentGradeId: 'studentGradeId',
    academicYearId: 'academicYearId',
    createdAt: 'createdAt'
  };

  export type UserAcademicYearMappingScalarFieldEnum = (typeof UserAcademicYearMappingScalarFieldEnum)[keyof typeof UserAcademicYearMappingScalarFieldEnum]


  export const UserCurriculumMappingScalarFieldEnum: {
    userId: 'userId',
    curriculumId: 'curriculumId'
  };

  export type UserCurriculumMappingScalarFieldEnum = (typeof UserCurriculumMappingScalarFieldEnum)[keyof typeof UserCurriculumMappingScalarFieldEnum]


  export const UserGradeMappingScalarFieldEnum: {
    userId: 'userId',
    gradeId: 'gradeId'
  };

  export type UserGradeMappingScalarFieldEnum = (typeof UserGradeMappingScalarFieldEnum)[keyof typeof UserGradeMappingScalarFieldEnum]


  export const UserSubjectMappingScalarFieldEnum: {
    userId: 'userId',
    subjectId: 'subjectId'
  };

  export type UserSubjectMappingScalarFieldEnum = (typeof UserSubjectMappingScalarFieldEnum)[keyof typeof UserSubjectMappingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AuthUserWhereInput = {
    AND?: AuthUserWhereInput | AuthUserWhereInput[]
    OR?: AuthUserWhereInput[]
    NOT?: AuthUserWhereInput | AuthUserWhereInput[]
    id?: StringFilter<"AuthUser"> | string
    email?: StringFilter<"AuthUser"> | string
    passwordHash?: StringNullableFilter<"AuthUser"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"AuthUser"> | Date | string | null
    isActive?: BoolFilter<"AuthUser"> | boolean
    createdAt?: DateTimeFilter<"AuthUser"> | Date | string
    updatedAt?: DateTimeFilter<"AuthUser"> | Date | string
    profileId?: UuidNullableFilter<"AuthUser"> | string | null
    sessions?: SessionListRelationFilter
    identities?: IdentityListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type AuthUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    identities?: IdentityOrderByRelationAggregateInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type AuthUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    profileId?: string
    AND?: AuthUserWhereInput | AuthUserWhereInput[]
    OR?: AuthUserWhereInput[]
    NOT?: AuthUserWhereInput | AuthUserWhereInput[]
    passwordHash?: StringNullableFilter<"AuthUser"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"AuthUser"> | Date | string | null
    isActive?: BoolFilter<"AuthUser"> | boolean
    createdAt?: DateTimeFilter<"AuthUser"> | Date | string
    updatedAt?: DateTimeFilter<"AuthUser"> | Date | string
    sessions?: SessionListRelationFilter
    identities?: IdentityListRelationFilter
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id" | "email" | "profileId">

  export type AuthUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrderInput | SortOrder
    _count?: AuthUserCountOrderByAggregateInput
    _max?: AuthUserMaxOrderByAggregateInput
    _min?: AuthUserMinOrderByAggregateInput
  }

  export type AuthUserScalarWhereWithAggregatesInput = {
    AND?: AuthUserScalarWhereWithAggregatesInput | AuthUserScalarWhereWithAggregatesInput[]
    OR?: AuthUserScalarWhereWithAggregatesInput[]
    NOT?: AuthUserScalarWhereWithAggregatesInput | AuthUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthUser"> | string
    email?: StringWithAggregatesFilter<"AuthUser"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"AuthUser"> | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"AuthUser"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"AuthUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AuthUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthUser"> | Date | string
    profileId?: UuidNullableWithAggregatesFilter<"AuthUser"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    authId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    auth?: XOR<AuthUserScalarRelationFilter, AuthUserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    authId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    auth?: AuthUserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    authId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    auth?: XOR<AuthUserScalarRelationFilter, AuthUserWhereInput>
  }, "id" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    authId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    authId?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type IdentityWhereInput = {
    AND?: IdentityWhereInput | IdentityWhereInput[]
    OR?: IdentityWhereInput[]
    NOT?: IdentityWhereInput | IdentityWhereInput[]
    id?: StringFilter<"Identity"> | string
    provider?: EnumAuthProviderFilter<"Identity"> | $Enums.AuthProvider
    providerId?: StringFilter<"Identity"> | string
    authId?: StringFilter<"Identity"> | string
    createdAt?: DateTimeFilter<"Identity"> | Date | string
    auth?: XOR<AuthUserScalarRelationFilter, AuthUserWhereInput>
  }

  export type IdentityOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    authId?: SortOrder
    createdAt?: SortOrder
    auth?: AuthUserOrderByWithRelationInput
  }

  export type IdentityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerId?: IdentityProviderProviderIdCompoundUniqueInput
    AND?: IdentityWhereInput | IdentityWhereInput[]
    OR?: IdentityWhereInput[]
    NOT?: IdentityWhereInput | IdentityWhereInput[]
    provider?: EnumAuthProviderFilter<"Identity"> | $Enums.AuthProvider
    providerId?: StringFilter<"Identity"> | string
    authId?: StringFilter<"Identity"> | string
    createdAt?: DateTimeFilter<"Identity"> | Date | string
    auth?: XOR<AuthUserScalarRelationFilter, AuthUserWhereInput>
  }, "id" | "provider_providerId">

  export type IdentityOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    authId?: SortOrder
    createdAt?: SortOrder
    _count?: IdentityCountOrderByAggregateInput
    _max?: IdentityMaxOrderByAggregateInput
    _min?: IdentityMinOrderByAggregateInput
  }

  export type IdentityScalarWhereWithAggregatesInput = {
    AND?: IdentityScalarWhereWithAggregatesInput | IdentityScalarWhereWithAggregatesInput[]
    OR?: IdentityScalarWhereWithAggregatesInput[]
    NOT?: IdentityScalarWhereWithAggregatesInput | IdentityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Identity"> | string
    provider?: EnumAuthProviderWithAggregatesFilter<"Identity"> | $Enums.AuthProvider
    providerId?: StringWithAggregatesFilter<"Identity"> | string
    authId?: StringWithAggregatesFilter<"Identity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Identity"> | Date | string
  }

  export type CurriculumWhereInput = {
    AND?: CurriculumWhereInput | CurriculumWhereInput[]
    OR?: CurriculumWhereInput[]
    NOT?: CurriculumWhereInput | CurriculumWhereInput[]
    id?: BigIntFilter<"Curriculum"> | bigint | number
    createdAt?: DateTimeFilter<"Curriculum"> | Date | string
    image?: StringFilter<"Curriculum"> | string
    name?: StringNullableFilter<"Curriculum"> | string | null
    description?: StringNullableFilter<"Curriculum"> | string | null
    isDeleted?: BoolFilter<"Curriculum"> | boolean
    academicYears?: AcademicYearListRelationFilter
    grades?: GradeListRelationFilter
    users?: UserCurriculumMappingListRelationFilter
  }

  export type CurriculumOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    academicYears?: AcademicYearOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
    users?: UserCurriculumMappingOrderByRelationAggregateInput
  }

  export type CurriculumWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name?: string
    AND?: CurriculumWhereInput | CurriculumWhereInput[]
    OR?: CurriculumWhereInput[]
    NOT?: CurriculumWhereInput | CurriculumWhereInput[]
    createdAt?: DateTimeFilter<"Curriculum"> | Date | string
    image?: StringFilter<"Curriculum"> | string
    description?: StringNullableFilter<"Curriculum"> | string | null
    isDeleted?: BoolFilter<"Curriculum"> | boolean
    academicYears?: AcademicYearListRelationFilter
    grades?: GradeListRelationFilter
    users?: UserCurriculumMappingListRelationFilter
  }, "id" | "name">

  export type CurriculumOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    _count?: CurriculumCountOrderByAggregateInput
    _avg?: CurriculumAvgOrderByAggregateInput
    _max?: CurriculumMaxOrderByAggregateInput
    _min?: CurriculumMinOrderByAggregateInput
    _sum?: CurriculumSumOrderByAggregateInput
  }

  export type CurriculumScalarWhereWithAggregatesInput = {
    AND?: CurriculumScalarWhereWithAggregatesInput | CurriculumScalarWhereWithAggregatesInput[]
    OR?: CurriculumScalarWhereWithAggregatesInput[]
    NOT?: CurriculumScalarWhereWithAggregatesInput | CurriculumScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Curriculum"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Curriculum"> | Date | string
    image?: StringWithAggregatesFilter<"Curriculum"> | string
    name?: StringNullableWithAggregatesFilter<"Curriculum"> | string | null
    description?: StringNullableWithAggregatesFilter<"Curriculum"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Curriculum"> | boolean
  }

  export type AcademicYearWhereInput = {
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    id?: BigIntFilter<"AcademicYear"> | bigint | number
    name?: StringNullableFilter<"AcademicYear"> | string | null
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeNullableFilter<"AcademicYear"> | Date | string | null
    isActiveSession?: BoolNullableFilter<"AcademicYear"> | boolean | null
    isDeleted?: BoolNullableFilter<"AcademicYear"> | boolean | null
    curriculumId?: BigIntNullableFilter<"AcademicYear"> | bigint | number | null
    curriculum?: XOR<CurriculumNullableScalarRelationFilter, CurriculumWhereInput> | null
    users?: UserAcademicYearMappingListRelationFilter
  }

  export type AcademicYearOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    isActiveSession?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    curriculumId?: SortOrderInput | SortOrder
    curriculum?: CurriculumOrderByWithRelationInput
    users?: UserAcademicYearMappingOrderByRelationAggregateInput
  }

  export type AcademicYearWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    name?: StringNullableFilter<"AcademicYear"> | string | null
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeNullableFilter<"AcademicYear"> | Date | string | null
    isActiveSession?: BoolNullableFilter<"AcademicYear"> | boolean | null
    isDeleted?: BoolNullableFilter<"AcademicYear"> | boolean | null
    curriculumId?: BigIntNullableFilter<"AcademicYear"> | bigint | number | null
    curriculum?: XOR<CurriculumNullableScalarRelationFilter, CurriculumWhereInput> | null
    users?: UserAcademicYearMappingListRelationFilter
  }, "id">

  export type AcademicYearOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    isActiveSession?: SortOrderInput | SortOrder
    isDeleted?: SortOrderInput | SortOrder
    curriculumId?: SortOrderInput | SortOrder
    _count?: AcademicYearCountOrderByAggregateInput
    _avg?: AcademicYearAvgOrderByAggregateInput
    _max?: AcademicYearMaxOrderByAggregateInput
    _min?: AcademicYearMinOrderByAggregateInput
    _sum?: AcademicYearSumOrderByAggregateInput
  }

  export type AcademicYearScalarWhereWithAggregatesInput = {
    AND?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    OR?: AcademicYearScalarWhereWithAggregatesInput[]
    NOT?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"AcademicYear"> | bigint | number
    name?: StringNullableWithAggregatesFilter<"AcademicYear"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AcademicYear"> | Date | string | null
    isActiveSession?: BoolNullableWithAggregatesFilter<"AcademicYear"> | boolean | null
    isDeleted?: BoolNullableWithAggregatesFilter<"AcademicYear"> | boolean | null
    curriculumId?: BigIntNullableWithAggregatesFilter<"AcademicYear"> | bigint | number | null
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: BigIntFilter<"Location"> | bigint | number
    name?: StringFilter<"Location"> | string
    description?: StringNullableFilter<"Location"> | string | null
    isDeleted?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    sortOrder?: BigIntFilter<"Location"> | bigint | number
    profiles?: ProfileListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    sortOrder?: SortOrder
    profiles?: ProfileOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    description?: StringNullableFilter<"Location"> | string | null
    isDeleted?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    sortOrder?: BigIntFilter<"Location"> | bigint | number
    profiles?: ProfileListRelationFilter
  }, "id" | "name">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    sortOrder?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Location"> | bigint | number
    name?: StringWithAggregatesFilter<"Location"> | string
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    sortOrder?: BigIntWithAggregatesFilter<"Location"> | bigint | number
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: UuidFilter<"Profile"> | string
    fullName?: StringFilter<"Profile"> | string
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    gender?: StringFilter<"Profile"> | string
    dob?: DateTimeNullableFilter<"Profile"> | Date | string | null
    locationId?: BigIntNullableFilter<"Profile"> | bigint | number | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    userType?: StringFilter<"Profile"> | string
    phoneNumber?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    isDeleted?: BoolFilter<"Profile"> | boolean
    isDeactivated?: BoolFilter<"Profile"> | boolean
    deviceId?: StringFilter<"Profile"> | string
    fcmDeviceToken?: StringNullableFilter<"Profile"> | string | null
    isNotificationEnabled?: BoolFilter<"Profile"> | boolean
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    schools?: SchoolListRelationFilter
    userCurriculums?: UserCurriculumMappingListRelationFilter
    userGrades?: UserGradeMappingListRelationFilter
    userSubjects?: UserSubjectMappingListRelationFilter
    academicYears?: UserAcademicYearMappingListRelationFilter
    authUser?: XOR<AuthUserNullableScalarRelationFilter, AuthUserWhereInput> | null
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userType?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    isDeactivated?: SortOrder
    deviceId?: SortOrder
    fcmDeviceToken?: SortOrderInput | SortOrder
    isNotificationEnabled?: SortOrder
    location?: LocationOrderByWithRelationInput
    schools?: SchoolOrderByRelationAggregateInput
    userCurriculums?: UserCurriculumMappingOrderByRelationAggregateInput
    userGrades?: UserGradeMappingOrderByRelationAggregateInput
    userSubjects?: UserSubjectMappingOrderByRelationAggregateInput
    academicYears?: UserAcademicYearMappingOrderByRelationAggregateInput
    authUser?: AuthUserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    fullName?: StringFilter<"Profile"> | string
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    gender?: StringFilter<"Profile"> | string
    dob?: DateTimeNullableFilter<"Profile"> | Date | string | null
    locationId?: BigIntNullableFilter<"Profile"> | bigint | number | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    userType?: StringFilter<"Profile"> | string
    phoneNumber?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    isDeleted?: BoolFilter<"Profile"> | boolean
    isDeactivated?: BoolFilter<"Profile"> | boolean
    deviceId?: StringFilter<"Profile"> | string
    fcmDeviceToken?: StringNullableFilter<"Profile"> | string | null
    isNotificationEnabled?: BoolFilter<"Profile"> | boolean
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    schools?: SchoolListRelationFilter
    userCurriculums?: UserCurriculumMappingListRelationFilter
    userGrades?: UserGradeMappingListRelationFilter
    userSubjects?: UserSubjectMappingListRelationFilter
    academicYears?: UserAcademicYearMappingListRelationFilter
    authUser?: XOR<AuthUserNullableScalarRelationFilter, AuthUserWhereInput> | null
  }, "id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userType?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    isDeactivated?: SortOrder
    deviceId?: SortOrder
    fcmDeviceToken?: SortOrderInput | SortOrder
    isNotificationEnabled?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Profile"> | string
    fullName?: StringWithAggregatesFilter<"Profile"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    gender?: StringWithAggregatesFilter<"Profile"> | string
    dob?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    locationId?: BigIntNullableWithAggregatesFilter<"Profile"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    userType?: StringWithAggregatesFilter<"Profile"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    email?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Profile"> | boolean
    isDeactivated?: BoolWithAggregatesFilter<"Profile"> | boolean
    deviceId?: StringWithAggregatesFilter<"Profile"> | string
    fcmDeviceToken?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    isNotificationEnabled?: BoolWithAggregatesFilter<"Profile"> | boolean
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: BigIntFilter<"Grade"> | bigint | number
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    image?: StringNullableFilter<"Grade"> | string | null
    description?: StringNullableFilter<"Grade"> | string | null
    name?: StringNullableFilter<"Grade"> | string | null
    isDeleted?: BoolFilter<"Grade"> | boolean
    curriculumId?: BigIntNullableFilter<"Grade"> | bigint | number | null
    curriculum?: XOR<CurriculumNullableScalarRelationFilter, CurriculumWhereInput> | null
    subjects?: SubjectListRelationFilter
    academicYearMappings?: UserAcademicYearMappingListRelationFilter
    userGradeMappings?: UserGradeMappingListRelationFilter
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrderInput | SortOrder
    curriculum?: CurriculumOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
    academicYearMappings?: UserAcademicYearMappingOrderByRelationAggregateInput
    userGradeMappings?: UserGradeMappingOrderByRelationAggregateInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    image?: StringNullableFilter<"Grade"> | string | null
    description?: StringNullableFilter<"Grade"> | string | null
    name?: StringNullableFilter<"Grade"> | string | null
    isDeleted?: BoolFilter<"Grade"> | boolean
    curriculumId?: BigIntNullableFilter<"Grade"> | bigint | number | null
    curriculum?: XOR<CurriculumNullableScalarRelationFilter, CurriculumWhereInput> | null
    subjects?: SubjectListRelationFilter
    academicYearMappings?: UserAcademicYearMappingListRelationFilter
    userGradeMappings?: UserGradeMappingListRelationFilter
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrderInput | SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Grade"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
    image?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    description?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    name?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Grade"> | boolean
    curriculumId?: BigIntNullableWithAggregatesFilter<"Grade"> | bigint | number | null
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: BigIntFilter<"Subject"> | bigint | number
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    name?: StringNullableFilter<"Subject"> | string | null
    image?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    isDeleted?: BoolFilter<"Subject"> | boolean
    gradeId?: BigIntNullableFilter<"Subject"> | bigint | number | null
    grade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
    chapters?: ChapterListRelationFilter
    users?: UserSubjectMappingListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    gradeId?: SortOrderInput | SortOrder
    grade?: GradeOrderByWithRelationInput
    chapters?: ChapterOrderByRelationAggregateInput
    users?: UserSubjectMappingOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    name?: StringNullableFilter<"Subject"> | string | null
    image?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    isDeleted?: BoolFilter<"Subject"> | boolean
    gradeId?: BigIntNullableFilter<"Subject"> | bigint | number | null
    grade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
    chapters?: ChapterListRelationFilter
    users?: UserSubjectMappingListRelationFilter
  }, "id">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    gradeId?: SortOrderInput | SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Subject"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    name?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    image?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    description?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Subject"> | boolean
    gradeId?: BigIntNullableWithAggregatesFilter<"Subject"> | bigint | number | null
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: BigIntFilter<"Chapter"> | bigint | number
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    title?: StringFilter<"Chapter"> | string
    sortOrder?: DecimalFilter<"Chapter"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"Chapter"> | string | null
    isDeleted?: BoolFilter<"Chapter"> | boolean
    subjectId?: BigIntNullableFilter<"Chapter"> | bigint | number | null
    label?: StringNullableFilter<"Chapter"> | string | null
    updatedAt?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    content?: StringNullableFilter<"Chapter"> | string | null
    teacherGuide?: StringNullableFilter<"Chapter"> | string | null
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    sortOrder?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    teacherGuide?: SortOrderInput | SortOrder
    subject?: SubjectOrderByWithRelationInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    title?: StringFilter<"Chapter"> | string
    sortOrder?: DecimalFilter<"Chapter"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"Chapter"> | string | null
    isDeleted?: BoolFilter<"Chapter"> | boolean
    subjectId?: BigIntNullableFilter<"Chapter"> | bigint | number | null
    label?: StringNullableFilter<"Chapter"> | string | null
    updatedAt?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    content?: StringNullableFilter<"Chapter"> | string | null
    teacherGuide?: StringNullableFilter<"Chapter"> | string | null
    subject?: XOR<SubjectNullableScalarRelationFilter, SubjectWhereInput> | null
  }, "id">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    sortOrder?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    teacherGuide?: SortOrderInput | SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Chapter"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    title?: StringWithAggregatesFilter<"Chapter"> | string
    sortOrder?: DecimalWithAggregatesFilter<"Chapter"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Chapter"> | boolean
    subjectId?: BigIntNullableWithAggregatesFilter<"Chapter"> | bigint | number | null
    label?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Chapter"> | Date | string | null
    content?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    teacherGuide?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: BigIntFilter<"School"> | bigint | number
    schoolName?: StringFilter<"School"> | string
    userId?: UuidFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeNullableFilter<"School"> | Date | string | null
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    schoolName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    user?: ProfileOrderByWithRelationInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    schoolName?: StringFilter<"School"> | string
    userId?: UuidFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeNullableFilter<"School"> | Date | string | null
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    schoolName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"School"> | bigint | number
    schoolName?: StringWithAggregatesFilter<"School"> | string
    userId?: UuidWithAggregatesFilter<"School"> | string
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"School"> | Date | string | null
  }

  export type UserAcademicYearMappingWhereInput = {
    AND?: UserAcademicYearMappingWhereInput | UserAcademicYearMappingWhereInput[]
    OR?: UserAcademicYearMappingWhereInput[]
    NOT?: UserAcademicYearMappingWhereInput | UserAcademicYearMappingWhereInput[]
    id?: BigIntFilter<"UserAcademicYearMapping"> | bigint | number
    userId?: UuidFilter<"UserAcademicYearMapping"> | string
    studentGradeId?: BigIntNullableFilter<"UserAcademicYearMapping"> | bigint | number | null
    academicYearId?: BigIntNullableFilter<"UserAcademicYearMapping"> | bigint | number | null
    createdAt?: DateTimeFilter<"UserAcademicYearMapping"> | Date | string
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    studentGrade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }

  export type UserAcademicYearMappingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentGradeId?: SortOrderInput | SortOrder
    academicYearId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: ProfileOrderByWithRelationInput
    studentGrade?: GradeOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
  }

  export type UserAcademicYearMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UserAcademicYearMappingWhereInput | UserAcademicYearMappingWhereInput[]
    OR?: UserAcademicYearMappingWhereInput[]
    NOT?: UserAcademicYearMappingWhereInput | UserAcademicYearMappingWhereInput[]
    userId?: UuidFilter<"UserAcademicYearMapping"> | string
    studentGradeId?: BigIntNullableFilter<"UserAcademicYearMapping"> | bigint | number | null
    academicYearId?: BigIntNullableFilter<"UserAcademicYearMapping"> | bigint | number | null
    createdAt?: DateTimeFilter<"UserAcademicYearMapping"> | Date | string
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    studentGrade?: XOR<GradeNullableScalarRelationFilter, GradeWhereInput> | null
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
  }, "id">

  export type UserAcademicYearMappingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentGradeId?: SortOrderInput | SortOrder
    academicYearId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserAcademicYearMappingCountOrderByAggregateInput
    _avg?: UserAcademicYearMappingAvgOrderByAggregateInput
    _max?: UserAcademicYearMappingMaxOrderByAggregateInput
    _min?: UserAcademicYearMappingMinOrderByAggregateInput
    _sum?: UserAcademicYearMappingSumOrderByAggregateInput
  }

  export type UserAcademicYearMappingScalarWhereWithAggregatesInput = {
    AND?: UserAcademicYearMappingScalarWhereWithAggregatesInput | UserAcademicYearMappingScalarWhereWithAggregatesInput[]
    OR?: UserAcademicYearMappingScalarWhereWithAggregatesInput[]
    NOT?: UserAcademicYearMappingScalarWhereWithAggregatesInput | UserAcademicYearMappingScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserAcademicYearMapping"> | bigint | number
    userId?: UuidWithAggregatesFilter<"UserAcademicYearMapping"> | string
    studentGradeId?: BigIntNullableWithAggregatesFilter<"UserAcademicYearMapping"> | bigint | number | null
    academicYearId?: BigIntNullableWithAggregatesFilter<"UserAcademicYearMapping"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAcademicYearMapping"> | Date | string
  }

  export type UserCurriculumMappingWhereInput = {
    AND?: UserCurriculumMappingWhereInput | UserCurriculumMappingWhereInput[]
    OR?: UserCurriculumMappingWhereInput[]
    NOT?: UserCurriculumMappingWhereInput | UserCurriculumMappingWhereInput[]
    userId?: UuidFilter<"UserCurriculumMapping"> | string
    curriculumId?: BigIntFilter<"UserCurriculumMapping"> | bigint | number
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    curriculum?: XOR<CurriculumScalarRelationFilter, CurriculumWhereInput>
  }

  export type UserCurriculumMappingOrderByWithRelationInput = {
    userId?: SortOrder
    curriculumId?: SortOrder
    user?: ProfileOrderByWithRelationInput
    curriculum?: CurriculumOrderByWithRelationInput
  }

  export type UserCurriculumMappingWhereUniqueInput = Prisma.AtLeast<{
    userId_curriculumId?: UserCurriculumMappingUserIdCurriculumIdCompoundUniqueInput
    AND?: UserCurriculumMappingWhereInput | UserCurriculumMappingWhereInput[]
    OR?: UserCurriculumMappingWhereInput[]
    NOT?: UserCurriculumMappingWhereInput | UserCurriculumMappingWhereInput[]
    userId?: UuidFilter<"UserCurriculumMapping"> | string
    curriculumId?: BigIntFilter<"UserCurriculumMapping"> | bigint | number
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    curriculum?: XOR<CurriculumScalarRelationFilter, CurriculumWhereInput>
  }, "userId_curriculumId">

  export type UserCurriculumMappingOrderByWithAggregationInput = {
    userId?: SortOrder
    curriculumId?: SortOrder
    _count?: UserCurriculumMappingCountOrderByAggregateInput
    _avg?: UserCurriculumMappingAvgOrderByAggregateInput
    _max?: UserCurriculumMappingMaxOrderByAggregateInput
    _min?: UserCurriculumMappingMinOrderByAggregateInput
    _sum?: UserCurriculumMappingSumOrderByAggregateInput
  }

  export type UserCurriculumMappingScalarWhereWithAggregatesInput = {
    AND?: UserCurriculumMappingScalarWhereWithAggregatesInput | UserCurriculumMappingScalarWhereWithAggregatesInput[]
    OR?: UserCurriculumMappingScalarWhereWithAggregatesInput[]
    NOT?: UserCurriculumMappingScalarWhereWithAggregatesInput | UserCurriculumMappingScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserCurriculumMapping"> | string
    curriculumId?: BigIntWithAggregatesFilter<"UserCurriculumMapping"> | bigint | number
  }

  export type UserGradeMappingWhereInput = {
    AND?: UserGradeMappingWhereInput | UserGradeMappingWhereInput[]
    OR?: UserGradeMappingWhereInput[]
    NOT?: UserGradeMappingWhereInput | UserGradeMappingWhereInput[]
    userId?: UuidFilter<"UserGradeMapping"> | string
    gradeId?: BigIntFilter<"UserGradeMapping"> | bigint | number
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
  }

  export type UserGradeMappingOrderByWithRelationInput = {
    userId?: SortOrder
    gradeId?: SortOrder
    user?: ProfileOrderByWithRelationInput
    grade?: GradeOrderByWithRelationInput
  }

  export type UserGradeMappingWhereUniqueInput = Prisma.AtLeast<{
    userId_gradeId?: UserGradeMappingUserIdGradeIdCompoundUniqueInput
    AND?: UserGradeMappingWhereInput | UserGradeMappingWhereInput[]
    OR?: UserGradeMappingWhereInput[]
    NOT?: UserGradeMappingWhereInput | UserGradeMappingWhereInput[]
    userId?: UuidFilter<"UserGradeMapping"> | string
    gradeId?: BigIntFilter<"UserGradeMapping"> | bigint | number
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    grade?: XOR<GradeScalarRelationFilter, GradeWhereInput>
  }, "userId_gradeId">

  export type UserGradeMappingOrderByWithAggregationInput = {
    userId?: SortOrder
    gradeId?: SortOrder
    _count?: UserGradeMappingCountOrderByAggregateInput
    _avg?: UserGradeMappingAvgOrderByAggregateInput
    _max?: UserGradeMappingMaxOrderByAggregateInput
    _min?: UserGradeMappingMinOrderByAggregateInput
    _sum?: UserGradeMappingSumOrderByAggregateInput
  }

  export type UserGradeMappingScalarWhereWithAggregatesInput = {
    AND?: UserGradeMappingScalarWhereWithAggregatesInput | UserGradeMappingScalarWhereWithAggregatesInput[]
    OR?: UserGradeMappingScalarWhereWithAggregatesInput[]
    NOT?: UserGradeMappingScalarWhereWithAggregatesInput | UserGradeMappingScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserGradeMapping"> | string
    gradeId?: BigIntWithAggregatesFilter<"UserGradeMapping"> | bigint | number
  }

  export type UserSubjectMappingWhereInput = {
    AND?: UserSubjectMappingWhereInput | UserSubjectMappingWhereInput[]
    OR?: UserSubjectMappingWhereInput[]
    NOT?: UserSubjectMappingWhereInput | UserSubjectMappingWhereInput[]
    userId?: UuidFilter<"UserSubjectMapping"> | string
    subjectId?: BigIntFilter<"UserSubjectMapping"> | bigint | number
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type UserSubjectMappingOrderByWithRelationInput = {
    userId?: SortOrder
    subjectId?: SortOrder
    user?: ProfileOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type UserSubjectMappingWhereUniqueInput = Prisma.AtLeast<{
    userId_subjectId?: UserSubjectMappingUserIdSubjectIdCompoundUniqueInput
    AND?: UserSubjectMappingWhereInput | UserSubjectMappingWhereInput[]
    OR?: UserSubjectMappingWhereInput[]
    NOT?: UserSubjectMappingWhereInput | UserSubjectMappingWhereInput[]
    userId?: UuidFilter<"UserSubjectMapping"> | string
    subjectId?: BigIntFilter<"UserSubjectMapping"> | bigint | number
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "userId_subjectId">

  export type UserSubjectMappingOrderByWithAggregationInput = {
    userId?: SortOrder
    subjectId?: SortOrder
    _count?: UserSubjectMappingCountOrderByAggregateInput
    _avg?: UserSubjectMappingAvgOrderByAggregateInput
    _max?: UserSubjectMappingMaxOrderByAggregateInput
    _min?: UserSubjectMappingMinOrderByAggregateInput
    _sum?: UserSubjectMappingSumOrderByAggregateInput
  }

  export type UserSubjectMappingScalarWhereWithAggregatesInput = {
    AND?: UserSubjectMappingScalarWhereWithAggregatesInput | UserSubjectMappingScalarWhereWithAggregatesInput[]
    OR?: UserSubjectMappingScalarWhereWithAggregatesInput[]
    NOT?: UserSubjectMappingScalarWhereWithAggregatesInput | UserSubjectMappingScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserSubjectMapping"> | string
    subjectId?: BigIntWithAggregatesFilter<"UserSubjectMapping"> | bigint | number
  }

  export type AuthUserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutAuthInput
    identities?: IdentityCreateNestedManyWithoutAuthInput
    profile?: ProfileCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutAuthInput
    identities?: IdentityUncheckedCreateNestedManyWithoutAuthInput
  }

  export type AuthUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutAuthNestedInput
    identities?: IdentityUpdateManyWithoutAuthNestedInput
    profile?: ProfileUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutAuthNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutAuthNestedInput
  }

  export type AuthUserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
  }

  export type AuthUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    auth: AuthUserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    authId: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    authId: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityCreateInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerId: string
    createdAt?: Date | string
    auth: AuthUserCreateNestedOneWithoutIdentitiesInput
  }

  export type IdentityUncheckedCreateInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerId: string
    authId: string
    createdAt?: Date | string
  }

  export type IdentityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUserUpdateOneRequiredWithoutIdentitiesNestedInput
  }

  export type IdentityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityCreateManyInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerId: string
    authId: string
    createdAt?: Date | string
  }

  export type IdentityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    authId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurriculumCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    academicYears?: AcademicYearCreateNestedManyWithoutCurriculumInput
    grades?: GradeCreateNestedManyWithoutCurriculumInput
    users?: UserCurriculumMappingCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumUncheckedCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    academicYears?: AcademicYearUncheckedCreateNestedManyWithoutCurriculumInput
    grades?: GradeUncheckedCreateNestedManyWithoutCurriculumInput
    users?: UserCurriculumMappingUncheckedCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    academicYears?: AcademicYearUpdateManyWithoutCurriculumNestedInput
    grades?: GradeUpdateManyWithoutCurriculumNestedInput
    users?: UserCurriculumMappingUpdateManyWithoutCurriculumNestedInput
  }

  export type CurriculumUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    academicYears?: AcademicYearUncheckedUpdateManyWithoutCurriculumNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCurriculumNestedInput
    users?: UserCurriculumMappingUncheckedUpdateManyWithoutCurriculumNestedInput
  }

  export type CurriculumCreateManyInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
  }

  export type CurriculumUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CurriculumUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AcademicYearCreateInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
    curriculum?: CurriculumCreateNestedOneWithoutAcademicYearsInput
    users?: UserAcademicYearMappingCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
    curriculumId?: bigint | number | null
    users?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    curriculum?: CurriculumUpdateOneWithoutAcademicYearsNestedInput
    users?: UserAcademicYearMappingUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    users?: UserAcademicYearMappingUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearCreateManyInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
    curriculumId?: bigint | number | null
  }

  export type AcademicYearUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AcademicYearUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type LocationCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    sortOrder?: bigint | number
    profiles?: ProfileCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    sortOrder?: bigint | number
    profiles?: ProfileUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: BigIntFieldUpdateOperationsInput | bigint | number
    profiles?: ProfileUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: BigIntFieldUpdateOperationsInput | bigint | number
    profiles?: ProfileUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: bigint | number
    name: string
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    sortOrder?: bigint | number
  }

  export type LocationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProfileCreateInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    location?: LocationCreateNestedOneWithoutProfilesInput
    schools?: SchoolCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingCreateNestedManyWithoutUserInput
    authUser?: AuthUserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolUncheckedCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingUncheckedCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput
    authUser?: AuthUserUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutProfilesNestedInput
    schools?: SchoolUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUncheckedUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GradeCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculum?: CurriculumCreateNestedOneWithoutGradesInput
    subjects?: SubjectCreateNestedManyWithoutGradeInput
    academicYearMappings?: UserAcademicYearMappingCreateNestedManyWithoutStudentGradeInput
    userGradeMappings?: UserGradeMappingCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculumId?: bigint | number | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradeInput
    academicYearMappings?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutStudentGradeInput
    userGradeMappings?: UserGradeMappingUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculum?: CurriculumUpdateOneWithoutGradesNestedInput
    subjects?: SubjectUpdateManyWithoutGradeNestedInput
    academicYearMappings?: UserAcademicYearMappingUpdateManyWithoutStudentGradeNestedInput
    userGradeMappings?: UserGradeMappingUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subjects?: SubjectUncheckedUpdateManyWithoutGradeNestedInput
    academicYearMappings?: UserAcademicYearMappingUncheckedUpdateManyWithoutStudentGradeNestedInput
    userGradeMappings?: UserGradeMappingUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeCreateManyInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculumId?: bigint | number | null
  }

  export type GradeUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type SubjectCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    grade?: GradeCreateNestedOneWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    users?: UserSubjectMappingCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    gradeId?: bigint | number | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    users?: UserSubjectMappingUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    grade?: GradeUpdateOneWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    users?: UserSubjectMappingUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    gradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    users?: UserSubjectMappingUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    gradeId?: bigint | number | null
  }

  export type SubjectUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    gradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ChapterCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    title: string
    sortOrder: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    isDeleted?: boolean
    label?: string | null
    updatedAt?: Date | string | null
    content?: string | null
    teacherGuide?: string | null
    subject?: SubjectCreateNestedOneWithoutChaptersInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    title: string
    sortOrder: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    isDeleted?: boolean
    subjectId?: bigint | number | null
    label?: string | null
    updatedAt?: Date | string | null
    content?: string | null
    teacherGuide?: string | null
  }

  export type ChapterUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    sortOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    label?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    teacherGuide?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: SubjectUpdateOneWithoutChaptersNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    sortOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    teacherGuide?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChapterCreateManyInput = {
    id?: bigint | number
    createdAt?: Date | string
    title: string
    sortOrder: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    isDeleted?: boolean
    subjectId?: bigint | number | null
    label?: string | null
    updatedAt?: Date | string | null
    content?: string | null
    teacherGuide?: string | null
  }

  export type ChapterUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    sortOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    label?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    teacherGuide?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    sortOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    subjectId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    teacherGuide?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolCreateInput = {
    id?: bigint | number
    schoolName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user: ProfileCreateNestedOneWithoutSchoolsInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: bigint | number
    schoolName: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SchoolUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    schoolName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: ProfileUpdateOneRequiredWithoutSchoolsNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    schoolName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SchoolCreateManyInput = {
    id?: bigint | number
    schoolName: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SchoolUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    schoolName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    schoolName?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAcademicYearMappingCreateInput = {
    id?: bigint | number
    createdAt?: Date | string
    user: ProfileCreateNestedOneWithoutAcademicYearsInput
    studentGrade?: GradeCreateNestedOneWithoutAcademicYearMappingsInput
    academicYear?: AcademicYearCreateNestedOneWithoutUsersInput
  }

  export type UserAcademicYearMappingUncheckedCreateInput = {
    id?: bigint | number
    userId: string
    studentGradeId?: bigint | number | null
    academicYearId?: bigint | number | null
    createdAt?: Date | string
  }

  export type UserAcademicYearMappingUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutAcademicYearsNestedInput
    studentGrade?: GradeUpdateOneWithoutAcademicYearMappingsNestedInput
    academicYear?: AcademicYearUpdateOneWithoutUsersNestedInput
  }

  export type UserAcademicYearMappingUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    studentGradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    academicYearId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademicYearMappingCreateManyInput = {
    id?: bigint | number
    userId: string
    studentGradeId?: bigint | number | null
    academicYearId?: bigint | number | null
    createdAt?: Date | string
  }

  export type UserAcademicYearMappingUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademicYearMappingUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    studentGradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    academicYearId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCurriculumMappingCreateInput = {
    user: ProfileCreateNestedOneWithoutUserCurriculumsInput
    curriculum: CurriculumCreateNestedOneWithoutUsersInput
  }

  export type UserCurriculumMappingUncheckedCreateInput = {
    userId: string
    curriculumId: bigint | number
  }

  export type UserCurriculumMappingUpdateInput = {
    user?: ProfileUpdateOneRequiredWithoutUserCurriculumsNestedInput
    curriculum?: CurriculumUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserCurriculumMappingUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    curriculumId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserCurriculumMappingCreateManyInput = {
    userId: string
    curriculumId: bigint | number
  }

  export type UserCurriculumMappingUpdateManyMutationInput = {

  }

  export type UserCurriculumMappingUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    curriculumId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserGradeMappingCreateInput = {
    user: ProfileCreateNestedOneWithoutUserGradesInput
    grade: GradeCreateNestedOneWithoutUserGradeMappingsInput
  }

  export type UserGradeMappingUncheckedCreateInput = {
    userId: string
    gradeId: bigint | number
  }

  export type UserGradeMappingUpdateInput = {
    user?: ProfileUpdateOneRequiredWithoutUserGradesNestedInput
    grade?: GradeUpdateOneRequiredWithoutUserGradeMappingsNestedInput
  }

  export type UserGradeMappingUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    gradeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserGradeMappingCreateManyInput = {
    userId: string
    gradeId: bigint | number
  }

  export type UserGradeMappingUpdateManyMutationInput = {

  }

  export type UserGradeMappingUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    gradeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSubjectMappingCreateInput = {
    user: ProfileCreateNestedOneWithoutUserSubjectsInput
    subject: SubjectCreateNestedOneWithoutUsersInput
  }

  export type UserSubjectMappingUncheckedCreateInput = {
    userId: string
    subjectId: bigint | number
  }

  export type UserSubjectMappingUpdateInput = {
    user?: ProfileUpdateOneRequiredWithoutUserSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSubjectMappingUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subjectId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSubjectMappingCreateManyInput = {
    userId: string
    subjectId: bigint | number
  }

  export type UserSubjectMappingUpdateManyMutationInput = {

  }

  export type UserSubjectMappingUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    subjectId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type IdentityListRelationFilter = {
    every?: IdentityWhereInput
    some?: IdentityWhereInput
    none?: IdentityWhereInput
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdentityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type AuthUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type AuthUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    emailVerifiedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AuthUserScalarRelationFilter = {
    is?: AuthUserWhereInput
    isNot?: AuthUserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    authId?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type IdentityProviderProviderIdCompoundUniqueInput = {
    provider: $Enums.AuthProvider
    providerId: string
  }

  export type IdentityCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    authId?: SortOrder
    createdAt?: SortOrder
  }

  export type IdentityMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    authId?: SortOrder
    createdAt?: SortOrder
  }

  export type IdentityMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    authId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type AcademicYearListRelationFilter = {
    every?: AcademicYearWhereInput
    some?: AcademicYearWhereInput
    none?: AcademicYearWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type UserCurriculumMappingListRelationFilter = {
    every?: UserCurriculumMappingWhereInput
    some?: UserCurriculumMappingWhereInput
    none?: UserCurriculumMappingWhereInput
  }

  export type AcademicYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCurriculumMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurriculumCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
  }

  export type CurriculumAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurriculumMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
  }

  export type CurriculumMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
  }

  export type CurriculumSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type CurriculumNullableScalarRelationFilter = {
    is?: CurriculumWhereInput | null
    isNot?: CurriculumWhereInput | null
  }

  export type UserAcademicYearMappingListRelationFilter = {
    every?: UserAcademicYearMappingWhereInput
    some?: UserAcademicYearMappingWhereInput
    none?: UserAcademicYearMappingWhereInput
  }

  export type UserAcademicYearMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicYearCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActiveSession?: SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrder
  }

  export type AcademicYearAvgOrderByAggregateInput = {
    id?: SortOrder
    curriculumId?: SortOrder
  }

  export type AcademicYearMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActiveSession?: SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrder
  }

  export type AcademicYearMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActiveSession?: SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrder
  }

  export type AcademicYearSumOrderByAggregateInput = {
    id?: SortOrder
    curriculumId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    sortOrder?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    sortOrder?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    sortOrder?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type SchoolListRelationFilter = {
    every?: SchoolWhereInput
    some?: SchoolWhereInput
    none?: SchoolWhereInput
  }

  export type UserGradeMappingListRelationFilter = {
    every?: UserGradeMappingWhereInput
    some?: UserGradeMappingWhereInput
    none?: UserGradeMappingWhereInput
  }

  export type UserSubjectMappingListRelationFilter = {
    every?: UserSubjectMappingWhereInput
    some?: UserSubjectMappingWhereInput
    none?: UserSubjectMappingWhereInput
  }

  export type AuthUserNullableScalarRelationFilter = {
    is?: AuthUserWhereInput | null
    isNot?: AuthUserWhereInput | null
  }

  export type SchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserGradeMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSubjectMappingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userType?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    isDeactivated?: SortOrder
    deviceId?: SortOrder
    fcmDeviceToken?: SortOrder
    isNotificationEnabled?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    locationId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userType?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    isDeactivated?: SortOrder
    deviceId?: SortOrder
    fcmDeviceToken?: SortOrder
    isNotificationEnabled?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    avatarUrl?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userType?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    isDeleted?: SortOrder
    isDeactivated?: SortOrder
    deviceId?: SortOrder
    fcmDeviceToken?: SortOrder
    isNotificationEnabled?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    locationId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    description?: SortOrder
    name?: SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    id?: SortOrder
    curriculumId?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    description?: SortOrder
    name?: SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    image?: SortOrder
    description?: SortOrder
    name?: SortOrder
    isDeleted?: SortOrder
    curriculumId?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    id?: SortOrder
    curriculumId?: SortOrder
  }

  export type GradeNullableScalarRelationFilter = {
    is?: GradeWhereInput | null
    isNot?: GradeWhereInput | null
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    gradeId?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    gradeId?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    gradeId?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    id?: SortOrder
    gradeId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type SubjectNullableScalarRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    sortOrder?: SortOrder
    imageUrl?: SortOrder
    isDeleted?: SortOrder
    subjectId?: SortOrder
    label?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    teacherGuide?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
    subjectId?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    sortOrder?: SortOrder
    imageUrl?: SortOrder
    isDeleted?: SortOrder
    subjectId?: SortOrder
    label?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    teacherGuide?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    title?: SortOrder
    sortOrder?: SortOrder
    imageUrl?: SortOrder
    isDeleted?: SortOrder
    subjectId?: SortOrder
    label?: SortOrder
    updatedAt?: SortOrder
    content?: SortOrder
    teacherGuide?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
    subjectId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    schoolName?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AcademicYearNullableScalarRelationFilter = {
    is?: AcademicYearWhereInput | null
    isNot?: AcademicYearWhereInput | null
  }

  export type UserAcademicYearMappingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentGradeId?: SortOrder
    academicYearId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAcademicYearMappingAvgOrderByAggregateInput = {
    id?: SortOrder
    studentGradeId?: SortOrder
    academicYearId?: SortOrder
  }

  export type UserAcademicYearMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentGradeId?: SortOrder
    academicYearId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAcademicYearMappingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentGradeId?: SortOrder
    academicYearId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAcademicYearMappingSumOrderByAggregateInput = {
    id?: SortOrder
    studentGradeId?: SortOrder
    academicYearId?: SortOrder
  }

  export type CurriculumScalarRelationFilter = {
    is?: CurriculumWhereInput
    isNot?: CurriculumWhereInput
  }

  export type UserCurriculumMappingUserIdCurriculumIdCompoundUniqueInput = {
    userId: string
    curriculumId: bigint | number
  }

  export type UserCurriculumMappingCountOrderByAggregateInput = {
    userId?: SortOrder
    curriculumId?: SortOrder
  }

  export type UserCurriculumMappingAvgOrderByAggregateInput = {
    curriculumId?: SortOrder
  }

  export type UserCurriculumMappingMaxOrderByAggregateInput = {
    userId?: SortOrder
    curriculumId?: SortOrder
  }

  export type UserCurriculumMappingMinOrderByAggregateInput = {
    userId?: SortOrder
    curriculumId?: SortOrder
  }

  export type UserCurriculumMappingSumOrderByAggregateInput = {
    curriculumId?: SortOrder
  }

  export type GradeScalarRelationFilter = {
    is?: GradeWhereInput
    isNot?: GradeWhereInput
  }

  export type UserGradeMappingUserIdGradeIdCompoundUniqueInput = {
    userId: string
    gradeId: bigint | number
  }

  export type UserGradeMappingCountOrderByAggregateInput = {
    userId?: SortOrder
    gradeId?: SortOrder
  }

  export type UserGradeMappingAvgOrderByAggregateInput = {
    gradeId?: SortOrder
  }

  export type UserGradeMappingMaxOrderByAggregateInput = {
    userId?: SortOrder
    gradeId?: SortOrder
  }

  export type UserGradeMappingMinOrderByAggregateInput = {
    userId?: SortOrder
    gradeId?: SortOrder
  }

  export type UserGradeMappingSumOrderByAggregateInput = {
    gradeId?: SortOrder
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type UserSubjectMappingUserIdSubjectIdCompoundUniqueInput = {
    userId: string
    subjectId: bigint | number
  }

  export type UserSubjectMappingCountOrderByAggregateInput = {
    userId?: SortOrder
    subjectId?: SortOrder
  }

  export type UserSubjectMappingAvgOrderByAggregateInput = {
    subjectId?: SortOrder
  }

  export type UserSubjectMappingMaxOrderByAggregateInput = {
    userId?: SortOrder
    subjectId?: SortOrder
  }

  export type UserSubjectMappingMinOrderByAggregateInput = {
    userId?: SortOrder
    subjectId?: SortOrder
  }

  export type UserSubjectMappingSumOrderByAggregateInput = {
    subjectId?: SortOrder
  }

  export type SessionCreateNestedManyWithoutAuthInput = {
    create?: XOR<SessionCreateWithoutAuthInput, SessionUncheckedCreateWithoutAuthInput> | SessionCreateWithoutAuthInput[] | SessionUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAuthInput | SessionCreateOrConnectWithoutAuthInput[]
    createMany?: SessionCreateManyAuthInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type IdentityCreateNestedManyWithoutAuthInput = {
    create?: XOR<IdentityCreateWithoutAuthInput, IdentityUncheckedCreateWithoutAuthInput> | IdentityCreateWithoutAuthInput[] | IdentityUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutAuthInput | IdentityCreateOrConnectWithoutAuthInput[]
    createMany?: IdentityCreateManyAuthInputEnvelope
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutAuthUserInput = {
    create?: XOR<ProfileCreateWithoutAuthUserInput, ProfileUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAuthUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutAuthInput = {
    create?: XOR<SessionCreateWithoutAuthInput, SessionUncheckedCreateWithoutAuthInput> | SessionCreateWithoutAuthInput[] | SessionUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAuthInput | SessionCreateOrConnectWithoutAuthInput[]
    createMany?: SessionCreateManyAuthInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type IdentityUncheckedCreateNestedManyWithoutAuthInput = {
    create?: XOR<IdentityCreateWithoutAuthInput, IdentityUncheckedCreateWithoutAuthInput> | IdentityCreateWithoutAuthInput[] | IdentityUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutAuthInput | IdentityCreateOrConnectWithoutAuthInput[]
    createMany?: IdentityCreateManyAuthInputEnvelope
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutAuthNestedInput = {
    create?: XOR<SessionCreateWithoutAuthInput, SessionUncheckedCreateWithoutAuthInput> | SessionCreateWithoutAuthInput[] | SessionUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAuthInput | SessionCreateOrConnectWithoutAuthInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutAuthInput | SessionUpsertWithWhereUniqueWithoutAuthInput[]
    createMany?: SessionCreateManyAuthInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutAuthInput | SessionUpdateWithWhereUniqueWithoutAuthInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutAuthInput | SessionUpdateManyWithWhereWithoutAuthInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type IdentityUpdateManyWithoutAuthNestedInput = {
    create?: XOR<IdentityCreateWithoutAuthInput, IdentityUncheckedCreateWithoutAuthInput> | IdentityCreateWithoutAuthInput[] | IdentityUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutAuthInput | IdentityCreateOrConnectWithoutAuthInput[]
    upsert?: IdentityUpsertWithWhereUniqueWithoutAuthInput | IdentityUpsertWithWhereUniqueWithoutAuthInput[]
    createMany?: IdentityCreateManyAuthInputEnvelope
    set?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    disconnect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    delete?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    update?: IdentityUpdateWithWhereUniqueWithoutAuthInput | IdentityUpdateWithWhereUniqueWithoutAuthInput[]
    updateMany?: IdentityUpdateManyWithWhereWithoutAuthInput | IdentityUpdateManyWithWhereWithoutAuthInput[]
    deleteMany?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
  }

  export type ProfileUpdateOneWithoutAuthUserNestedInput = {
    create?: XOR<ProfileCreateWithoutAuthUserInput, ProfileUncheckedCreateWithoutAuthUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAuthUserInput
    upsert?: ProfileUpsertWithoutAuthUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutAuthUserInput, ProfileUpdateWithoutAuthUserInput>, ProfileUncheckedUpdateWithoutAuthUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutAuthNestedInput = {
    create?: XOR<SessionCreateWithoutAuthInput, SessionUncheckedCreateWithoutAuthInput> | SessionCreateWithoutAuthInput[] | SessionUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutAuthInput | SessionCreateOrConnectWithoutAuthInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutAuthInput | SessionUpsertWithWhereUniqueWithoutAuthInput[]
    createMany?: SessionCreateManyAuthInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutAuthInput | SessionUpdateWithWhereUniqueWithoutAuthInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutAuthInput | SessionUpdateManyWithWhereWithoutAuthInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type IdentityUncheckedUpdateManyWithoutAuthNestedInput = {
    create?: XOR<IdentityCreateWithoutAuthInput, IdentityUncheckedCreateWithoutAuthInput> | IdentityCreateWithoutAuthInput[] | IdentityUncheckedCreateWithoutAuthInput[]
    connectOrCreate?: IdentityCreateOrConnectWithoutAuthInput | IdentityCreateOrConnectWithoutAuthInput[]
    upsert?: IdentityUpsertWithWhereUniqueWithoutAuthInput | IdentityUpsertWithWhereUniqueWithoutAuthInput[]
    createMany?: IdentityCreateManyAuthInputEnvelope
    set?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    disconnect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    delete?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    connect?: IdentityWhereUniqueInput | IdentityWhereUniqueInput[]
    update?: IdentityUpdateWithWhereUniqueWithoutAuthInput | IdentityUpdateWithWhereUniqueWithoutAuthInput[]
    updateMany?: IdentityUpdateManyWithWhereWithoutAuthInput | IdentityUpdateManyWithWhereWithoutAuthInput[]
    deleteMany?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
  }

  export type AuthUserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AuthUserCreateWithoutSessionsInput, AuthUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutSessionsInput
    connect?: AuthUserWhereUniqueInput
  }

  export type AuthUserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AuthUserCreateWithoutSessionsInput, AuthUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutSessionsInput
    upsert?: AuthUserUpsertWithoutSessionsInput
    connect?: AuthUserWhereUniqueInput
    update?: XOR<XOR<AuthUserUpdateToOneWithWhereWithoutSessionsInput, AuthUserUpdateWithoutSessionsInput>, AuthUserUncheckedUpdateWithoutSessionsInput>
  }

  export type AuthUserCreateNestedOneWithoutIdentitiesInput = {
    create?: XOR<AuthUserCreateWithoutIdentitiesInput, AuthUserUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutIdentitiesInput
    connect?: AuthUserWhereUniqueInput
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type AuthUserUpdateOneRequiredWithoutIdentitiesNestedInput = {
    create?: XOR<AuthUserCreateWithoutIdentitiesInput, AuthUserUncheckedCreateWithoutIdentitiesInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutIdentitiesInput
    upsert?: AuthUserUpsertWithoutIdentitiesInput
    connect?: AuthUserWhereUniqueInput
    update?: XOR<XOR<AuthUserUpdateToOneWithWhereWithoutIdentitiesInput, AuthUserUpdateWithoutIdentitiesInput>, AuthUserUncheckedUpdateWithoutIdentitiesInput>
  }

  export type AcademicYearCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<AcademicYearCreateWithoutCurriculumInput, AcademicYearUncheckedCreateWithoutCurriculumInput> | AcademicYearCreateWithoutCurriculumInput[] | AcademicYearUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutCurriculumInput | AcademicYearCreateOrConnectWithoutCurriculumInput[]
    createMany?: AcademicYearCreateManyCurriculumInputEnvelope
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<GradeCreateWithoutCurriculumInput, GradeUncheckedCreateWithoutCurriculumInput> | GradeCreateWithoutCurriculumInput[] | GradeUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCurriculumInput | GradeCreateOrConnectWithoutCurriculumInput[]
    createMany?: GradeCreateManyCurriculumInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type UserCurriculumMappingCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutCurriculumInput, UserCurriculumMappingUncheckedCreateWithoutCurriculumInput> | UserCurriculumMappingCreateWithoutCurriculumInput[] | UserCurriculumMappingUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutCurriculumInput | UserCurriculumMappingCreateOrConnectWithoutCurriculumInput[]
    createMany?: UserCurriculumMappingCreateManyCurriculumInputEnvelope
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
  }

  export type AcademicYearUncheckedCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<AcademicYearCreateWithoutCurriculumInput, AcademicYearUncheckedCreateWithoutCurriculumInput> | AcademicYearCreateWithoutCurriculumInput[] | AcademicYearUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutCurriculumInput | AcademicYearCreateOrConnectWithoutCurriculumInput[]
    createMany?: AcademicYearCreateManyCurriculumInputEnvelope
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<GradeCreateWithoutCurriculumInput, GradeUncheckedCreateWithoutCurriculumInput> | GradeCreateWithoutCurriculumInput[] | GradeUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCurriculumInput | GradeCreateOrConnectWithoutCurriculumInput[]
    createMany?: GradeCreateManyCurriculumInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type UserCurriculumMappingUncheckedCreateNestedManyWithoutCurriculumInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutCurriculumInput, UserCurriculumMappingUncheckedCreateWithoutCurriculumInput> | UserCurriculumMappingCreateWithoutCurriculumInput[] | UserCurriculumMappingUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutCurriculumInput | UserCurriculumMappingCreateOrConnectWithoutCurriculumInput[]
    createMany?: UserCurriculumMappingCreateManyCurriculumInputEnvelope
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type AcademicYearUpdateManyWithoutCurriculumNestedInput = {
    create?: XOR<AcademicYearCreateWithoutCurriculumInput, AcademicYearUncheckedCreateWithoutCurriculumInput> | AcademicYearCreateWithoutCurriculumInput[] | AcademicYearUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutCurriculumInput | AcademicYearCreateOrConnectWithoutCurriculumInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutCurriculumInput | AcademicYearUpsertWithWhereUniqueWithoutCurriculumInput[]
    createMany?: AcademicYearCreateManyCurriculumInputEnvelope
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutCurriculumInput | AcademicYearUpdateWithWhereUniqueWithoutCurriculumInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutCurriculumInput | AcademicYearUpdateManyWithWhereWithoutCurriculumInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutCurriculumNestedInput = {
    create?: XOR<GradeCreateWithoutCurriculumInput, GradeUncheckedCreateWithoutCurriculumInput> | GradeCreateWithoutCurriculumInput[] | GradeUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCurriculumInput | GradeCreateOrConnectWithoutCurriculumInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutCurriculumInput | GradeUpsertWithWhereUniqueWithoutCurriculumInput[]
    createMany?: GradeCreateManyCurriculumInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutCurriculumInput | GradeUpdateWithWhereUniqueWithoutCurriculumInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutCurriculumInput | GradeUpdateManyWithWhereWithoutCurriculumInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type UserCurriculumMappingUpdateManyWithoutCurriculumNestedInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutCurriculumInput, UserCurriculumMappingUncheckedCreateWithoutCurriculumInput> | UserCurriculumMappingCreateWithoutCurriculumInput[] | UserCurriculumMappingUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutCurriculumInput | UserCurriculumMappingCreateOrConnectWithoutCurriculumInput[]
    upsert?: UserCurriculumMappingUpsertWithWhereUniqueWithoutCurriculumInput | UserCurriculumMappingUpsertWithWhereUniqueWithoutCurriculumInput[]
    createMany?: UserCurriculumMappingCreateManyCurriculumInputEnvelope
    set?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    disconnect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    delete?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    update?: UserCurriculumMappingUpdateWithWhereUniqueWithoutCurriculumInput | UserCurriculumMappingUpdateWithWhereUniqueWithoutCurriculumInput[]
    updateMany?: UserCurriculumMappingUpdateManyWithWhereWithoutCurriculumInput | UserCurriculumMappingUpdateManyWithWhereWithoutCurriculumInput[]
    deleteMany?: UserCurriculumMappingScalarWhereInput | UserCurriculumMappingScalarWhereInput[]
  }

  export type AcademicYearUncheckedUpdateManyWithoutCurriculumNestedInput = {
    create?: XOR<AcademicYearCreateWithoutCurriculumInput, AcademicYearUncheckedCreateWithoutCurriculumInput> | AcademicYearCreateWithoutCurriculumInput[] | AcademicYearUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutCurriculumInput | AcademicYearCreateOrConnectWithoutCurriculumInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutCurriculumInput | AcademicYearUpsertWithWhereUniqueWithoutCurriculumInput[]
    createMany?: AcademicYearCreateManyCurriculumInputEnvelope
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutCurriculumInput | AcademicYearUpdateWithWhereUniqueWithoutCurriculumInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutCurriculumInput | AcademicYearUpdateManyWithWhereWithoutCurriculumInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutCurriculumNestedInput = {
    create?: XOR<GradeCreateWithoutCurriculumInput, GradeUncheckedCreateWithoutCurriculumInput> | GradeCreateWithoutCurriculumInput[] | GradeUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutCurriculumInput | GradeCreateOrConnectWithoutCurriculumInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutCurriculumInput | GradeUpsertWithWhereUniqueWithoutCurriculumInput[]
    createMany?: GradeCreateManyCurriculumInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutCurriculumInput | GradeUpdateWithWhereUniqueWithoutCurriculumInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutCurriculumInput | GradeUpdateManyWithWhereWithoutCurriculumInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type UserCurriculumMappingUncheckedUpdateManyWithoutCurriculumNestedInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutCurriculumInput, UserCurriculumMappingUncheckedCreateWithoutCurriculumInput> | UserCurriculumMappingCreateWithoutCurriculumInput[] | UserCurriculumMappingUncheckedCreateWithoutCurriculumInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutCurriculumInput | UserCurriculumMappingCreateOrConnectWithoutCurriculumInput[]
    upsert?: UserCurriculumMappingUpsertWithWhereUniqueWithoutCurriculumInput | UserCurriculumMappingUpsertWithWhereUniqueWithoutCurriculumInput[]
    createMany?: UserCurriculumMappingCreateManyCurriculumInputEnvelope
    set?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    disconnect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    delete?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    update?: UserCurriculumMappingUpdateWithWhereUniqueWithoutCurriculumInput | UserCurriculumMappingUpdateWithWhereUniqueWithoutCurriculumInput[]
    updateMany?: UserCurriculumMappingUpdateManyWithWhereWithoutCurriculumInput | UserCurriculumMappingUpdateManyWithWhereWithoutCurriculumInput[]
    deleteMany?: UserCurriculumMappingScalarWhereInput | UserCurriculumMappingScalarWhereInput[]
  }

  export type CurriculumCreateNestedOneWithoutAcademicYearsInput = {
    create?: XOR<CurriculumCreateWithoutAcademicYearsInput, CurriculumUncheckedCreateWithoutAcademicYearsInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutAcademicYearsInput
    connect?: CurriculumWhereUniqueInput
  }

  export type UserAcademicYearMappingCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput> | UserAcademicYearMappingCreateWithoutAcademicYearInput[] | UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput | UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput[]
    createMany?: UserAcademicYearMappingCreateManyAcademicYearInputEnvelope
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
  }

  export type UserAcademicYearMappingUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput> | UserAcademicYearMappingCreateWithoutAcademicYearInput[] | UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput | UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput[]
    createMany?: UserAcademicYearMappingCreateManyAcademicYearInputEnvelope
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CurriculumUpdateOneWithoutAcademicYearsNestedInput = {
    create?: XOR<CurriculumCreateWithoutAcademicYearsInput, CurriculumUncheckedCreateWithoutAcademicYearsInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutAcademicYearsInput
    upsert?: CurriculumUpsertWithoutAcademicYearsInput
    disconnect?: CurriculumWhereInput | boolean
    delete?: CurriculumWhereInput | boolean
    connect?: CurriculumWhereUniqueInput
    update?: XOR<XOR<CurriculumUpdateToOneWithWhereWithoutAcademicYearsInput, CurriculumUpdateWithoutAcademicYearsInput>, CurriculumUncheckedUpdateWithoutAcademicYearsInput>
  }

  export type UserAcademicYearMappingUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput> | UserAcademicYearMappingCreateWithoutAcademicYearInput[] | UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput | UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput[]
    upsert?: UserAcademicYearMappingUpsertWithWhereUniqueWithoutAcademicYearInput | UserAcademicYearMappingUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: UserAcademicYearMappingCreateManyAcademicYearInputEnvelope
    set?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    disconnect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    delete?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    update?: UserAcademicYearMappingUpdateWithWhereUniqueWithoutAcademicYearInput | UserAcademicYearMappingUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: UserAcademicYearMappingUpdateManyWithWhereWithoutAcademicYearInput | UserAcademicYearMappingUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserAcademicYearMappingUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput> | UserAcademicYearMappingCreateWithoutAcademicYearInput[] | UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput | UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput[]
    upsert?: UserAcademicYearMappingUpsertWithWhereUniqueWithoutAcademicYearInput | UserAcademicYearMappingUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: UserAcademicYearMappingCreateManyAcademicYearInputEnvelope
    set?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    disconnect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    delete?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    update?: UserAcademicYearMappingUpdateWithWhereUniqueWithoutAcademicYearInput | UserAcademicYearMappingUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: UserAcademicYearMappingUpdateManyWithWhereWithoutAcademicYearInput | UserAcademicYearMappingUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
  }

  export type ProfileCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProfileCreateWithoutLocationInput, ProfileUncheckedCreateWithoutLocationInput> | ProfileCreateWithoutLocationInput[] | ProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutLocationInput | ProfileCreateOrConnectWithoutLocationInput[]
    createMany?: ProfileCreateManyLocationInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ProfileCreateWithoutLocationInput, ProfileUncheckedCreateWithoutLocationInput> | ProfileCreateWithoutLocationInput[] | ProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutLocationInput | ProfileCreateOrConnectWithoutLocationInput[]
    createMany?: ProfileCreateManyLocationInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ProfileUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProfileCreateWithoutLocationInput, ProfileUncheckedCreateWithoutLocationInput> | ProfileCreateWithoutLocationInput[] | ProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutLocationInput | ProfileCreateOrConnectWithoutLocationInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutLocationInput | ProfileUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProfileCreateManyLocationInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutLocationInput | ProfileUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutLocationInput | ProfileUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ProfileCreateWithoutLocationInput, ProfileUncheckedCreateWithoutLocationInput> | ProfileCreateWithoutLocationInput[] | ProfileUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutLocationInput | ProfileCreateOrConnectWithoutLocationInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutLocationInput | ProfileUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ProfileCreateManyLocationInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutLocationInput | ProfileUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutLocationInput | ProfileUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutProfilesInput = {
    create?: XOR<LocationCreateWithoutProfilesInput, LocationUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProfilesInput
    connect?: LocationWhereUniqueInput
  }

  export type SchoolCreateNestedManyWithoutUserInput = {
    create?: XOR<SchoolCreateWithoutUserInput, SchoolUncheckedCreateWithoutUserInput> | SchoolCreateWithoutUserInput[] | SchoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutUserInput | SchoolCreateOrConnectWithoutUserInput[]
    createMany?: SchoolCreateManyUserInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCurriculumMappingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutUserInput, UserCurriculumMappingUncheckedCreateWithoutUserInput> | UserCurriculumMappingCreateWithoutUserInput[] | UserCurriculumMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutUserInput | UserCurriculumMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserCurriculumMappingCreateManyUserInputEnvelope
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
  }

  export type UserGradeMappingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGradeMappingCreateWithoutUserInput, UserGradeMappingUncheckedCreateWithoutUserInput> | UserGradeMappingCreateWithoutUserInput[] | UserGradeMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutUserInput | UserGradeMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserGradeMappingCreateManyUserInputEnvelope
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
  }

  export type UserSubjectMappingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubjectMappingCreateWithoutUserInput, UserSubjectMappingUncheckedCreateWithoutUserInput> | UserSubjectMappingCreateWithoutUserInput[] | UserSubjectMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutUserInput | UserSubjectMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserSubjectMappingCreateManyUserInputEnvelope
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
  }

  export type UserAcademicYearMappingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutUserInput, UserAcademicYearMappingUncheckedCreateWithoutUserInput> | UserAcademicYearMappingCreateWithoutUserInput[] | UserAcademicYearMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutUserInput | UserAcademicYearMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserAcademicYearMappingCreateManyUserInputEnvelope
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
  }

  export type AuthUserCreateNestedOneWithoutProfileInput = {
    create?: XOR<AuthUserCreateWithoutProfileInput, AuthUserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutProfileInput
    connect?: AuthUserWhereUniqueInput
  }

  export type SchoolUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SchoolCreateWithoutUserInput, SchoolUncheckedCreateWithoutUserInput> | SchoolCreateWithoutUserInput[] | SchoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutUserInput | SchoolCreateOrConnectWithoutUserInput[]
    createMany?: SchoolCreateManyUserInputEnvelope
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
  }

  export type UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutUserInput, UserCurriculumMappingUncheckedCreateWithoutUserInput> | UserCurriculumMappingCreateWithoutUserInput[] | UserCurriculumMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutUserInput | UserCurriculumMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserCurriculumMappingCreateManyUserInputEnvelope
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
  }

  export type UserGradeMappingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserGradeMappingCreateWithoutUserInput, UserGradeMappingUncheckedCreateWithoutUserInput> | UserGradeMappingCreateWithoutUserInput[] | UserGradeMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutUserInput | UserGradeMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserGradeMappingCreateManyUserInputEnvelope
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
  }

  export type UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSubjectMappingCreateWithoutUserInput, UserSubjectMappingUncheckedCreateWithoutUserInput> | UserSubjectMappingCreateWithoutUserInput[] | UserSubjectMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutUserInput | UserSubjectMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserSubjectMappingCreateManyUserInputEnvelope
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
  }

  export type UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutUserInput, UserAcademicYearMappingUncheckedCreateWithoutUserInput> | UserAcademicYearMappingCreateWithoutUserInput[] | UserAcademicYearMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutUserInput | UserAcademicYearMappingCreateOrConnectWithoutUserInput[]
    createMany?: UserAcademicYearMappingCreateManyUserInputEnvelope
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
  }

  export type AuthUserUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<AuthUserCreateWithoutProfileInput, AuthUserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutProfileInput
    connect?: AuthUserWhereUniqueInput
  }

  export type LocationUpdateOneWithoutProfilesNestedInput = {
    create?: XOR<LocationCreateWithoutProfilesInput, LocationUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutProfilesInput
    upsert?: LocationUpsertWithoutProfilesInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutProfilesInput, LocationUpdateWithoutProfilesInput>, LocationUncheckedUpdateWithoutProfilesInput>
  }

  export type SchoolUpdateManyWithoutUserNestedInput = {
    create?: XOR<SchoolCreateWithoutUserInput, SchoolUncheckedCreateWithoutUserInput> | SchoolCreateWithoutUserInput[] | SchoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutUserInput | SchoolCreateOrConnectWithoutUserInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutUserInput | SchoolUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SchoolCreateManyUserInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutUserInput | SchoolUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutUserInput | SchoolUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserCurriculumMappingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutUserInput, UserCurriculumMappingUncheckedCreateWithoutUserInput> | UserCurriculumMappingCreateWithoutUserInput[] | UserCurriculumMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutUserInput | UserCurriculumMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserCurriculumMappingUpsertWithWhereUniqueWithoutUserInput | UserCurriculumMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCurriculumMappingCreateManyUserInputEnvelope
    set?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    disconnect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    delete?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    update?: UserCurriculumMappingUpdateWithWhereUniqueWithoutUserInput | UserCurriculumMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCurriculumMappingUpdateManyWithWhereWithoutUserInput | UserCurriculumMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCurriculumMappingScalarWhereInput | UserCurriculumMappingScalarWhereInput[]
  }

  export type UserGradeMappingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGradeMappingCreateWithoutUserInput, UserGradeMappingUncheckedCreateWithoutUserInput> | UserGradeMappingCreateWithoutUserInput[] | UserGradeMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutUserInput | UserGradeMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserGradeMappingUpsertWithWhereUniqueWithoutUserInput | UserGradeMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGradeMappingCreateManyUserInputEnvelope
    set?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    disconnect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    delete?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    update?: UserGradeMappingUpdateWithWhereUniqueWithoutUserInput | UserGradeMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGradeMappingUpdateManyWithWhereWithoutUserInput | UserGradeMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGradeMappingScalarWhereInput | UserGradeMappingScalarWhereInput[]
  }

  export type UserSubjectMappingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubjectMappingCreateWithoutUserInput, UserSubjectMappingUncheckedCreateWithoutUserInput> | UserSubjectMappingCreateWithoutUserInput[] | UserSubjectMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutUserInput | UserSubjectMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserSubjectMappingUpsertWithWhereUniqueWithoutUserInput | UserSubjectMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubjectMappingCreateManyUserInputEnvelope
    set?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    disconnect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    delete?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    update?: UserSubjectMappingUpdateWithWhereUniqueWithoutUserInput | UserSubjectMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubjectMappingUpdateManyWithWhereWithoutUserInput | UserSubjectMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubjectMappingScalarWhereInput | UserSubjectMappingScalarWhereInput[]
  }

  export type UserAcademicYearMappingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutUserInput, UserAcademicYearMappingUncheckedCreateWithoutUserInput> | UserAcademicYearMappingCreateWithoutUserInput[] | UserAcademicYearMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutUserInput | UserAcademicYearMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserAcademicYearMappingUpsertWithWhereUniqueWithoutUserInput | UserAcademicYearMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAcademicYearMappingCreateManyUserInputEnvelope
    set?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    disconnect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    delete?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    update?: UserAcademicYearMappingUpdateWithWhereUniqueWithoutUserInput | UserAcademicYearMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAcademicYearMappingUpdateManyWithWhereWithoutUserInput | UserAcademicYearMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
  }

  export type AuthUserUpdateOneWithoutProfileNestedInput = {
    create?: XOR<AuthUserCreateWithoutProfileInput, AuthUserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutProfileInput
    upsert?: AuthUserUpsertWithoutProfileInput
    disconnect?: AuthUserWhereInput | boolean
    delete?: AuthUserWhereInput | boolean
    connect?: AuthUserWhereUniqueInput
    update?: XOR<XOR<AuthUserUpdateToOneWithWhereWithoutProfileInput, AuthUserUpdateWithoutProfileInput>, AuthUserUncheckedUpdateWithoutProfileInput>
  }

  export type SchoolUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SchoolCreateWithoutUserInput, SchoolUncheckedCreateWithoutUserInput> | SchoolCreateWithoutUserInput[] | SchoolUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SchoolCreateOrConnectWithoutUserInput | SchoolCreateOrConnectWithoutUserInput[]
    upsert?: SchoolUpsertWithWhereUniqueWithoutUserInput | SchoolUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SchoolCreateManyUserInputEnvelope
    set?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    disconnect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    delete?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    connect?: SchoolWhereUniqueInput | SchoolWhereUniqueInput[]
    update?: SchoolUpdateWithWhereUniqueWithoutUserInput | SchoolUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SchoolUpdateManyWithWhereWithoutUserInput | SchoolUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
  }

  export type UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCurriculumMappingCreateWithoutUserInput, UserCurriculumMappingUncheckedCreateWithoutUserInput> | UserCurriculumMappingCreateWithoutUserInput[] | UserCurriculumMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCurriculumMappingCreateOrConnectWithoutUserInput | UserCurriculumMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserCurriculumMappingUpsertWithWhereUniqueWithoutUserInput | UserCurriculumMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCurriculumMappingCreateManyUserInputEnvelope
    set?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    disconnect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    delete?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    connect?: UserCurriculumMappingWhereUniqueInput | UserCurriculumMappingWhereUniqueInput[]
    update?: UserCurriculumMappingUpdateWithWhereUniqueWithoutUserInput | UserCurriculumMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCurriculumMappingUpdateManyWithWhereWithoutUserInput | UserCurriculumMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCurriculumMappingScalarWhereInput | UserCurriculumMappingScalarWhereInput[]
  }

  export type UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserGradeMappingCreateWithoutUserInput, UserGradeMappingUncheckedCreateWithoutUserInput> | UserGradeMappingCreateWithoutUserInput[] | UserGradeMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutUserInput | UserGradeMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserGradeMappingUpsertWithWhereUniqueWithoutUserInput | UserGradeMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserGradeMappingCreateManyUserInputEnvelope
    set?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    disconnect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    delete?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    update?: UserGradeMappingUpdateWithWhereUniqueWithoutUserInput | UserGradeMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserGradeMappingUpdateManyWithWhereWithoutUserInput | UserGradeMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserGradeMappingScalarWhereInput | UserGradeMappingScalarWhereInput[]
  }

  export type UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSubjectMappingCreateWithoutUserInput, UserSubjectMappingUncheckedCreateWithoutUserInput> | UserSubjectMappingCreateWithoutUserInput[] | UserSubjectMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutUserInput | UserSubjectMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserSubjectMappingUpsertWithWhereUniqueWithoutUserInput | UserSubjectMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSubjectMappingCreateManyUserInputEnvelope
    set?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    disconnect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    delete?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    update?: UserSubjectMappingUpdateWithWhereUniqueWithoutUserInput | UserSubjectMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSubjectMappingUpdateManyWithWhereWithoutUserInput | UserSubjectMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSubjectMappingScalarWhereInput | UserSubjectMappingScalarWhereInput[]
  }

  export type UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutUserInput, UserAcademicYearMappingUncheckedCreateWithoutUserInput> | UserAcademicYearMappingCreateWithoutUserInput[] | UserAcademicYearMappingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutUserInput | UserAcademicYearMappingCreateOrConnectWithoutUserInput[]
    upsert?: UserAcademicYearMappingUpsertWithWhereUniqueWithoutUserInput | UserAcademicYearMappingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAcademicYearMappingCreateManyUserInputEnvelope
    set?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    disconnect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    delete?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    update?: UserAcademicYearMappingUpdateWithWhereUniqueWithoutUserInput | UserAcademicYearMappingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAcademicYearMappingUpdateManyWithWhereWithoutUserInput | UserAcademicYearMappingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
  }

  export type AuthUserUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<AuthUserCreateWithoutProfileInput, AuthUserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: AuthUserCreateOrConnectWithoutProfileInput
    upsert?: AuthUserUpsertWithoutProfileInput
    disconnect?: AuthUserWhereInput | boolean
    delete?: AuthUserWhereInput | boolean
    connect?: AuthUserWhereUniqueInput
    update?: XOR<XOR<AuthUserUpdateToOneWithWhereWithoutProfileInput, AuthUserUpdateWithoutProfileInput>, AuthUserUncheckedUpdateWithoutProfileInput>
  }

  export type CurriculumCreateNestedOneWithoutGradesInput = {
    create?: XOR<CurriculumCreateWithoutGradesInput, CurriculumUncheckedCreateWithoutGradesInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutGradesInput
    connect?: CurriculumWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutGradeInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type UserAcademicYearMappingCreateNestedManyWithoutStudentGradeInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput> | UserAcademicYearMappingCreateWithoutStudentGradeInput[] | UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput | UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput[]
    createMany?: UserAcademicYearMappingCreateManyStudentGradeInputEnvelope
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
  }

  export type UserGradeMappingCreateNestedManyWithoutGradeInput = {
    create?: XOR<UserGradeMappingCreateWithoutGradeInput, UserGradeMappingUncheckedCreateWithoutGradeInput> | UserGradeMappingCreateWithoutGradeInput[] | UserGradeMappingUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutGradeInput | UserGradeMappingCreateOrConnectWithoutGradeInput[]
    createMany?: UserGradeMappingCreateManyGradeInputEnvelope
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type UserAcademicYearMappingUncheckedCreateNestedManyWithoutStudentGradeInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput> | UserAcademicYearMappingCreateWithoutStudentGradeInput[] | UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput | UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput[]
    createMany?: UserAcademicYearMappingCreateManyStudentGradeInputEnvelope
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
  }

  export type UserGradeMappingUncheckedCreateNestedManyWithoutGradeInput = {
    create?: XOR<UserGradeMappingCreateWithoutGradeInput, UserGradeMappingUncheckedCreateWithoutGradeInput> | UserGradeMappingCreateWithoutGradeInput[] | UserGradeMappingUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutGradeInput | UserGradeMappingCreateOrConnectWithoutGradeInput[]
    createMany?: UserGradeMappingCreateManyGradeInputEnvelope
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
  }

  export type CurriculumUpdateOneWithoutGradesNestedInput = {
    create?: XOR<CurriculumCreateWithoutGradesInput, CurriculumUncheckedCreateWithoutGradesInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutGradesInput
    upsert?: CurriculumUpsertWithoutGradesInput
    disconnect?: CurriculumWhereInput | boolean
    delete?: CurriculumWhereInput | boolean
    connect?: CurriculumWhereUniqueInput
    update?: XOR<XOR<CurriculumUpdateToOneWithWhereWithoutGradesInput, CurriculumUpdateWithoutGradesInput>, CurriculumUncheckedUpdateWithoutGradesInput>
  }

  export type SubjectUpdateManyWithoutGradeNestedInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutGradeInput | SubjectUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutGradeInput | SubjectUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutGradeInput | SubjectUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type UserAcademicYearMappingUpdateManyWithoutStudentGradeNestedInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput> | UserAcademicYearMappingCreateWithoutStudentGradeInput[] | UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput | UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput[]
    upsert?: UserAcademicYearMappingUpsertWithWhereUniqueWithoutStudentGradeInput | UserAcademicYearMappingUpsertWithWhereUniqueWithoutStudentGradeInput[]
    createMany?: UserAcademicYearMappingCreateManyStudentGradeInputEnvelope
    set?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    disconnect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    delete?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    update?: UserAcademicYearMappingUpdateWithWhereUniqueWithoutStudentGradeInput | UserAcademicYearMappingUpdateWithWhereUniqueWithoutStudentGradeInput[]
    updateMany?: UserAcademicYearMappingUpdateManyWithWhereWithoutStudentGradeInput | UserAcademicYearMappingUpdateManyWithWhereWithoutStudentGradeInput[]
    deleteMany?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
  }

  export type UserGradeMappingUpdateManyWithoutGradeNestedInput = {
    create?: XOR<UserGradeMappingCreateWithoutGradeInput, UserGradeMappingUncheckedCreateWithoutGradeInput> | UserGradeMappingCreateWithoutGradeInput[] | UserGradeMappingUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutGradeInput | UserGradeMappingCreateOrConnectWithoutGradeInput[]
    upsert?: UserGradeMappingUpsertWithWhereUniqueWithoutGradeInput | UserGradeMappingUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: UserGradeMappingCreateManyGradeInputEnvelope
    set?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    disconnect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    delete?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    update?: UserGradeMappingUpdateWithWhereUniqueWithoutGradeInput | UserGradeMappingUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: UserGradeMappingUpdateManyWithWhereWithoutGradeInput | UserGradeMappingUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: UserGradeMappingScalarWhereInput | UserGradeMappingScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput> | SubjectCreateWithoutGradeInput[] | SubjectUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutGradeInput | SubjectCreateOrConnectWithoutGradeInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutGradeInput | SubjectUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: SubjectCreateManyGradeInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutGradeInput | SubjectUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutGradeInput | SubjectUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type UserAcademicYearMappingUncheckedUpdateManyWithoutStudentGradeNestedInput = {
    create?: XOR<UserAcademicYearMappingCreateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput> | UserAcademicYearMappingCreateWithoutStudentGradeInput[] | UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput[]
    connectOrCreate?: UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput | UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput[]
    upsert?: UserAcademicYearMappingUpsertWithWhereUniqueWithoutStudentGradeInput | UserAcademicYearMappingUpsertWithWhereUniqueWithoutStudentGradeInput[]
    createMany?: UserAcademicYearMappingCreateManyStudentGradeInputEnvelope
    set?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    disconnect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    delete?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    connect?: UserAcademicYearMappingWhereUniqueInput | UserAcademicYearMappingWhereUniqueInput[]
    update?: UserAcademicYearMappingUpdateWithWhereUniqueWithoutStudentGradeInput | UserAcademicYearMappingUpdateWithWhereUniqueWithoutStudentGradeInput[]
    updateMany?: UserAcademicYearMappingUpdateManyWithWhereWithoutStudentGradeInput | UserAcademicYearMappingUpdateManyWithWhereWithoutStudentGradeInput[]
    deleteMany?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
  }

  export type UserGradeMappingUncheckedUpdateManyWithoutGradeNestedInput = {
    create?: XOR<UserGradeMappingCreateWithoutGradeInput, UserGradeMappingUncheckedCreateWithoutGradeInput> | UserGradeMappingCreateWithoutGradeInput[] | UserGradeMappingUncheckedCreateWithoutGradeInput[]
    connectOrCreate?: UserGradeMappingCreateOrConnectWithoutGradeInput | UserGradeMappingCreateOrConnectWithoutGradeInput[]
    upsert?: UserGradeMappingUpsertWithWhereUniqueWithoutGradeInput | UserGradeMappingUpsertWithWhereUniqueWithoutGradeInput[]
    createMany?: UserGradeMappingCreateManyGradeInputEnvelope
    set?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    disconnect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    delete?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    connect?: UserGradeMappingWhereUniqueInput | UserGradeMappingWhereUniqueInput[]
    update?: UserGradeMappingUpdateWithWhereUniqueWithoutGradeInput | UserGradeMappingUpdateWithWhereUniqueWithoutGradeInput[]
    updateMany?: UserGradeMappingUpdateManyWithWhereWithoutGradeInput | UserGradeMappingUpdateManyWithWhereWithoutGradeInput[]
    deleteMany?: UserGradeMappingScalarWhereInput | UserGradeMappingScalarWhereInput[]
  }

  export type GradeCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectsInput
    connect?: GradeWhereUniqueInput
  }

  export type ChapterCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type UserSubjectMappingCreateNestedManyWithoutSubjectInput = {
    create?: XOR<UserSubjectMappingCreateWithoutSubjectInput, UserSubjectMappingUncheckedCreateWithoutSubjectInput> | UserSubjectMappingCreateWithoutSubjectInput[] | UserSubjectMappingUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutSubjectInput | UserSubjectMappingCreateOrConnectWithoutSubjectInput[]
    createMany?: UserSubjectMappingCreateManySubjectInputEnvelope
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type UserSubjectMappingUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<UserSubjectMappingCreateWithoutSubjectInput, UserSubjectMappingUncheckedCreateWithoutSubjectInput> | UserSubjectMappingCreateWithoutSubjectInput[] | UserSubjectMappingUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutSubjectInput | UserSubjectMappingCreateOrConnectWithoutSubjectInput[]
    createMany?: UserSubjectMappingCreateManySubjectInputEnvelope
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
  }

  export type GradeUpdateOneWithoutSubjectsNestedInput = {
    create?: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectsInput
    upsert?: GradeUpsertWithoutSubjectsInput
    disconnect?: GradeWhereInput | boolean
    delete?: GradeWhereInput | boolean
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutSubjectsInput, GradeUpdateWithoutSubjectsInput>, GradeUncheckedUpdateWithoutSubjectsInput>
  }

  export type ChapterUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type UserSubjectMappingUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<UserSubjectMappingCreateWithoutSubjectInput, UserSubjectMappingUncheckedCreateWithoutSubjectInput> | UserSubjectMappingCreateWithoutSubjectInput[] | UserSubjectMappingUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutSubjectInput | UserSubjectMappingCreateOrConnectWithoutSubjectInput[]
    upsert?: UserSubjectMappingUpsertWithWhereUniqueWithoutSubjectInput | UserSubjectMappingUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: UserSubjectMappingCreateManySubjectInputEnvelope
    set?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    disconnect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    delete?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    update?: UserSubjectMappingUpdateWithWhereUniqueWithoutSubjectInput | UserSubjectMappingUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: UserSubjectMappingUpdateManyWithWhereWithoutSubjectInput | UserSubjectMappingUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: UserSubjectMappingScalarWhereInput | UserSubjectMappingScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type UserSubjectMappingUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<UserSubjectMappingCreateWithoutSubjectInput, UserSubjectMappingUncheckedCreateWithoutSubjectInput> | UserSubjectMappingCreateWithoutSubjectInput[] | UserSubjectMappingUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: UserSubjectMappingCreateOrConnectWithoutSubjectInput | UserSubjectMappingCreateOrConnectWithoutSubjectInput[]
    upsert?: UserSubjectMappingUpsertWithWhereUniqueWithoutSubjectInput | UserSubjectMappingUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: UserSubjectMappingCreateManySubjectInputEnvelope
    set?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    disconnect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    delete?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    connect?: UserSubjectMappingWhereUniqueInput | UserSubjectMappingWhereUniqueInput[]
    update?: UserSubjectMappingUpdateWithWhereUniqueWithoutSubjectInput | UserSubjectMappingUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: UserSubjectMappingUpdateManyWithWhereWithoutSubjectInput | UserSubjectMappingUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: UserSubjectMappingScalarWhereInput | UserSubjectMappingScalarWhereInput[]
  }

  export type SubjectCreateNestedOneWithoutChaptersInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    connect?: SubjectWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type SubjectUpdateOneWithoutChaptersNestedInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    upsert?: SubjectUpsertWithoutChaptersInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutChaptersInput, SubjectUpdateWithoutChaptersInput>, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type ProfileCreateNestedOneWithoutSchoolsInput = {
    create?: XOR<ProfileCreateWithoutSchoolsInput, ProfileUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSchoolsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutSchoolsNestedInput = {
    create?: XOR<ProfileCreateWithoutSchoolsInput, ProfileUncheckedCreateWithoutSchoolsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSchoolsInput
    upsert?: ProfileUpsertWithoutSchoolsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSchoolsInput, ProfileUpdateWithoutSchoolsInput>, ProfileUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProfileCreateNestedOneWithoutAcademicYearsInput = {
    create?: XOR<ProfileCreateWithoutAcademicYearsInput, ProfileUncheckedCreateWithoutAcademicYearsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAcademicYearsInput
    connect?: ProfileWhereUniqueInput
  }

  export type GradeCreateNestedOneWithoutAcademicYearMappingsInput = {
    create?: XOR<GradeCreateWithoutAcademicYearMappingsInput, GradeUncheckedCreateWithoutAcademicYearMappingsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutAcademicYearMappingsInput
    connect?: GradeWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutUsersInput = {
    create?: XOR<AcademicYearCreateWithoutUsersInput, AcademicYearUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutUsersInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutAcademicYearsNestedInput = {
    create?: XOR<ProfileCreateWithoutAcademicYearsInput, ProfileUncheckedCreateWithoutAcademicYearsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAcademicYearsInput
    upsert?: ProfileUpsertWithoutAcademicYearsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutAcademicYearsInput, ProfileUpdateWithoutAcademicYearsInput>, ProfileUncheckedUpdateWithoutAcademicYearsInput>
  }

  export type GradeUpdateOneWithoutAcademicYearMappingsNestedInput = {
    create?: XOR<GradeCreateWithoutAcademicYearMappingsInput, GradeUncheckedCreateWithoutAcademicYearMappingsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutAcademicYearMappingsInput
    upsert?: GradeUpsertWithoutAcademicYearMappingsInput
    disconnect?: GradeWhereInput | boolean
    delete?: GradeWhereInput | boolean
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutAcademicYearMappingsInput, GradeUpdateWithoutAcademicYearMappingsInput>, GradeUncheckedUpdateWithoutAcademicYearMappingsInput>
  }

  export type AcademicYearUpdateOneWithoutUsersNestedInput = {
    create?: XOR<AcademicYearCreateWithoutUsersInput, AcademicYearUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutUsersInput
    upsert?: AcademicYearUpsertWithoutUsersInput
    disconnect?: AcademicYearWhereInput | boolean
    delete?: AcademicYearWhereInput | boolean
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutUsersInput, AcademicYearUpdateWithoutUsersInput>, AcademicYearUncheckedUpdateWithoutUsersInput>
  }

  export type ProfileCreateNestedOneWithoutUserCurriculumsInput = {
    create?: XOR<ProfileCreateWithoutUserCurriculumsInput, ProfileUncheckedCreateWithoutUserCurriculumsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserCurriculumsInput
    connect?: ProfileWhereUniqueInput
  }

  export type CurriculumCreateNestedOneWithoutUsersInput = {
    create?: XOR<CurriculumCreateWithoutUsersInput, CurriculumUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutUsersInput
    connect?: CurriculumWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutUserCurriculumsNestedInput = {
    create?: XOR<ProfileCreateWithoutUserCurriculumsInput, ProfileUncheckedCreateWithoutUserCurriculumsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserCurriculumsInput
    upsert?: ProfileUpsertWithoutUserCurriculumsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserCurriculumsInput, ProfileUpdateWithoutUserCurriculumsInput>, ProfileUncheckedUpdateWithoutUserCurriculumsInput>
  }

  export type CurriculumUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CurriculumCreateWithoutUsersInput, CurriculumUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CurriculumCreateOrConnectWithoutUsersInput
    upsert?: CurriculumUpsertWithoutUsersInput
    connect?: CurriculumWhereUniqueInput
    update?: XOR<XOR<CurriculumUpdateToOneWithWhereWithoutUsersInput, CurriculumUpdateWithoutUsersInput>, CurriculumUncheckedUpdateWithoutUsersInput>
  }

  export type ProfileCreateNestedOneWithoutUserGradesInput = {
    create?: XOR<ProfileCreateWithoutUserGradesInput, ProfileUncheckedCreateWithoutUserGradesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserGradesInput
    connect?: ProfileWhereUniqueInput
  }

  export type GradeCreateNestedOneWithoutUserGradeMappingsInput = {
    create?: XOR<GradeCreateWithoutUserGradeMappingsInput, GradeUncheckedCreateWithoutUserGradeMappingsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutUserGradeMappingsInput
    connect?: GradeWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutUserGradesNestedInput = {
    create?: XOR<ProfileCreateWithoutUserGradesInput, ProfileUncheckedCreateWithoutUserGradesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserGradesInput
    upsert?: ProfileUpsertWithoutUserGradesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserGradesInput, ProfileUpdateWithoutUserGradesInput>, ProfileUncheckedUpdateWithoutUserGradesInput>
  }

  export type GradeUpdateOneRequiredWithoutUserGradeMappingsNestedInput = {
    create?: XOR<GradeCreateWithoutUserGradeMappingsInput, GradeUncheckedCreateWithoutUserGradeMappingsInput>
    connectOrCreate?: GradeCreateOrConnectWithoutUserGradeMappingsInput
    upsert?: GradeUpsertWithoutUserGradeMappingsInput
    connect?: GradeWhereUniqueInput
    update?: XOR<XOR<GradeUpdateToOneWithWhereWithoutUserGradeMappingsInput, GradeUpdateWithoutUserGradeMappingsInput>, GradeUncheckedUpdateWithoutUserGradeMappingsInput>
  }

  export type ProfileCreateNestedOneWithoutUserSubjectsInput = {
    create?: XOR<ProfileCreateWithoutUserSubjectsInput, ProfileUncheckedCreateWithoutUserSubjectsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserSubjectsInput
    connect?: ProfileWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutUsersInput = {
    create?: XOR<SubjectCreateWithoutUsersInput, SubjectUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutUsersInput
    connect?: SubjectWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutUserSubjectsNestedInput = {
    create?: XOR<ProfileCreateWithoutUserSubjectsInput, ProfileUncheckedCreateWithoutUserSubjectsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserSubjectsInput
    upsert?: ProfileUpsertWithoutUserSubjectsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserSubjectsInput, ProfileUpdateWithoutUserSubjectsInput>, ProfileUncheckedUpdateWithoutUserSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SubjectCreateWithoutUsersInput, SubjectUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutUsersInput
    upsert?: SubjectUpsertWithoutUsersInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutUsersInput, SubjectUpdateWithoutUsersInput>, SubjectUncheckedUpdateWithoutUsersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type SessionCreateWithoutAuthInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutAuthInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutAuthInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutAuthInput, SessionUncheckedCreateWithoutAuthInput>
  }

  export type SessionCreateManyAuthInputEnvelope = {
    data: SessionCreateManyAuthInput | SessionCreateManyAuthInput[]
    skipDuplicates?: boolean
  }

  export type IdentityCreateWithoutAuthInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerId: string
    createdAt?: Date | string
  }

  export type IdentityUncheckedCreateWithoutAuthInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerId: string
    createdAt?: Date | string
  }

  export type IdentityCreateOrConnectWithoutAuthInput = {
    where: IdentityWhereUniqueInput
    create: XOR<IdentityCreateWithoutAuthInput, IdentityUncheckedCreateWithoutAuthInput>
  }

  export type IdentityCreateManyAuthInputEnvelope = {
    data: IdentityCreateManyAuthInput | IdentityCreateManyAuthInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutAuthUserInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    location?: LocationCreateNestedOneWithoutProfilesInput
    schools?: SchoolCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingCreateNestedManyWithoutUserInput
  }

  export type ProfileUncheckedCreateWithoutAuthUserInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolUncheckedCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingUncheckedCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput
  }

  export type ProfileCreateOrConnectWithoutAuthUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAuthUserInput, ProfileUncheckedCreateWithoutAuthUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutAuthInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutAuthInput, SessionUncheckedUpdateWithoutAuthInput>
    create: XOR<SessionCreateWithoutAuthInput, SessionUncheckedCreateWithoutAuthInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutAuthInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutAuthInput, SessionUncheckedUpdateWithoutAuthInput>
  }

  export type SessionUpdateManyWithWhereWithoutAuthInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutAuthInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    authId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type IdentityUpsertWithWhereUniqueWithoutAuthInput = {
    where: IdentityWhereUniqueInput
    update: XOR<IdentityUpdateWithoutAuthInput, IdentityUncheckedUpdateWithoutAuthInput>
    create: XOR<IdentityCreateWithoutAuthInput, IdentityUncheckedCreateWithoutAuthInput>
  }

  export type IdentityUpdateWithWhereUniqueWithoutAuthInput = {
    where: IdentityWhereUniqueInput
    data: XOR<IdentityUpdateWithoutAuthInput, IdentityUncheckedUpdateWithoutAuthInput>
  }

  export type IdentityUpdateManyWithWhereWithoutAuthInput = {
    where: IdentityScalarWhereInput
    data: XOR<IdentityUpdateManyMutationInput, IdentityUncheckedUpdateManyWithoutAuthInput>
  }

  export type IdentityScalarWhereInput = {
    AND?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
    OR?: IdentityScalarWhereInput[]
    NOT?: IdentityScalarWhereInput | IdentityScalarWhereInput[]
    id?: StringFilter<"Identity"> | string
    provider?: EnumAuthProviderFilter<"Identity"> | $Enums.AuthProvider
    providerId?: StringFilter<"Identity"> | string
    authId?: StringFilter<"Identity"> | string
    createdAt?: DateTimeFilter<"Identity"> | Date | string
  }

  export type ProfileUpsertWithoutAuthUserInput = {
    update: XOR<ProfileUpdateWithoutAuthUserInput, ProfileUncheckedUpdateWithoutAuthUserInput>
    create: XOR<ProfileCreateWithoutAuthUserInput, ProfileUncheckedCreateWithoutAuthUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutAuthUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutAuthUserInput, ProfileUncheckedUpdateWithoutAuthUserInput>
  }

  export type ProfileUpdateWithoutAuthUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutProfilesNestedInput
    schools?: SchoolUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUpdateManyWithoutUserNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAuthUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUncheckedUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuthUserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    identities?: IdentityCreateNestedManyWithoutAuthInput
    profile?: ProfileCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    identities?: IdentityUncheckedCreateNestedManyWithoutAuthInput
  }

  export type AuthUserCreateOrConnectWithoutSessionsInput = {
    where: AuthUserWhereUniqueInput
    create: XOR<AuthUserCreateWithoutSessionsInput, AuthUserUncheckedCreateWithoutSessionsInput>
  }

  export type AuthUserUpsertWithoutSessionsInput = {
    update: XOR<AuthUserUpdateWithoutSessionsInput, AuthUserUncheckedUpdateWithoutSessionsInput>
    create: XOR<AuthUserCreateWithoutSessionsInput, AuthUserUncheckedCreateWithoutSessionsInput>
    where?: AuthUserWhereInput
  }

  export type AuthUserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AuthUserWhereInput
    data: XOR<AuthUserUpdateWithoutSessionsInput, AuthUserUncheckedUpdateWithoutSessionsInput>
  }

  export type AuthUserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    identities?: IdentityUpdateManyWithoutAuthNestedInput
    profile?: ProfileUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    identities?: IdentityUncheckedUpdateManyWithoutAuthNestedInput
  }

  export type AuthUserCreateWithoutIdentitiesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutAuthInput
    profile?: ProfileCreateNestedOneWithoutAuthUserInput
  }

  export type AuthUserUncheckedCreateWithoutIdentitiesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutAuthInput
  }

  export type AuthUserCreateOrConnectWithoutIdentitiesInput = {
    where: AuthUserWhereUniqueInput
    create: XOR<AuthUserCreateWithoutIdentitiesInput, AuthUserUncheckedCreateWithoutIdentitiesInput>
  }

  export type AuthUserUpsertWithoutIdentitiesInput = {
    update: XOR<AuthUserUpdateWithoutIdentitiesInput, AuthUserUncheckedUpdateWithoutIdentitiesInput>
    create: XOR<AuthUserCreateWithoutIdentitiesInput, AuthUserUncheckedCreateWithoutIdentitiesInput>
    where?: AuthUserWhereInput
  }

  export type AuthUserUpdateToOneWithWhereWithoutIdentitiesInput = {
    where?: AuthUserWhereInput
    data: XOR<AuthUserUpdateWithoutIdentitiesInput, AuthUserUncheckedUpdateWithoutIdentitiesInput>
  }

  export type AuthUserUpdateWithoutIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutAuthNestedInput
    profile?: ProfileUpdateOneWithoutAuthUserNestedInput
  }

  export type AuthUserUncheckedUpdateWithoutIdentitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutAuthNestedInput
  }

  export type AcademicYearCreateWithoutCurriculumInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
    users?: UserAcademicYearMappingCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutCurriculumInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
    users?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutCurriculumInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutCurriculumInput, AcademicYearUncheckedCreateWithoutCurriculumInput>
  }

  export type AcademicYearCreateManyCurriculumInputEnvelope = {
    data: AcademicYearCreateManyCurriculumInput | AcademicYearCreateManyCurriculumInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutCurriculumInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    subjects?: SubjectCreateNestedManyWithoutGradeInput
    academicYearMappings?: UserAcademicYearMappingCreateNestedManyWithoutStudentGradeInput
    userGradeMappings?: UserGradeMappingCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutCurriculumInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradeInput
    academicYearMappings?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutStudentGradeInput
    userGradeMappings?: UserGradeMappingUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutCurriculumInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutCurriculumInput, GradeUncheckedCreateWithoutCurriculumInput>
  }

  export type GradeCreateManyCurriculumInputEnvelope = {
    data: GradeCreateManyCurriculumInput | GradeCreateManyCurriculumInput[]
    skipDuplicates?: boolean
  }

  export type UserCurriculumMappingCreateWithoutCurriculumInput = {
    user: ProfileCreateNestedOneWithoutUserCurriculumsInput
  }

  export type UserCurriculumMappingUncheckedCreateWithoutCurriculumInput = {
    userId: string
  }

  export type UserCurriculumMappingCreateOrConnectWithoutCurriculumInput = {
    where: UserCurriculumMappingWhereUniqueInput
    create: XOR<UserCurriculumMappingCreateWithoutCurriculumInput, UserCurriculumMappingUncheckedCreateWithoutCurriculumInput>
  }

  export type UserCurriculumMappingCreateManyCurriculumInputEnvelope = {
    data: UserCurriculumMappingCreateManyCurriculumInput | UserCurriculumMappingCreateManyCurriculumInput[]
    skipDuplicates?: boolean
  }

  export type AcademicYearUpsertWithWhereUniqueWithoutCurriculumInput = {
    where: AcademicYearWhereUniqueInput
    update: XOR<AcademicYearUpdateWithoutCurriculumInput, AcademicYearUncheckedUpdateWithoutCurriculumInput>
    create: XOR<AcademicYearCreateWithoutCurriculumInput, AcademicYearUncheckedCreateWithoutCurriculumInput>
  }

  export type AcademicYearUpdateWithWhereUniqueWithoutCurriculumInput = {
    where: AcademicYearWhereUniqueInput
    data: XOR<AcademicYearUpdateWithoutCurriculumInput, AcademicYearUncheckedUpdateWithoutCurriculumInput>
  }

  export type AcademicYearUpdateManyWithWhereWithoutCurriculumInput = {
    where: AcademicYearScalarWhereInput
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyWithoutCurriculumInput>
  }

  export type AcademicYearScalarWhereInput = {
    AND?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
    OR?: AcademicYearScalarWhereInput[]
    NOT?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
    id?: BigIntFilter<"AcademicYear"> | bigint | number
    name?: StringNullableFilter<"AcademicYear"> | string | null
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeNullableFilter<"AcademicYear"> | Date | string | null
    isActiveSession?: BoolNullableFilter<"AcademicYear"> | boolean | null
    isDeleted?: BoolNullableFilter<"AcademicYear"> | boolean | null
    curriculumId?: BigIntNullableFilter<"AcademicYear"> | bigint | number | null
  }

  export type GradeUpsertWithWhereUniqueWithoutCurriculumInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutCurriculumInput, GradeUncheckedUpdateWithoutCurriculumInput>
    create: XOR<GradeCreateWithoutCurriculumInput, GradeUncheckedCreateWithoutCurriculumInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutCurriculumInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutCurriculumInput, GradeUncheckedUpdateWithoutCurriculumInput>
  }

  export type GradeUpdateManyWithWhereWithoutCurriculumInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutCurriculumInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: BigIntFilter<"Grade"> | bigint | number
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    image?: StringNullableFilter<"Grade"> | string | null
    description?: StringNullableFilter<"Grade"> | string | null
    name?: StringNullableFilter<"Grade"> | string | null
    isDeleted?: BoolFilter<"Grade"> | boolean
    curriculumId?: BigIntNullableFilter<"Grade"> | bigint | number | null
  }

  export type UserCurriculumMappingUpsertWithWhereUniqueWithoutCurriculumInput = {
    where: UserCurriculumMappingWhereUniqueInput
    update: XOR<UserCurriculumMappingUpdateWithoutCurriculumInput, UserCurriculumMappingUncheckedUpdateWithoutCurriculumInput>
    create: XOR<UserCurriculumMappingCreateWithoutCurriculumInput, UserCurriculumMappingUncheckedCreateWithoutCurriculumInput>
  }

  export type UserCurriculumMappingUpdateWithWhereUniqueWithoutCurriculumInput = {
    where: UserCurriculumMappingWhereUniqueInput
    data: XOR<UserCurriculumMappingUpdateWithoutCurriculumInput, UserCurriculumMappingUncheckedUpdateWithoutCurriculumInput>
  }

  export type UserCurriculumMappingUpdateManyWithWhereWithoutCurriculumInput = {
    where: UserCurriculumMappingScalarWhereInput
    data: XOR<UserCurriculumMappingUpdateManyMutationInput, UserCurriculumMappingUncheckedUpdateManyWithoutCurriculumInput>
  }

  export type UserCurriculumMappingScalarWhereInput = {
    AND?: UserCurriculumMappingScalarWhereInput | UserCurriculumMappingScalarWhereInput[]
    OR?: UserCurriculumMappingScalarWhereInput[]
    NOT?: UserCurriculumMappingScalarWhereInput | UserCurriculumMappingScalarWhereInput[]
    userId?: UuidFilter<"UserCurriculumMapping"> | string
    curriculumId?: BigIntFilter<"UserCurriculumMapping"> | bigint | number
  }

  export type CurriculumCreateWithoutAcademicYearsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    grades?: GradeCreateNestedManyWithoutCurriculumInput
    users?: UserCurriculumMappingCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumUncheckedCreateWithoutAcademicYearsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    grades?: GradeUncheckedCreateNestedManyWithoutCurriculumInput
    users?: UserCurriculumMappingUncheckedCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumCreateOrConnectWithoutAcademicYearsInput = {
    where: CurriculumWhereUniqueInput
    create: XOR<CurriculumCreateWithoutAcademicYearsInput, CurriculumUncheckedCreateWithoutAcademicYearsInput>
  }

  export type UserAcademicYearMappingCreateWithoutAcademicYearInput = {
    id?: bigint | number
    createdAt?: Date | string
    user: ProfileCreateNestedOneWithoutAcademicYearsInput
    studentGrade?: GradeCreateNestedOneWithoutAcademicYearMappingsInput
  }

  export type UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput = {
    id?: bigint | number
    userId: string
    studentGradeId?: bigint | number | null
    createdAt?: Date | string
  }

  export type UserAcademicYearMappingCreateOrConnectWithoutAcademicYearInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    create: XOR<UserAcademicYearMappingCreateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput>
  }

  export type UserAcademicYearMappingCreateManyAcademicYearInputEnvelope = {
    data: UserAcademicYearMappingCreateManyAcademicYearInput | UserAcademicYearMappingCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type CurriculumUpsertWithoutAcademicYearsInput = {
    update: XOR<CurriculumUpdateWithoutAcademicYearsInput, CurriculumUncheckedUpdateWithoutAcademicYearsInput>
    create: XOR<CurriculumCreateWithoutAcademicYearsInput, CurriculumUncheckedCreateWithoutAcademicYearsInput>
    where?: CurriculumWhereInput
  }

  export type CurriculumUpdateToOneWithWhereWithoutAcademicYearsInput = {
    where?: CurriculumWhereInput
    data: XOR<CurriculumUpdateWithoutAcademicYearsInput, CurriculumUncheckedUpdateWithoutAcademicYearsInput>
  }

  export type CurriculumUpdateWithoutAcademicYearsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    grades?: GradeUpdateManyWithoutCurriculumNestedInput
    users?: UserCurriculumMappingUpdateManyWithoutCurriculumNestedInput
  }

  export type CurriculumUncheckedUpdateWithoutAcademicYearsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    grades?: GradeUncheckedUpdateManyWithoutCurriculumNestedInput
    users?: UserCurriculumMappingUncheckedUpdateManyWithoutCurriculumNestedInput
  }

  export type UserAcademicYearMappingUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    update: XOR<UserAcademicYearMappingUpdateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<UserAcademicYearMappingCreateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedCreateWithoutAcademicYearInput>
  }

  export type UserAcademicYearMappingUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    data: XOR<UserAcademicYearMappingUpdateWithoutAcademicYearInput, UserAcademicYearMappingUncheckedUpdateWithoutAcademicYearInput>
  }

  export type UserAcademicYearMappingUpdateManyWithWhereWithoutAcademicYearInput = {
    where: UserAcademicYearMappingScalarWhereInput
    data: XOR<UserAcademicYearMappingUpdateManyMutationInput, UserAcademicYearMappingUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type UserAcademicYearMappingScalarWhereInput = {
    AND?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
    OR?: UserAcademicYearMappingScalarWhereInput[]
    NOT?: UserAcademicYearMappingScalarWhereInput | UserAcademicYearMappingScalarWhereInput[]
    id?: BigIntFilter<"UserAcademicYearMapping"> | bigint | number
    userId?: UuidFilter<"UserAcademicYearMapping"> | string
    studentGradeId?: BigIntNullableFilter<"UserAcademicYearMapping"> | bigint | number | null
    academicYearId?: BigIntNullableFilter<"UserAcademicYearMapping"> | bigint | number | null
    createdAt?: DateTimeFilter<"UserAcademicYearMapping"> | Date | string
  }

  export type ProfileCreateWithoutLocationInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingCreateNestedManyWithoutUserInput
    authUser?: AuthUserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutLocationInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolUncheckedCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingUncheckedCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput
    authUser?: AuthUserUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutLocationInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLocationInput, ProfileUncheckedCreateWithoutLocationInput>
  }

  export type ProfileCreateManyLocationInputEnvelope = {
    data: ProfileCreateManyLocationInput | ProfileCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithWhereUniqueWithoutLocationInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutLocationInput, ProfileUncheckedUpdateWithoutLocationInput>
    create: XOR<ProfileCreateWithoutLocationInput, ProfileUncheckedCreateWithoutLocationInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutLocationInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutLocationInput, ProfileUncheckedUpdateWithoutLocationInput>
  }

  export type ProfileUpdateManyWithWhereWithoutLocationInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutLocationInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: UuidFilter<"Profile"> | string
    fullName?: StringFilter<"Profile"> | string
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    gender?: StringFilter<"Profile"> | string
    dob?: DateTimeNullableFilter<"Profile"> | Date | string | null
    locationId?: BigIntNullableFilter<"Profile"> | bigint | number | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    userType?: StringFilter<"Profile"> | string
    phoneNumber?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    isDeleted?: BoolFilter<"Profile"> | boolean
    isDeactivated?: BoolFilter<"Profile"> | boolean
    deviceId?: StringFilter<"Profile"> | string
    fcmDeviceToken?: StringNullableFilter<"Profile"> | string | null
    isNotificationEnabled?: BoolFilter<"Profile"> | boolean
  }

  export type LocationCreateWithoutProfilesInput = {
    id?: bigint | number
    name: string
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    sortOrder?: bigint | number
  }

  export type LocationUncheckedCreateWithoutProfilesInput = {
    id?: bigint | number
    name: string
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    sortOrder?: bigint | number
  }

  export type LocationCreateOrConnectWithoutProfilesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutProfilesInput, LocationUncheckedCreateWithoutProfilesInput>
  }

  export type SchoolCreateWithoutUserInput = {
    id?: bigint | number
    schoolName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SchoolUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    schoolName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type SchoolCreateOrConnectWithoutUserInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUserInput, SchoolUncheckedCreateWithoutUserInput>
  }

  export type SchoolCreateManyUserInputEnvelope = {
    data: SchoolCreateManyUserInput | SchoolCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCurriculumMappingCreateWithoutUserInput = {
    curriculum: CurriculumCreateNestedOneWithoutUsersInput
  }

  export type UserCurriculumMappingUncheckedCreateWithoutUserInput = {
    curriculumId: bigint | number
  }

  export type UserCurriculumMappingCreateOrConnectWithoutUserInput = {
    where: UserCurriculumMappingWhereUniqueInput
    create: XOR<UserCurriculumMappingCreateWithoutUserInput, UserCurriculumMappingUncheckedCreateWithoutUserInput>
  }

  export type UserCurriculumMappingCreateManyUserInputEnvelope = {
    data: UserCurriculumMappingCreateManyUserInput | UserCurriculumMappingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserGradeMappingCreateWithoutUserInput = {
    grade: GradeCreateNestedOneWithoutUserGradeMappingsInput
  }

  export type UserGradeMappingUncheckedCreateWithoutUserInput = {
    gradeId: bigint | number
  }

  export type UserGradeMappingCreateOrConnectWithoutUserInput = {
    where: UserGradeMappingWhereUniqueInput
    create: XOR<UserGradeMappingCreateWithoutUserInput, UserGradeMappingUncheckedCreateWithoutUserInput>
  }

  export type UserGradeMappingCreateManyUserInputEnvelope = {
    data: UserGradeMappingCreateManyUserInput | UserGradeMappingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSubjectMappingCreateWithoutUserInput = {
    subject: SubjectCreateNestedOneWithoutUsersInput
  }

  export type UserSubjectMappingUncheckedCreateWithoutUserInput = {
    subjectId: bigint | number
  }

  export type UserSubjectMappingCreateOrConnectWithoutUserInput = {
    where: UserSubjectMappingWhereUniqueInput
    create: XOR<UserSubjectMappingCreateWithoutUserInput, UserSubjectMappingUncheckedCreateWithoutUserInput>
  }

  export type UserSubjectMappingCreateManyUserInputEnvelope = {
    data: UserSubjectMappingCreateManyUserInput | UserSubjectMappingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAcademicYearMappingCreateWithoutUserInput = {
    id?: bigint | number
    createdAt?: Date | string
    studentGrade?: GradeCreateNestedOneWithoutAcademicYearMappingsInput
    academicYear?: AcademicYearCreateNestedOneWithoutUsersInput
  }

  export type UserAcademicYearMappingUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    studentGradeId?: bigint | number | null
    academicYearId?: bigint | number | null
    createdAt?: Date | string
  }

  export type UserAcademicYearMappingCreateOrConnectWithoutUserInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    create: XOR<UserAcademicYearMappingCreateWithoutUserInput, UserAcademicYearMappingUncheckedCreateWithoutUserInput>
  }

  export type UserAcademicYearMappingCreateManyUserInputEnvelope = {
    data: UserAcademicYearMappingCreateManyUserInput | UserAcademicYearMappingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuthUserCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutAuthInput
    identities?: IdentityCreateNestedManyWithoutAuthInput
  }

  export type AuthUserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash?: string | null
    emailVerifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutAuthInput
    identities?: IdentityUncheckedCreateNestedManyWithoutAuthInput
  }

  export type AuthUserCreateOrConnectWithoutProfileInput = {
    where: AuthUserWhereUniqueInput
    create: XOR<AuthUserCreateWithoutProfileInput, AuthUserUncheckedCreateWithoutProfileInput>
  }

  export type LocationUpsertWithoutProfilesInput = {
    update: XOR<LocationUpdateWithoutProfilesInput, LocationUncheckedUpdateWithoutProfilesInput>
    create: XOR<LocationCreateWithoutProfilesInput, LocationUncheckedCreateWithoutProfilesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutProfilesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutProfilesInput, LocationUncheckedUpdateWithoutProfilesInput>
  }

  export type LocationUpdateWithoutProfilesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type LocationUncheckedUpdateWithoutProfilesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sortOrder?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type SchoolUpsertWithWhereUniqueWithoutUserInput = {
    where: SchoolWhereUniqueInput
    update: XOR<SchoolUpdateWithoutUserInput, SchoolUncheckedUpdateWithoutUserInput>
    create: XOR<SchoolCreateWithoutUserInput, SchoolUncheckedCreateWithoutUserInput>
  }

  export type SchoolUpdateWithWhereUniqueWithoutUserInput = {
    where: SchoolWhereUniqueInput
    data: XOR<SchoolUpdateWithoutUserInput, SchoolUncheckedUpdateWithoutUserInput>
  }

  export type SchoolUpdateManyWithWhereWithoutUserInput = {
    where: SchoolScalarWhereInput
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyWithoutUserInput>
  }

  export type SchoolScalarWhereInput = {
    AND?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    OR?: SchoolScalarWhereInput[]
    NOT?: SchoolScalarWhereInput | SchoolScalarWhereInput[]
    id?: BigIntFilter<"School"> | bigint | number
    schoolName?: StringFilter<"School"> | string
    userId?: UuidFilter<"School"> | string
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeNullableFilter<"School"> | Date | string | null
  }

  export type UserCurriculumMappingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCurriculumMappingWhereUniqueInput
    update: XOR<UserCurriculumMappingUpdateWithoutUserInput, UserCurriculumMappingUncheckedUpdateWithoutUserInput>
    create: XOR<UserCurriculumMappingCreateWithoutUserInput, UserCurriculumMappingUncheckedCreateWithoutUserInput>
  }

  export type UserCurriculumMappingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCurriculumMappingWhereUniqueInput
    data: XOR<UserCurriculumMappingUpdateWithoutUserInput, UserCurriculumMappingUncheckedUpdateWithoutUserInput>
  }

  export type UserCurriculumMappingUpdateManyWithWhereWithoutUserInput = {
    where: UserCurriculumMappingScalarWhereInput
    data: XOR<UserCurriculumMappingUpdateManyMutationInput, UserCurriculumMappingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserGradeMappingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserGradeMappingWhereUniqueInput
    update: XOR<UserGradeMappingUpdateWithoutUserInput, UserGradeMappingUncheckedUpdateWithoutUserInput>
    create: XOR<UserGradeMappingCreateWithoutUserInput, UserGradeMappingUncheckedCreateWithoutUserInput>
  }

  export type UserGradeMappingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserGradeMappingWhereUniqueInput
    data: XOR<UserGradeMappingUpdateWithoutUserInput, UserGradeMappingUncheckedUpdateWithoutUserInput>
  }

  export type UserGradeMappingUpdateManyWithWhereWithoutUserInput = {
    where: UserGradeMappingScalarWhereInput
    data: XOR<UserGradeMappingUpdateManyMutationInput, UserGradeMappingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserGradeMappingScalarWhereInput = {
    AND?: UserGradeMappingScalarWhereInput | UserGradeMappingScalarWhereInput[]
    OR?: UserGradeMappingScalarWhereInput[]
    NOT?: UserGradeMappingScalarWhereInput | UserGradeMappingScalarWhereInput[]
    userId?: UuidFilter<"UserGradeMapping"> | string
    gradeId?: BigIntFilter<"UserGradeMapping"> | bigint | number
  }

  export type UserSubjectMappingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSubjectMappingWhereUniqueInput
    update: XOR<UserSubjectMappingUpdateWithoutUserInput, UserSubjectMappingUncheckedUpdateWithoutUserInput>
    create: XOR<UserSubjectMappingCreateWithoutUserInput, UserSubjectMappingUncheckedCreateWithoutUserInput>
  }

  export type UserSubjectMappingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSubjectMappingWhereUniqueInput
    data: XOR<UserSubjectMappingUpdateWithoutUserInput, UserSubjectMappingUncheckedUpdateWithoutUserInput>
  }

  export type UserSubjectMappingUpdateManyWithWhereWithoutUserInput = {
    where: UserSubjectMappingScalarWhereInput
    data: XOR<UserSubjectMappingUpdateManyMutationInput, UserSubjectMappingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSubjectMappingScalarWhereInput = {
    AND?: UserSubjectMappingScalarWhereInput | UserSubjectMappingScalarWhereInput[]
    OR?: UserSubjectMappingScalarWhereInput[]
    NOT?: UserSubjectMappingScalarWhereInput | UserSubjectMappingScalarWhereInput[]
    userId?: UuidFilter<"UserSubjectMapping"> | string
    subjectId?: BigIntFilter<"UserSubjectMapping"> | bigint | number
  }

  export type UserAcademicYearMappingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    update: XOR<UserAcademicYearMappingUpdateWithoutUserInput, UserAcademicYearMappingUncheckedUpdateWithoutUserInput>
    create: XOR<UserAcademicYearMappingCreateWithoutUserInput, UserAcademicYearMappingUncheckedCreateWithoutUserInput>
  }

  export type UserAcademicYearMappingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    data: XOR<UserAcademicYearMappingUpdateWithoutUserInput, UserAcademicYearMappingUncheckedUpdateWithoutUserInput>
  }

  export type UserAcademicYearMappingUpdateManyWithWhereWithoutUserInput = {
    where: UserAcademicYearMappingScalarWhereInput
    data: XOR<UserAcademicYearMappingUpdateManyMutationInput, UserAcademicYearMappingUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthUserUpsertWithoutProfileInput = {
    update: XOR<AuthUserUpdateWithoutProfileInput, AuthUserUncheckedUpdateWithoutProfileInput>
    create: XOR<AuthUserCreateWithoutProfileInput, AuthUserUncheckedCreateWithoutProfileInput>
    where?: AuthUserWhereInput
  }

  export type AuthUserUpdateToOneWithWhereWithoutProfileInput = {
    where?: AuthUserWhereInput
    data: XOR<AuthUserUpdateWithoutProfileInput, AuthUserUncheckedUpdateWithoutProfileInput>
  }

  export type AuthUserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutAuthNestedInput
    identities?: IdentityUpdateManyWithoutAuthNestedInput
  }

  export type AuthUserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutAuthNestedInput
    identities?: IdentityUncheckedUpdateManyWithoutAuthNestedInput
  }

  export type CurriculumCreateWithoutGradesInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    academicYears?: AcademicYearCreateNestedManyWithoutCurriculumInput
    users?: UserCurriculumMappingCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumUncheckedCreateWithoutGradesInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    academicYears?: AcademicYearUncheckedCreateNestedManyWithoutCurriculumInput
    users?: UserCurriculumMappingUncheckedCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumCreateOrConnectWithoutGradesInput = {
    where: CurriculumWhereUniqueInput
    create: XOR<CurriculumCreateWithoutGradesInput, CurriculumUncheckedCreateWithoutGradesInput>
  }

  export type SubjectCreateWithoutGradeInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    users?: UserSubjectMappingCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutGradeInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    users?: UserSubjectMappingUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutGradeInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput>
  }

  export type SubjectCreateManyGradeInputEnvelope = {
    data: SubjectCreateManyGradeInput | SubjectCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type UserAcademicYearMappingCreateWithoutStudentGradeInput = {
    id?: bigint | number
    createdAt?: Date | string
    user: ProfileCreateNestedOneWithoutAcademicYearsInput
    academicYear?: AcademicYearCreateNestedOneWithoutUsersInput
  }

  export type UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput = {
    id?: bigint | number
    userId: string
    academicYearId?: bigint | number | null
    createdAt?: Date | string
  }

  export type UserAcademicYearMappingCreateOrConnectWithoutStudentGradeInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    create: XOR<UserAcademicYearMappingCreateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput>
  }

  export type UserAcademicYearMappingCreateManyStudentGradeInputEnvelope = {
    data: UserAcademicYearMappingCreateManyStudentGradeInput | UserAcademicYearMappingCreateManyStudentGradeInput[]
    skipDuplicates?: boolean
  }

  export type UserGradeMappingCreateWithoutGradeInput = {
    user: ProfileCreateNestedOneWithoutUserGradesInput
  }

  export type UserGradeMappingUncheckedCreateWithoutGradeInput = {
    userId: string
  }

  export type UserGradeMappingCreateOrConnectWithoutGradeInput = {
    where: UserGradeMappingWhereUniqueInput
    create: XOR<UserGradeMappingCreateWithoutGradeInput, UserGradeMappingUncheckedCreateWithoutGradeInput>
  }

  export type UserGradeMappingCreateManyGradeInputEnvelope = {
    data: UserGradeMappingCreateManyGradeInput | UserGradeMappingCreateManyGradeInput[]
    skipDuplicates?: boolean
  }

  export type CurriculumUpsertWithoutGradesInput = {
    update: XOR<CurriculumUpdateWithoutGradesInput, CurriculumUncheckedUpdateWithoutGradesInput>
    create: XOR<CurriculumCreateWithoutGradesInput, CurriculumUncheckedCreateWithoutGradesInput>
    where?: CurriculumWhereInput
  }

  export type CurriculumUpdateToOneWithWhereWithoutGradesInput = {
    where?: CurriculumWhereInput
    data: XOR<CurriculumUpdateWithoutGradesInput, CurriculumUncheckedUpdateWithoutGradesInput>
  }

  export type CurriculumUpdateWithoutGradesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    academicYears?: AcademicYearUpdateManyWithoutCurriculumNestedInput
    users?: UserCurriculumMappingUpdateManyWithoutCurriculumNestedInput
  }

  export type CurriculumUncheckedUpdateWithoutGradesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    academicYears?: AcademicYearUncheckedUpdateManyWithoutCurriculumNestedInput
    users?: UserCurriculumMappingUncheckedUpdateManyWithoutCurriculumNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutGradeInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutGradeInput, SubjectUncheckedUpdateWithoutGradeInput>
    create: XOR<SubjectCreateWithoutGradeInput, SubjectUncheckedCreateWithoutGradeInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutGradeInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutGradeInput, SubjectUncheckedUpdateWithoutGradeInput>
  }

  export type SubjectUpdateManyWithWhereWithoutGradeInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutGradeInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: BigIntFilter<"Subject"> | bigint | number
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    name?: StringNullableFilter<"Subject"> | string | null
    image?: StringNullableFilter<"Subject"> | string | null
    description?: StringNullableFilter<"Subject"> | string | null
    isDeleted?: BoolFilter<"Subject"> | boolean
    gradeId?: BigIntNullableFilter<"Subject"> | bigint | number | null
  }

  export type UserAcademicYearMappingUpsertWithWhereUniqueWithoutStudentGradeInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    update: XOR<UserAcademicYearMappingUpdateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedUpdateWithoutStudentGradeInput>
    create: XOR<UserAcademicYearMappingCreateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedCreateWithoutStudentGradeInput>
  }

  export type UserAcademicYearMappingUpdateWithWhereUniqueWithoutStudentGradeInput = {
    where: UserAcademicYearMappingWhereUniqueInput
    data: XOR<UserAcademicYearMappingUpdateWithoutStudentGradeInput, UserAcademicYearMappingUncheckedUpdateWithoutStudentGradeInput>
  }

  export type UserAcademicYearMappingUpdateManyWithWhereWithoutStudentGradeInput = {
    where: UserAcademicYearMappingScalarWhereInput
    data: XOR<UserAcademicYearMappingUpdateManyMutationInput, UserAcademicYearMappingUncheckedUpdateManyWithoutStudentGradeInput>
  }

  export type UserGradeMappingUpsertWithWhereUniqueWithoutGradeInput = {
    where: UserGradeMappingWhereUniqueInput
    update: XOR<UserGradeMappingUpdateWithoutGradeInput, UserGradeMappingUncheckedUpdateWithoutGradeInput>
    create: XOR<UserGradeMappingCreateWithoutGradeInput, UserGradeMappingUncheckedCreateWithoutGradeInput>
  }

  export type UserGradeMappingUpdateWithWhereUniqueWithoutGradeInput = {
    where: UserGradeMappingWhereUniqueInput
    data: XOR<UserGradeMappingUpdateWithoutGradeInput, UserGradeMappingUncheckedUpdateWithoutGradeInput>
  }

  export type UserGradeMappingUpdateManyWithWhereWithoutGradeInput = {
    where: UserGradeMappingScalarWhereInput
    data: XOR<UserGradeMappingUpdateManyMutationInput, UserGradeMappingUncheckedUpdateManyWithoutGradeInput>
  }

  export type GradeCreateWithoutSubjectsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculum?: CurriculumCreateNestedOneWithoutGradesInput
    academicYearMappings?: UserAcademicYearMappingCreateNestedManyWithoutStudentGradeInput
    userGradeMappings?: UserGradeMappingCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutSubjectsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculumId?: bigint | number | null
    academicYearMappings?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutStudentGradeInput
    userGradeMappings?: UserGradeMappingUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutSubjectsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
  }

  export type ChapterCreateWithoutSubjectInput = {
    id?: bigint | number
    createdAt?: Date | string
    title: string
    sortOrder: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    isDeleted?: boolean
    label?: string | null
    updatedAt?: Date | string | null
    content?: string | null
    teacherGuide?: string | null
  }

  export type ChapterUncheckedCreateWithoutSubjectInput = {
    id?: bigint | number
    createdAt?: Date | string
    title: string
    sortOrder: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    isDeleted?: boolean
    label?: string | null
    updatedAt?: Date | string | null
    content?: string | null
    teacherGuide?: string | null
  }

  export type ChapterCreateOrConnectWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterCreateManySubjectInputEnvelope = {
    data: ChapterCreateManySubjectInput | ChapterCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type UserSubjectMappingCreateWithoutSubjectInput = {
    user: ProfileCreateNestedOneWithoutUserSubjectsInput
  }

  export type UserSubjectMappingUncheckedCreateWithoutSubjectInput = {
    userId: string
  }

  export type UserSubjectMappingCreateOrConnectWithoutSubjectInput = {
    where: UserSubjectMappingWhereUniqueInput
    create: XOR<UserSubjectMappingCreateWithoutSubjectInput, UserSubjectMappingUncheckedCreateWithoutSubjectInput>
  }

  export type UserSubjectMappingCreateManySubjectInputEnvelope = {
    data: UserSubjectMappingCreateManySubjectInput | UserSubjectMappingCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type GradeUpsertWithoutSubjectsInput = {
    update: XOR<GradeUpdateWithoutSubjectsInput, GradeUncheckedUpdateWithoutSubjectsInput>
    create: XOR<GradeCreateWithoutSubjectsInput, GradeUncheckedCreateWithoutSubjectsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutSubjectsInput, GradeUncheckedUpdateWithoutSubjectsInput>
  }

  export type GradeUpdateWithoutSubjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculum?: CurriculumUpdateOneWithoutGradesNestedInput
    academicYearMappings?: UserAcademicYearMappingUpdateManyWithoutStudentGradeNestedInput
    userGradeMappings?: UserGradeMappingUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutSubjectsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    academicYearMappings?: UserAcademicYearMappingUncheckedUpdateManyWithoutStudentGradeNestedInput
    userGradeMappings?: UserGradeMappingUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type ChapterUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
  }

  export type ChapterUpdateManyWithWhereWithoutSubjectInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: BigIntFilter<"Chapter"> | bigint | number
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    title?: StringFilter<"Chapter"> | string
    sortOrder?: DecimalFilter<"Chapter"> | Decimal | DecimalJsLike | number | string
    imageUrl?: StringNullableFilter<"Chapter"> | string | null
    isDeleted?: BoolFilter<"Chapter"> | boolean
    subjectId?: BigIntNullableFilter<"Chapter"> | bigint | number | null
    label?: StringNullableFilter<"Chapter"> | string | null
    updatedAt?: DateTimeNullableFilter<"Chapter"> | Date | string | null
    content?: StringNullableFilter<"Chapter"> | string | null
    teacherGuide?: StringNullableFilter<"Chapter"> | string | null
  }

  export type UserSubjectMappingUpsertWithWhereUniqueWithoutSubjectInput = {
    where: UserSubjectMappingWhereUniqueInput
    update: XOR<UserSubjectMappingUpdateWithoutSubjectInput, UserSubjectMappingUncheckedUpdateWithoutSubjectInput>
    create: XOR<UserSubjectMappingCreateWithoutSubjectInput, UserSubjectMappingUncheckedCreateWithoutSubjectInput>
  }

  export type UserSubjectMappingUpdateWithWhereUniqueWithoutSubjectInput = {
    where: UserSubjectMappingWhereUniqueInput
    data: XOR<UserSubjectMappingUpdateWithoutSubjectInput, UserSubjectMappingUncheckedUpdateWithoutSubjectInput>
  }

  export type UserSubjectMappingUpdateManyWithWhereWithoutSubjectInput = {
    where: UserSubjectMappingScalarWhereInput
    data: XOR<UserSubjectMappingUpdateManyMutationInput, UserSubjectMappingUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SubjectCreateWithoutChaptersInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    grade?: GradeCreateNestedOneWithoutSubjectsInput
    users?: UserSubjectMappingCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutChaptersInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    gradeId?: bigint | number | null
    users?: UserSubjectMappingUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutChaptersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
  }

  export type SubjectUpsertWithoutChaptersInput = {
    update: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutChaptersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type SubjectUpdateWithoutChaptersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    grade?: GradeUpdateOneWithoutSubjectsNestedInput
    users?: UserSubjectMappingUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutChaptersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    gradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    users?: UserSubjectMappingUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type ProfileCreateWithoutSchoolsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    location?: LocationCreateNestedOneWithoutProfilesInput
    userCurriculums?: UserCurriculumMappingCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingCreateNestedManyWithoutUserInput
    authUser?: AuthUserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutSchoolsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    userCurriculums?: UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingUncheckedCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput
    authUser?: AuthUserUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutSchoolsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSchoolsInput, ProfileUncheckedCreateWithoutSchoolsInput>
  }

  export type ProfileUpsertWithoutSchoolsInput = {
    update: XOR<ProfileUpdateWithoutSchoolsInput, ProfileUncheckedUpdateWithoutSchoolsInput>
    create: XOR<ProfileCreateWithoutSchoolsInput, ProfileUncheckedCreateWithoutSchoolsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSchoolsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSchoolsInput, ProfileUncheckedUpdateWithoutSchoolsInput>
  }

  export type ProfileUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutProfilesNestedInput
    userCurriculums?: UserCurriculumMappingUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSchoolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    userCurriculums?: UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type ProfileCreateWithoutAcademicYearsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    location?: LocationCreateNestedOneWithoutProfilesInput
    schools?: SchoolCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingCreateNestedManyWithoutUserInput
    authUser?: AuthUserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutAcademicYearsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolUncheckedCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingUncheckedCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput
    authUser?: AuthUserUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutAcademicYearsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAcademicYearsInput, ProfileUncheckedCreateWithoutAcademicYearsInput>
  }

  export type GradeCreateWithoutAcademicYearMappingsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculum?: CurriculumCreateNestedOneWithoutGradesInput
    subjects?: SubjectCreateNestedManyWithoutGradeInput
    userGradeMappings?: UserGradeMappingCreateNestedManyWithoutGradeInput
  }

  export type GradeUncheckedCreateWithoutAcademicYearMappingsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculumId?: bigint | number | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradeInput
    userGradeMappings?: UserGradeMappingUncheckedCreateNestedManyWithoutGradeInput
  }

  export type GradeCreateOrConnectWithoutAcademicYearMappingsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutAcademicYearMappingsInput, GradeUncheckedCreateWithoutAcademicYearMappingsInput>
  }

  export type AcademicYearCreateWithoutUsersInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
    curriculum?: CurriculumCreateNestedOneWithoutAcademicYearsInput
  }

  export type AcademicYearUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
    curriculumId?: bigint | number | null
  }

  export type AcademicYearCreateOrConnectWithoutUsersInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutUsersInput, AcademicYearUncheckedCreateWithoutUsersInput>
  }

  export type ProfileUpsertWithoutAcademicYearsInput = {
    update: XOR<ProfileUpdateWithoutAcademicYearsInput, ProfileUncheckedUpdateWithoutAcademicYearsInput>
    create: XOR<ProfileCreateWithoutAcademicYearsInput, ProfileUncheckedCreateWithoutAcademicYearsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutAcademicYearsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutAcademicYearsInput, ProfileUncheckedUpdateWithoutAcademicYearsInput>
  }

  export type ProfileUpdateWithoutAcademicYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutProfilesNestedInput
    schools?: SchoolUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAcademicYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUncheckedUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type GradeUpsertWithoutAcademicYearMappingsInput = {
    update: XOR<GradeUpdateWithoutAcademicYearMappingsInput, GradeUncheckedUpdateWithoutAcademicYearMappingsInput>
    create: XOR<GradeCreateWithoutAcademicYearMappingsInput, GradeUncheckedCreateWithoutAcademicYearMappingsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutAcademicYearMappingsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutAcademicYearMappingsInput, GradeUncheckedUpdateWithoutAcademicYearMappingsInput>
  }

  export type GradeUpdateWithoutAcademicYearMappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculum?: CurriculumUpdateOneWithoutGradesNestedInput
    subjects?: SubjectUpdateManyWithoutGradeNestedInput
    userGradeMappings?: UserGradeMappingUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutAcademicYearMappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subjects?: SubjectUncheckedUpdateManyWithoutGradeNestedInput
    userGradeMappings?: UserGradeMappingUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type AcademicYearUpsertWithoutUsersInput = {
    update: XOR<AcademicYearUpdateWithoutUsersInput, AcademicYearUncheckedUpdateWithoutUsersInput>
    create: XOR<AcademicYearCreateWithoutUsersInput, AcademicYearUncheckedCreateWithoutUsersInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutUsersInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutUsersInput, AcademicYearUncheckedUpdateWithoutUsersInput>
  }

  export type AcademicYearUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    curriculum?: CurriculumUpdateOneWithoutAcademicYearsNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type ProfileCreateWithoutUserCurriculumsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    location?: LocationCreateNestedOneWithoutProfilesInput
    schools?: SchoolCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingCreateNestedManyWithoutUserInput
    authUser?: AuthUserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserCurriculumsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolUncheckedCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingUncheckedCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput
    authUser?: AuthUserUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserCurriculumsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserCurriculumsInput, ProfileUncheckedCreateWithoutUserCurriculumsInput>
  }

  export type CurriculumCreateWithoutUsersInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    academicYears?: AcademicYearCreateNestedManyWithoutCurriculumInput
    grades?: GradeCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string
    name?: string | null
    description?: string | null
    isDeleted?: boolean
    academicYears?: AcademicYearUncheckedCreateNestedManyWithoutCurriculumInput
    grades?: GradeUncheckedCreateNestedManyWithoutCurriculumInput
  }

  export type CurriculumCreateOrConnectWithoutUsersInput = {
    where: CurriculumWhereUniqueInput
    create: XOR<CurriculumCreateWithoutUsersInput, CurriculumUncheckedCreateWithoutUsersInput>
  }

  export type ProfileUpsertWithoutUserCurriculumsInput = {
    update: XOR<ProfileUpdateWithoutUserCurriculumsInput, ProfileUncheckedUpdateWithoutUserCurriculumsInput>
    create: XOR<ProfileCreateWithoutUserCurriculumsInput, ProfileUncheckedCreateWithoutUserCurriculumsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserCurriculumsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserCurriculumsInput, ProfileUncheckedUpdateWithoutUserCurriculumsInput>
  }

  export type ProfileUpdateWithoutUserCurriculumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutProfilesNestedInput
    schools?: SchoolUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserCurriculumsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUncheckedUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type CurriculumUpsertWithoutUsersInput = {
    update: XOR<CurriculumUpdateWithoutUsersInput, CurriculumUncheckedUpdateWithoutUsersInput>
    create: XOR<CurriculumCreateWithoutUsersInput, CurriculumUncheckedCreateWithoutUsersInput>
    where?: CurriculumWhereInput
  }

  export type CurriculumUpdateToOneWithWhereWithoutUsersInput = {
    where?: CurriculumWhereInput
    data: XOR<CurriculumUpdateWithoutUsersInput, CurriculumUncheckedUpdateWithoutUsersInput>
  }

  export type CurriculumUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    academicYears?: AcademicYearUpdateManyWithoutCurriculumNestedInput
    grades?: GradeUpdateManyWithoutCurriculumNestedInput
  }

  export type CurriculumUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    academicYears?: AcademicYearUncheckedUpdateManyWithoutCurriculumNestedInput
    grades?: GradeUncheckedUpdateManyWithoutCurriculumNestedInput
  }

  export type ProfileCreateWithoutUserGradesInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    location?: LocationCreateNestedOneWithoutProfilesInput
    schools?: SchoolCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingCreateNestedManyWithoutUserInput
    authUser?: AuthUserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserGradesInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolUncheckedCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput
    userSubjects?: UserSubjectMappingUncheckedCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput
    authUser?: AuthUserUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserGradesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserGradesInput, ProfileUncheckedCreateWithoutUserGradesInput>
  }

  export type GradeCreateWithoutUserGradeMappingsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculum?: CurriculumCreateNestedOneWithoutGradesInput
    subjects?: SubjectCreateNestedManyWithoutGradeInput
    academicYearMappings?: UserAcademicYearMappingCreateNestedManyWithoutStudentGradeInput
  }

  export type GradeUncheckedCreateWithoutUserGradeMappingsInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
    curriculumId?: bigint | number | null
    subjects?: SubjectUncheckedCreateNestedManyWithoutGradeInput
    academicYearMappings?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutStudentGradeInput
  }

  export type GradeCreateOrConnectWithoutUserGradeMappingsInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutUserGradeMappingsInput, GradeUncheckedCreateWithoutUserGradeMappingsInput>
  }

  export type ProfileUpsertWithoutUserGradesInput = {
    update: XOR<ProfileUpdateWithoutUserGradesInput, ProfileUncheckedUpdateWithoutUserGradesInput>
    create: XOR<ProfileCreateWithoutUserGradesInput, ProfileUncheckedCreateWithoutUserGradesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserGradesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserGradesInput, ProfileUncheckedUpdateWithoutUserGradesInput>
  }

  export type ProfileUpdateWithoutUserGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutProfilesNestedInput
    schools?: SchoolUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUncheckedUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type GradeUpsertWithoutUserGradeMappingsInput = {
    update: XOR<GradeUpdateWithoutUserGradeMappingsInput, GradeUncheckedUpdateWithoutUserGradeMappingsInput>
    create: XOR<GradeCreateWithoutUserGradeMappingsInput, GradeUncheckedCreateWithoutUserGradeMappingsInput>
    where?: GradeWhereInput
  }

  export type GradeUpdateToOneWithWhereWithoutUserGradeMappingsInput = {
    where?: GradeWhereInput
    data: XOR<GradeUpdateWithoutUserGradeMappingsInput, GradeUncheckedUpdateWithoutUserGradeMappingsInput>
  }

  export type GradeUpdateWithoutUserGradeMappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculum?: CurriculumUpdateOneWithoutGradesNestedInput
    subjects?: SubjectUpdateManyWithoutGradeNestedInput
    academicYearMappings?: UserAcademicYearMappingUpdateManyWithoutStudentGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutUserGradeMappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    curriculumId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    subjects?: SubjectUncheckedUpdateManyWithoutGradeNestedInput
    academicYearMappings?: UserAcademicYearMappingUncheckedUpdateManyWithoutStudentGradeNestedInput
  }

  export type ProfileCreateWithoutUserSubjectsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    location?: LocationCreateNestedOneWithoutProfilesInput
    schools?: SchoolCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingCreateNestedManyWithoutUserInput
    authUser?: AuthUserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserSubjectsInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    locationId?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
    schools?: SchoolUncheckedCreateNestedManyWithoutUserInput
    userCurriculums?: UserCurriculumMappingUncheckedCreateNestedManyWithoutUserInput
    userGrades?: UserGradeMappingUncheckedCreateNestedManyWithoutUserInput
    academicYears?: UserAcademicYearMappingUncheckedCreateNestedManyWithoutUserInput
    authUser?: AuthUserUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserSubjectsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserSubjectsInput, ProfileUncheckedCreateWithoutUserSubjectsInput>
  }

  export type SubjectCreateWithoutUsersInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    grade?: GradeCreateNestedOneWithoutSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
    gradeId?: bigint | number | null
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutUsersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutUsersInput, SubjectUncheckedCreateWithoutUsersInput>
  }

  export type ProfileUpsertWithoutUserSubjectsInput = {
    update: XOR<ProfileUpdateWithoutUserSubjectsInput, ProfileUncheckedUpdateWithoutUserSubjectsInput>
    create: XOR<ProfileCreateWithoutUserSubjectsInput, ProfileUncheckedCreateWithoutUserSubjectsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserSubjectsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserSubjectsInput, ProfileUncheckedUpdateWithoutUserSubjectsInput>
  }

  export type ProfileUpdateWithoutUserSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneWithoutProfilesNestedInput
    schools?: SchoolUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUncheckedUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type SubjectUpsertWithoutUsersInput = {
    update: XOR<SubjectUpdateWithoutUsersInput, SubjectUncheckedUpdateWithoutUsersInput>
    create: XOR<SubjectCreateWithoutUsersInput, SubjectUncheckedCreateWithoutUsersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutUsersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutUsersInput, SubjectUncheckedUpdateWithoutUsersInput>
  }

  export type SubjectUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    grade?: GradeUpdateOneWithoutSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    gradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SessionCreateManyAuthInput = {
    id?: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type IdentityCreateManyAuthInput = {
    id?: string
    provider: $Enums.AuthProvider
    providerId: string
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUpdateWithoutAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUncheckedUpdateWithoutAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdentityUncheckedUpdateManyWithoutAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    providerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearCreateManyCurriculumInput = {
    id?: bigint | number
    name?: string | null
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    isActiveSession?: boolean | null
    isDeleted?: boolean | null
  }

  export type GradeCreateManyCurriculumInput = {
    id?: bigint | number
    createdAt?: Date | string
    image?: string | null
    description?: string | null
    name?: string | null
    isDeleted?: boolean
  }

  export type UserCurriculumMappingCreateManyCurriculumInput = {
    userId: string
  }

  export type AcademicYearUpdateWithoutCurriculumInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: UserAcademicYearMappingUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutCurriculumInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: UserAcademicYearMappingUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateManyWithoutCurriculumInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActiveSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isDeleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type GradeUpdateWithoutCurriculumInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    subjects?: SubjectUpdateManyWithoutGradeNestedInput
    academicYearMappings?: UserAcademicYearMappingUpdateManyWithoutStudentGradeNestedInput
    userGradeMappings?: UserGradeMappingUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateWithoutCurriculumInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    subjects?: SubjectUncheckedUpdateManyWithoutGradeNestedInput
    academicYearMappings?: UserAcademicYearMappingUncheckedUpdateManyWithoutStudentGradeNestedInput
    userGradeMappings?: UserGradeMappingUncheckedUpdateManyWithoutGradeNestedInput
  }

  export type GradeUncheckedUpdateManyWithoutCurriculumInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCurriculumMappingUpdateWithoutCurriculumInput = {
    user?: ProfileUpdateOneRequiredWithoutUserCurriculumsNestedInput
  }

  export type UserCurriculumMappingUncheckedUpdateWithoutCurriculumInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCurriculumMappingUncheckedUpdateManyWithoutCurriculumInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserAcademicYearMappingCreateManyAcademicYearInput = {
    id?: bigint | number
    userId: string
    studentGradeId?: bigint | number | null
    createdAt?: Date | string
  }

  export type UserAcademicYearMappingUpdateWithoutAcademicYearInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutAcademicYearsNestedInput
    studentGrade?: GradeUpdateOneWithoutAcademicYearMappingsNestedInput
  }

  export type UserAcademicYearMappingUncheckedUpdateWithoutAcademicYearInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    studentGradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademicYearMappingUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    studentGradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyLocationInput = {
    id: string
    fullName: string
    avatarUrl?: string | null
    gender: string
    dob?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userType: string
    phoneNumber?: string | null
    email?: string | null
    isDeleted?: boolean
    isDeactivated?: boolean
    deviceId?: string
    fcmDeviceToken?: string | null
    isNotificationEnabled?: boolean
  }

  export type ProfileUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    schools?: SchoolUncheckedUpdateManyWithoutUserNestedInput
    userCurriculums?: UserCurriculumMappingUncheckedUpdateManyWithoutUserNestedInput
    userGrades?: UserGradeMappingUncheckedUpdateManyWithoutUserNestedInput
    userSubjects?: UserSubjectMappingUncheckedUpdateManyWithoutUserNestedInput
    academicYears?: UserAcademicYearMappingUncheckedUpdateManyWithoutUserNestedInput
    authUser?: AuthUserUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userType?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    isDeactivated?: BoolFieldUpdateOperationsInput | boolean
    deviceId?: StringFieldUpdateOperationsInput | string
    fcmDeviceToken?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SchoolCreateManyUserInput = {
    id?: bigint | number
    schoolName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type UserCurriculumMappingCreateManyUserInput = {
    curriculumId: bigint | number
  }

  export type UserGradeMappingCreateManyUserInput = {
    gradeId: bigint | number
  }

  export type UserSubjectMappingCreateManyUserInput = {
    subjectId: bigint | number
  }

  export type UserAcademicYearMappingCreateManyUserInput = {
    id?: bigint | number
    studentGradeId?: bigint | number | null
    academicYearId?: bigint | number | null
    createdAt?: Date | string
  }

  export type SchoolUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    schoolName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SchoolUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    schoolName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SchoolUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    schoolName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCurriculumMappingUpdateWithoutUserInput = {
    curriculum?: CurriculumUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserCurriculumMappingUncheckedUpdateWithoutUserInput = {
    curriculumId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserCurriculumMappingUncheckedUpdateManyWithoutUserInput = {
    curriculumId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserGradeMappingUpdateWithoutUserInput = {
    grade?: GradeUpdateOneRequiredWithoutUserGradeMappingsNestedInput
  }

  export type UserGradeMappingUncheckedUpdateWithoutUserInput = {
    gradeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserGradeMappingUncheckedUpdateManyWithoutUserInput = {
    gradeId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSubjectMappingUpdateWithoutUserInput = {
    subject?: SubjectUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSubjectMappingUncheckedUpdateWithoutUserInput = {
    subjectId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserSubjectMappingUncheckedUpdateManyWithoutUserInput = {
    subjectId?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type UserAcademicYearMappingUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentGrade?: GradeUpdateOneWithoutAcademicYearMappingsNestedInput
    academicYear?: AcademicYearUpdateOneWithoutUsersNestedInput
  }

  export type UserAcademicYearMappingUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    studentGradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    academicYearId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademicYearMappingUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    studentGradeId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    academicYearId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateManyGradeInput = {
    id?: bigint | number
    createdAt?: Date | string
    name?: string | null
    image?: string | null
    description?: string | null
    isDeleted?: boolean
  }

  export type UserAcademicYearMappingCreateManyStudentGradeInput = {
    id?: bigint | number
    userId: string
    academicYearId?: bigint | number | null
    createdAt?: Date | string
  }

  export type UserGradeMappingCreateManyGradeInput = {
    userId: string
  }

  export type SubjectUpdateWithoutGradeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    users?: UserSubjectMappingUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutGradeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    users?: UserSubjectMappingUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutGradeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAcademicYearMappingUpdateWithoutStudentGradeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutAcademicYearsNestedInput
    academicYear?: AcademicYearUpdateOneWithoutUsersNestedInput
  }

  export type UserAcademicYearMappingUncheckedUpdateWithoutStudentGradeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    academicYearId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademicYearMappingUncheckedUpdateManyWithoutStudentGradeInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: StringFieldUpdateOperationsInput | string
    academicYearId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserGradeMappingUpdateWithoutGradeInput = {
    user?: ProfileUpdateOneRequiredWithoutUserGradesNestedInput
  }

  export type UserGradeMappingUncheckedUpdateWithoutGradeInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserGradeMappingUncheckedUpdateManyWithoutGradeInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterCreateManySubjectInput = {
    id?: bigint | number
    createdAt?: Date | string
    title: string
    sortOrder: Decimal | DecimalJsLike | number | string
    imageUrl?: string | null
    isDeleted?: boolean
    label?: string | null
    updatedAt?: Date | string | null
    content?: string | null
    teacherGuide?: string | null
  }

  export type UserSubjectMappingCreateManySubjectInput = {
    userId: string
  }

  export type ChapterUpdateWithoutSubjectInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    sortOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    label?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    teacherGuide?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChapterUncheckedUpdateWithoutSubjectInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    sortOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    label?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    teacherGuide?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    sortOrder?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    label?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    teacherGuide?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserSubjectMappingUpdateWithoutSubjectInput = {
    user?: ProfileUpdateOneRequiredWithoutUserSubjectsNestedInput
  }

  export type UserSubjectMappingUncheckedUpdateWithoutSubjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSubjectMappingUncheckedUpdateManyWithoutSubjectInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}